/* Parallel Hierarchical Grid -- an adaptive finite element library.
 *
 * Copyright (C) 2005-2010 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences. */

/* This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301  USA */

/* $Id: quad.c,v 1.275 2022/08/25 06:59:12 zlb Exp $ */

/* Numerical Quadrature */

#include "phg.h"
#include "phg/quad-gauss.h"
#include "phg/quad-permu.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

#ifdef Length
# undef Length
#endif
#define Length(wts)	(sizeof(wts) / (sizeof(wts[0])))

/*--------------------------- 1D quadrature rules ------------------------*/

static FLOAT QUAD_1D_P1_wts[] = {
    Dup2(1.)
};
static FLOAT QUAD_1D_P1_pts[Length(QUAD_1D_P1_wts) * 2] = {
    Perm2(.5)
};
static QUAD QUAD_1D_P1_ = {
    "1D P1",			/* name */
    1,				/* dim */
    1,				/* order */
    Length(QUAD_1D_P1_wts),	/* npoints */
    QUAD_1D_P1_pts,		/* points */
    QUAD_1D_P1_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P1 (&QUAD_1D_P1_)

static FLOAT QUAD_1D_P3_wts[] = {
    Dup11(.5)
};
static FLOAT QUAD_1D_P3_pts[Length(QUAD_1D_P3_wts) * 2] = {
    /* (3 - sqrt(3)) / 6, (3 + sqrt(3)) / 6 */
    Perm11(.21132486540518711774542560974902127)
};
static QUAD QUAD_1D_P3_ = {
    "1D P3",			/* name */
    1,				/* dim */
    3,				/* order */
    Length(QUAD_1D_P3_wts),	/* npoints */
    QUAD_1D_P3_pts,		/* points */
    QUAD_1D_P3_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P3 (&QUAD_1D_P3_)

static FLOAT QUAD_1D_P5_wts[] = {
    Dup11(5./18.),
    Dup2(4./9.)
};
static FLOAT QUAD_1D_P5_pts[Length(QUAD_1D_P5_wts) * 2] = {
    /* (5 - sqrt(15)) / 10, 1 / 2, (5 + sqrt(15)) / 10 */
    Perm11(.11270166537925831148207346002176004),
    Perm2(.5)
};
static QUAD QUAD_1D_P5_ = {
    "1D P5",			/* name */
    1,				/* dim */
    5,				/* order */
    Length(QUAD_1D_P5_wts),	/* npoints */
    QUAD_1D_P5_pts,		/* points */
    QUAD_1D_P5_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P5 (&QUAD_1D_P5_)

static FLOAT QUAD_1D_P7_wts[] = {
    /* (18 - sqrt(30)) / 72, (18 + sqrt(30)) / 72 */
    Dup11(.17392742256872692868653197461099970),
    Dup11(.32607257743127307131346802538900030)
};
static FLOAT QUAD_1D_P7_pts[Length(QUAD_1D_P7_wts) * 2] = {
    /* (35 \pm sqrt(525 \pm 70 * sqrt(30))) / 70 */
    Perm11(.06943184420297371238802675555359525),
    Perm11(.33000947820757186759866712044837766)
};
static QUAD QUAD_1D_P7_ = {
    "1D P7",			/* name */
    1,				/* dim */
    7,				/* order */
    Length(QUAD_1D_P7_wts),	/* npoints */
    QUAD_1D_P7_pts,		/* points */
    QUAD_1D_P7_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P7 (&QUAD_1D_P7_)

static FLOAT QUAD_1D_P9_wts[] = {
    /* (322 \pm 13 * sqrt(70)) / 1800 */
    Dup2(128./450.),
    Dup11(.11846344252809454375713202035995868),
    Dup11(.23931433524968323402064575741781910)
};
static FLOAT QUAD_1D_P9_pts[Length(QUAD_1D_P9_wts) * 2] = {
    /* (21 \pm sqrt(245 \pm 14 * sqrt(70))) / 42 */
    Perm2(0.5),
    Perm11(.04691007703066800360118656085030352),
    Perm11(.23076534494715845448184278964989560)
};
static QUAD QUAD_1D_P9_ = {
    "1D P9",			/* name */
    1,				/* dim */
    9,				/* order */
    Length(QUAD_1D_P9_wts),	/* npoints */
    QUAD_1D_P9_pts,		/* points */
    QUAD_1D_P9_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P9 (&QUAD_1D_P9_)

static FLOAT QUAD_1D_P11_wts[] = {
    Dup11(.08566224618958517252014807108636645),
    Dup11(.18038078652406930378491675691885806),
    Dup11(.23395696728634552369493517199477550)
};
static FLOAT QUAD_1D_P11_pts[Length(QUAD_1D_P11_wts) * 2] = {
    Perm11(.96623475710157601390615077724699730),
    Perm11(.83060469323313225683069979750995267),
    Perm11(.61930959304159845431525086084035597)
};
static QUAD QUAD_1D_P11_ = {
    "1D P11",			/* name */
    1,				/* dim */
    11,				/* order */
    Length(QUAD_1D_P11_wts),	/* npoints */
    QUAD_1D_P11_pts,		/* points */
    QUAD_1D_P11_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P11 (&QUAD_1D_P11_)

static FLOAT QUAD_1D_P13_wts[] = {
    Dup11(.06474248308443484663530571633954101),
    Dup11(.13985269574463833395073388571188979),
    Dup11(.19091502525255947247518488774448757),
    Dup2(.20897959183673469387755102040816327)
};
static FLOAT QUAD_1D_P13_pts[Length(QUAD_1D_P13_wts) * 2] = {
    Perm11(.97455395617137926226309484202392563),
    Perm11(.87076559279969721993193238664039420),
    Perm11(.70292257568869858345330320603848073),
    Perm2(.5)
};
static QUAD QUAD_1D_P13_ = {
    "1D P13",			/* name */
    1,				/* dim */
    13,				/* order */
    Length(QUAD_1D_P13_wts),	/* npoints */
    QUAD_1D_P13_pts,		/* points */
    QUAD_1D_P13_wts,		/* weights */
    -1				/* id */
};
#define QUAD_1D_P13 (&QUAD_1D_P13_)

static FLOAT QUAD_1D_P15_wts[] = {
    Dup11(.05061426814518812957626567715498110),
    Dup11(.11119051722668723527217799721312044),
    Dup11(.15685332293894364366898110099330066),
    Dup11(.18134189168918099148257522463859781)
};
static FLOAT QUAD_1D_P15_pts[Length(QUAD_1D_P15_wts) * 2] = {
    Perm11(.98014492824876811584178043428473650),
    Perm11(.89833323870681336979577696823791522),
    Perm11(.76276620495816449290886952459462317),
    Perm11(.59171732124782490246973807118009199)
};
static QUAD QUAD_1D_P15_ = {
    "1D P15",		/* name */
    1,			/* dim */
    15,			/* order */
    Length(QUAD_1D_P15_wts),	/* npoints */
    QUAD_1D_P15_pts,	/* points */
    QUAD_1D_P15_wts,	/* weights */
    -1			/* id */
};
#define QUAD_1D_P15 (&QUAD_1D_P15_)

static FLOAT QUAD_1D_P17_wts[] = {
    Dup11(.04063719418078720598594607905526183),
    Dup11(.09032408034742870202923601562145640),
    Dup11(.13030534820146773115937143470931642),
    Dup11(.15617353852000142003431520329222183),
    Dup2(.16511967750062988158226253464348702)
};
static FLOAT QUAD_1D_P17_pts[Length(QUAD_1D_P17_wts) * 2] = {
    Perm11(.98408011975381304491778810145183644),
    Perm11(.91801555366331789714971489403486744),
    Perm11(.80668571635029519865435101967073709),
    Perm11(.66212671170190446451926900732166830),
    Perm2(.5)
};
static QUAD QUAD_1D_P17_ = {
    "1D P17",		/* name */
    1,			/* dim */
    17,			/* order */
    Length(QUAD_1D_P17_wts),	/* npoints */
    QUAD_1D_P17_pts,	/* points */
    QUAD_1D_P17_wts,	/* weights */
    -1			/* id */
};
#define QUAD_1D_P17 (&QUAD_1D_P17_)

static FLOAT QUAD_1D_P19_wts[] = {
    Dup11(.03333567215434406879678440494666590),
    Dup11(.07472567457529029657288816982884867),
    Dup11(.10954318125799102199776746711408160),
    Dup11(.13463335965499817754561346078473468),
    Dup11(.14776211235737643508694649732566916)
};
static FLOAT QUAD_1D_P19_pts[Length(QUAD_1D_P19_wts) * 2] = {
    Perm11(.98695326425858586003898200604222603),
    Perm11(.93253168334449225536604834421174652),
    Perm11(.83970478414951220311716368255743679),
    Perm11(.71669769706462359539963297158289208),
    Perm11(.57443716949081560544241300056485999)
};
static QUAD QUAD_1D_P19_ = {
    "1D P19",		/* name */
    1,			/* dim */
    19,			/* order */
    Length(QUAD_1D_P19_wts),	/* npoints */
    QUAD_1D_P19_pts,	/* points */
    QUAD_1D_P19_wts,	/* weights */
    -1			/* id */
};
#define QUAD_1D_P19 (&QUAD_1D_P19_)

static FLOAT QUAD_1D_P21_wts[] = {
    Dup11(.02783428355808683324137686022127429),
    Dup11(.06279018473245231231734714961197005),
    Dup11(.09314510546386712571304882071582795),
    Dup11(.11659688229599523995926185242158757),
    Dup11(.13140227225512333109034443494525460),
    Dup2(.13646254338895031535724176416817109)
};
static FLOAT QUAD_1D_P21_pts[Length(QUAD_1D_P21_wts) * 2] = {
    Perm11(.98911432907302849640196900056142870),
    Perm11(.94353129988404764953757888465196363),
    Perm11(.86507600278702466204670812601557673),
    Perm11(.75954806460340590796286283472930478),
    Perm11(.63477157797617248616576599270043076),
    Perm2(.5)
};
static QUAD QUAD_1D_P21_ = {
    "1D P21",		/* name */
    1,			/* dim */
    21,			/* order */
    Length(QUAD_1D_P21_wts),	/* npoints */
    QUAD_1D_P21_pts,	/* points */
    QUAD_1D_P21_wts,	/* weights */
    -1			/* id */
};
#define QUAD_1D_P21 (&QUAD_1D_P21_)

/*--------------------------- 2D cubature rules ------------------------*/

static FLOAT QUAD_2D_P1_wts[] = {
    Dup3(1.)
};
static FLOAT QUAD_2D_P1_pts[Length(QUAD_2D_P1_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333)
};
static QUAD QUAD_2D_P1_ = {
    "2D P1",			/* name */
    2,				/* dim */
    1,				/* order */
    Length(QUAD_2D_P1_wts),	/* npoints = 1 */
    QUAD_2D_P1_pts,		/* points */
    QUAD_2D_P1_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P1 (&QUAD_2D_P1_)

static FLOAT QUAD_2D_P2_wts[] = {
    Dup21(1./3.)
};
static FLOAT QUAD_2D_P2_pts[Length(QUAD_2D_P2_wts) * 3] = {
    Perm21(1./6.)
};
static QUAD QUAD_2D_P2_ = {
    "2D P2",			/* name */
    2,				/* dim */
    2,				/* order */
    Length(QUAD_2D_P2_wts),	/* npoints = 3 */
    QUAD_2D_P2_pts,		/* points */
    QUAD_2D_P2_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P2 (&QUAD_2D_P2_)

#if 0
/* Note: this rule has points on the edges */
static FLOAT QUAD_2D_P3_wts[] = {
    Dup21(1./30.),
    Dup21(3./10.)
};
static FLOAT QUAD_2D_P3_pts[Length(QUAD_2D_P3_wts) * 3] = {
    Perm21(.5),
    /* 1/6 */
    Perm21(1./6.)
};
#else
static FLOAT QUAD_2D_P3_wts[] = {
    Dup21(.28114980244097964825351432270207695),
    Dup21(.05218353089235368507981901063125638)
};
static FLOAT QUAD_2D_P3_pts[Length(QUAD_2D_P3_wts) * 3] = {
    Perm21(.16288285039589191090016180418490635),
    Perm21(.47791988356756370000000000000000000)
};
#endif
static QUAD QUAD_2D_P3_ = {
    "2D P3",			/* name */
    2,				/* dim */
    3,				/* order */
    Length(QUAD_2D_P3_wts),	/* npoints = 6 */
    QUAD_2D_P3_pts,		/* points */
    QUAD_2D_P3_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P3 (&QUAD_2D_P3_)

static FLOAT QUAD_2D_P4_wts[] = {
    /* (620 + sqrt(213125 - 53320 * sqrt(10))) / 3720 */
    Dup21(.22338158967801146569500700843312280),
    /* (620 - sqrt(213125 - 53320 * sqrt(10))) / 3720 */
    Dup21(.10995174365532186763832632490021053)
};
static FLOAT QUAD_2D_P4_pts[Length(QUAD_2D_P4_wts) * 3] = {
    /* (8 - sqrt(10) + sqrt(38 - 44 * sqrt(2 / 5))) / 18 */
    Perm21(.44594849091596488631832925388305199),
    /* (8 - sqrt(10) - sqrt(38 - 44 * sqrt(2 / 5))) / 18 */
    Perm21(.09157621350977074345957146340220151)
};
static QUAD QUAD_2D_P4_ = {
    "2D P4",			/* name */
    2,				/* dim */
    4,				/* order */
    Length(QUAD_2D_P4_wts),	/* npoints = 6 */
    QUAD_2D_P4_pts,		/* points */
    QUAD_2D_P4_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P4 (&QUAD_2D_P4_)

static FLOAT QUAD_2D_P5_wts[] = {
    /* (155 - sqrt(15)) / 1200 */
    Dup21(.12593918054482715259568394550018133),
    /* (155 + sqrt(15)) / 1200 */
    Dup21(.13239415278850618073764938783315200),
    Dup3(9./40.)
};
static FLOAT QUAD_2D_P5_pts[Length(QUAD_2D_P5_wts) * 3] = {
    /* (6 - sqrt(15)) / 21 */
    Perm21(.10128650732345633880098736191512383),
    /* (6 + sqrt(15)) / 21 */
    Perm21(.47014206410511508977044120951344760),
    /* 1 / 3 */
    Perm3(.33333333333333333333333333333333333)
};
static QUAD QUAD_2D_P5_ = {
    "2D P5",			/* name */
    2,				/* dim */
    5,				/* order */
    Length(QUAD_2D_P5_wts),	/* npoints = 7 */
    QUAD_2D_P5_pts,		/* points */
    QUAD_2D_P5_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P5 (&QUAD_2D_P5_)

#if 0
/* An 11-point unsymmetric rule reported in:
 *	 Day, David M., Mark A. Taylor, "A new 11 point degree 6 cubature
 *	 	formula for the triangle [Proceedings of the ICIAM 2007],"
 *	 Journal Article, Proceedings of Applied Mathematics and Mechanics,
 *	 Accepted/Published January 2008. */
static FLOAT QUAD_2D_P6_wts[] = {
    Dup0(.03806807185295551439063192528703396),
    Dup0(.03837935530775265554764109222240791),
    Dup0(.04620045674456241859455515980217997),
    Dup0(.05346758944419901689402679518609906),
    Dup0(.08375582696574588108371037842585680),
    Dup0(.10164483302551605906571229513115369),
    Dup0(.10186152446136717571450065716620939),
    Dup0(.11142183166000185684914076857474210),
    Dup0(.11200945026294611573462286906312035),
    Dup0(.12478757143755821156418716664966669),
    Dup0(.18840348883739509456127089249153007)
};
static FLOAT QUAD_2D_P6_pts[Length(QUAD_2D_P6_wts) * 3] = {
    Perm30(.05725498667747685254386401337490528,.89549814678987956946437486806257514),
    Perm30(.89536264002457947703053711751108844,.06182822125032174107784815639931401),
    Perm30(.68447574845651404000000000000000000,.02334373849768321288645813914257559),
    Perm30(.06874625591502945506138017629748138,.06003027574726303099667885025487684),
    Perm30(.61567620557584050877805946045395354,.33346180834137626773374382178966904),
    Perm30(.62794614119778946000000000000000000,.15918918599215148000000000000000000),
    Perm30(.06290913834186374714863309341182919,.65529509370545247000000000000000000),
    Perm30(.06837821192050999512347955121812458,.30911768542826747346974929569953382),
    Perm30(.28752945837439246626570898085589649,.63642650917962018000000000000000000),
    Perm30(.32878355641313448865307686080999177,.07702400564246333220945276738749036),
    Perm30(.31229040501364539638767631759216157,.35234478644589918332680050733851911)
};
static QUAD QUAD_2D_P6_ = {
    "2D P6",			/* name */
    2,				/* dim */
    6,				/* order */
    Length(QUAD_2D_P6_wts),	/* npoints = 11 */
    QUAD_2D_P6_pts,		/* points */
    QUAD_2D_P6_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P6 (&QUAD_2D_P6_)
#else
static FLOAT QUAD_2D_P6_wts[] = {
    Dup21(.05084490637020681692093680910686898),
    Dup21(.11678627572637936602528961138557944),
    Dup111(.08285107561837357519355345642044245)
};
static FLOAT QUAD_2D_P6_pts[Length(QUAD_2D_P6_wts) * 3] = {
    Perm21(.06308901449150222834033160287081916),
    Perm21(.24928674517091042129163855310701908),
    Perm111(.05314504984481694735324967163139815,
	    .31035245103378440541660773395655215)
};
static QUAD QUAD_2D_P6_ = {
    "2D P6",			/* name */
    2,				/* dim */
    6,				/* order */
    Length(QUAD_2D_P6_wts),	/* npoints = 12 */
    QUAD_2D_P6_pts,		/* points */
    QUAD_2D_P6_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P6 (&QUAD_2D_P6_)
#endif

#if 0
static FLOAT QUAD_2D_P7_wts[] = {
    Dup21(0.0102558174092),
    Dup111(0.1116047046647),
    Dup21(0.1679775595335),
    Dup21(0.2652238803946)
};
static FLOAT QUAD_2D_P7_pts[Length(QUAD_2D_P7_wts) * 3] = {
    Perm21(0.),
    Perm111(0.7839656651012, 0.1738960507345),
    Perm21(0.4743880861752),
    Perm21(0.2385615300181)
};
#else
static FLOAT QUAD_2D_P7_wts[] = {
    Dup21(.01353386251566556156682309245259393),
    Dup21(.07895125443201098137652145029770332),
    Dup21(.12860792781890607455665553308952344),
    Dup111(.05612014428337535791666662874675632)
};
static FLOAT QUAD_2D_P7_pts[Length(QUAD_2D_P7_wts) * 3] = {
    Perm21(.02826392415607634022359600691324002),
    Perm21(.47431132326722257527522522793181654),
    Perm21(.24114332584984881025414351267036207),
    Perm111(.76122274802452380000000000000000000,
	    .04627087779880891064092559391702049)
};
#endif
static QUAD QUAD_2D_P7_ = {
    "2D P7",			/* name */
    2,				/* dim */
    7,				/* order */
    Length(QUAD_2D_P7_wts),	/* npoints = 15 */
    QUAD_2D_P7_pts,		/* points */
    QUAD_2D_P7_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P7 (&QUAD_2D_P7_)

static FLOAT QUAD_2D_P8_wts[] = {
    Dup3(.14431560767778716825109111048906462),
    Dup21(.10321737053471825028179155029212903),
    Dup21(.03245849762319808031092592834178060),
    Dup21(.09509163426728462479389610438858432),
    Dup111(.02723031417443499426484469007390892)
};
static FLOAT QUAD_2D_P8_pts[Length(QUAD_2D_P8_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.17056930775176020662229350149146450),
    Perm21(.05054722831703097545842355059659895),
    Perm21(.45929258829272315602881551449416932),
    Perm111(.26311282963463811342178578628464359,
	    .00839477740995760533721383453929445)
};
static QUAD QUAD_2D_P8_ = {
    "2D P8",			/* name */
    2,				/* dim */
    8,				/* order */
    Length(QUAD_2D_P8_wts),	/* npoints = 16 */
    QUAD_2D_P8_pts,		/* points */
    QUAD_2D_P8_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P8 (&QUAD_2D_P8_)

#if 0
static FLOAT QUAD_2D_P9_wts[] = {
    Dup21(0.0519871420646),
    Dup111(0.0707034101784),
    Dup111(0.0909390760952),
    Dup21(0.1032344051380),
    Dup21(0.1881601469167)
};
static FLOAT QUAD_2D_P9_pts[Length(QUAD_2D_P9_wts) * 3] = {
    Perm21(0.0451890097844),
    Perm111(0.7475124727339, 0.2220631655373),
    Perm111(0.1369912012649, 0.2182900709714),
    Perm21(0.4815198347833),
    Perm21(0.4036039798179)
};
static QUAD QUAD_2D_P9_ = {
    "2D P9",			/* name */
    2,				/* dim */
    9,				/* order */
    21,				/* npoints */
    QUAD_2D_P9_pts,		/* points */
    QUAD_2D_P9_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P9 (&QUAD_2D_P9_)
#else
static FLOAT QUAD_2D_P9_wts[] = {
    Dup3(.09713579628279883381924198250728863),
    Dup21(.03133470022713907053685483128720932),
    Dup21(.02557767565869803126167879855899982),
    Dup21(.07782754100477427931673935629940396),
    Dup21(.07964773892721025303289177426404527),
    Dup111(.04328353937728937728937728937728938)
};
static FLOAT QUAD_2D_P9_pts[Length(QUAD_2D_P9_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.48968251919873762778370692483619280),
    Perm21(.04472951339445270986510658996627636),
    Perm21(.43708959149293663726993036443535497),
    Perm21(.18820353561903273024096128046733557),
    Perm111(.74119859878449802069007987352342383,
	    .22196298916076569567510252769319107)
};
static QUAD QUAD_2D_P9_ = {
    "2D P9",			/* name */
    2,				/* dim */
    9,				/* order */
    Length(QUAD_2D_P9_wts),	/* npoints = 19 */
    QUAD_2D_P9_pts,		/* points */
    QUAD_2D_P9_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P9 (&QUAD_2D_P9_)
#endif

static FLOAT QUAD_2D_P10_wts[] = {
    Dup3(.08093742879762288025711312381650193),
    Dup21(.07729858800296312168250698238034344),
    Dup21(.07845763861237173136809392083439673),
    Dup21(.01746916799592948691760716329067815),
    Dup21(.00429237418483282803048040209013191),
    Dup111(.03746885821046764297902076548504452),
    Dup111(.02694935259187995964544947958109671)
};
static FLOAT QUAD_2D_P10_pts[Length(QUAD_2D_P10_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.42727317884677553809044271751544715),
    Perm21(.18309922244867502052157438485022004),
    Perm21(.49043401970113058745397122237684843),
    Perm21(.01257244555158053273132908502104126),
    Perm111(.65426866792006614066657009558762790,
	    .30804600168524770000000000000000000),
    Perm111(.12280457706855927343012981748128116,
	    .03337183373930478624081644177478038)
};
static QUAD QUAD_2D_P10_ = {
    "2D P10",			/* name */
    2,				/* dim */
    10,				/* order */
    Length(QUAD_2D_P10_wts),	/* npoints = 25 */
    QUAD_2D_P10_pts,		/* points */
    QUAD_2D_P10_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P10 (&QUAD_2D_P10_)

static FLOAT QUAD_2D_P11_wts[] = {
    Dup3(.08117796029686715951547596874982357),
    Dup21(.01232404350690949411847390101623284),
    Dup21(.06282800974441010728333942816029398),
    Dup21(.01222037904936452975521221500393789),
    Dup21(.06770134895281150992098886182322559),
    Dup21(.04021969362885169042356688960756866),
    Dup111(.01476227271771610133629306558778206),
    Dup111(.04072799645829903966033695848161786)
};
static FLOAT QUAD_2D_P11_pts[Length(QUAD_2D_P11_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.03093835524543078489519501499130475),
    Perm21(.43649818113412884191761527655997324),
    Perm21(.49898476370259326628798698383139087),
    Perm21(.21468819795859433660687581387825086),
    Perm21(.11368310404211339020529315622836178),
    Perm111(.82561876616486290435880620030835800,
	    .15974230459185018980086078822500751),
    Perm111(.64047231013486526767703659081896681,
	    .31178371570959900000000000000000000)
};
static QUAD QUAD_2D_P11_ = {
    "2D P11",			/* name */
    2,				/* dim */
    11,				/* order */
    Length(QUAD_2D_P11_wts),	/* npoints = 28 */
    QUAD_2D_P11_pts,		/* points */
    QUAD_2D_P11_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P11 (&QUAD_2D_P11_)

static FLOAT QUAD_2D_P12_wts[] = {
    Dup21(.00616626105155901723386648378523035),
    Dup21(.06285822421788510035427051309288255),
    Dup21(.03479611293070894298932839729499937),
    Dup21(.04369254453803840213545726255747497),
    Dup21(.02573106644045533541779092307156443),
    Dup111(.02235677320230344571183907670231999),
    Dup111(.01731623110865889237164210081103407),
    Dup111(.04037155776638092951782869925223677)
};
static FLOAT QUAD_2D_P12_pts[Length(QUAD_2D_P12_wts) * 3] = {
    Perm21(.02131735045321037024685697551572825),
    Perm21(.27121038501211592234595134039689474),
    Perm21(.12757614554158592467389632515428357),
    Perm21(.43972439229446027297973662348436108),
    Perm21(.48821738977380488256466206525881104),
    Perm111(.69583608678780342214163552323607254,
	    .28132558098993954824813069297455275),
    Perm111(.85801403354407263059053661662617818,
	    .11625191590759714124135414784260182),
    Perm111(.60894323577978780685619243776371007,
	    .27571326968551419397479634607976398)
};
static QUAD QUAD_2D_P12_ = {
    "2D P12",			/* name */
    2,				/* dim */
    12,				/* order */
    Length(QUAD_2D_P12_wts),	/* npoints = 33 */
    QUAD_2D_P12_pts,		/* points */
    QUAD_2D_P12_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P12 (&QUAD_2D_P12_)

static FLOAT QUAD_2D_P13_wts[] = {
    Dup3(.06796003658683164428177442468088488),
    Dup21(.05560196753045332870725746601046147),
    Dup21(.05827848511919998140476708351333981),
    Dup21(.00605233710353917184179280003229082),
    Dup21(.02399440192889473077371079945095965),
    Dup111(.03464127614084837046598682851091822),
    Dup111(.01496540110516566726324585713290344),
    Dup111(.02417903981159381913744574557306076),
    Dup111(.00959068100354326272259509016611089)
};
static FLOAT QUAD_2D_P13_pts[Length(QUAD_2D_P13_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.42694141425980040602081253503137421),
    Perm21(.22137228629183290065481255470507908),
    Perm21(.02150968110884318386929131353405208),
    Perm21(.48907694645253934990068971909020439),
    Perm111(.62354599555367557081585435318623659,
	    .30844176089211777465847185254124531),
    Perm111(.86470777029544277530254595089569318,
	    .11092204280346339541286954522167452),
    Perm111(.74850711589995219517301859578870965,
	    .16359740106785048023388790171095725),
    Perm111(.72235779312418796526062013230478405,
	    .27251581777342966618005046435408685)
};
static QUAD QUAD_2D_P13_ = {
    "2D P13",			/* name */
    2,				/* dim */
    13,				/* order */
    Length(QUAD_2D_P13_wts),	/* npoints = 37 */
    QUAD_2D_P13_pts,		/* points */
    QUAD_2D_P13_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P13 (&QUAD_2D_P13_)

static FLOAT QUAD_2D_P14_wts[] = {
    Dup21(.04216258873699301753823043732418613),
    Dup21(.00492340360240008168182602350904215),
    Dup21(.01443369966977666760170992148065332),
    Dup21(.03278835354412535064131097873862534),
    Dup21(.02188358136942889064084494596332597),
    Dup21(.05177410450729158631478491016639640),
    Dup111(.02466575321256367396287524518363623),
    Dup111(.03857151078706068322848902781041086),
    Dup111(.01443630811353384049608869199901580),
    Dup111(.00501022883850067176986009308248912)
};
static FLOAT QUAD_2D_P14_pts[Length(QUAD_2D_P14_wts) * 3] = {
    Perm21(.17720553241254343695661069046505908),
    Perm21(.01939096124870104817825009505452951),
    Perm21(.06179988309087260126747882843693579),
    Perm21(.41764471934045392250944082218564344),
    Perm21(.48896391036217863867737602045239024),
    Perm21(.27347752830883865975494428326269856),
    Perm111(.17226668782135557837528960161365733,
	    .05712475740364793903567712421891471),
    Perm111(.57022229084668317349769621336235426,
	    .09291624935697182475824858954872035),
    Perm111(.29837288213625775297083151805961273,
	    .01464695005565440967054132792007421),
    Perm111(.11897449769695684539818196192990548,
	    .00126833093287202508724640109549269)
};
static QUAD QUAD_2D_P14_ = {
    "2D P14",			/* name */
    2,				/* dim */
    14,				/* order */
    Length(QUAD_2D_P14_wts),	/* npoints = 42 */
    QUAD_2D_P14_pts,		/* points */
    QUAD_2D_P14_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P14 (&QUAD_2D_P14_)

/* a 49-point rule communicated by Freddie Witherden (freddie@witherden.org)
 * 2D 49 point order 15 rule (1:4:6, 346 tries, 3288 evals), error = 4.251e-17
 */
static FLOAT QUAD_2D_P15_wts[] = {
    Dup3(.02357126703190634206659321140821418),
    Dup21(.01517314955721170450311858877690239),
    Dup21(.01297600128392884154979521077280757),
    Dup21(.01706629596800615670942600046160914),
    Dup21(.04576001946273760698482638108892258),
    Dup111(.00222757447282223154006065426298478),
    Dup111(.02701014165986947101315702212247500),
    Dup111(.02608377963958756403057720483642768),
    Dup111(.01211015327702828337230795926322736),
    Dup111(.01564785059680444573399007149035058),
    Dup111(.03417088937929479242522512890637806)
};
static FLOAT QUAD_2D_P15_pts[Length(QUAD_2D_P15_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.11022229622834687297855264132259850),
    Perm21(.05197643301003435047003197947889073),
    Perm21(.49114565807532554119014945122395425),
    Perm21(.39315718888435884048226809785071794),
    Perm111(.03737440487572919066543605209836625,
	    .96251835223001214880811969560396873),
    Perm111(.24824877798467321198263980694374938,
	    .19316669854521416819773100288721521),
    Perm111(.20699402274830217740486528153682148,
	    .08689590883549962551575259619781217),
    Perm111(.14854110526954708137688902238435510,
	    .01743682539845430796259020511767948),
    Perm111(.30674237923596382376588728350286621,
	    .01749251095825766163254977051260599),
    Perm111(.36703198754220473278855469116984882,
	    .09034802175864556044634095119222305)
};
static QUAD QUAD_2D_P15_ = {
    "2D P15",			/* name */
    2,				/* dim */
    15,				/* order */
    Length(QUAD_2D_P15_wts),	/* npoints = 49 */
    QUAD_2D_P15_pts,		/* points */
    QUAD_2D_P15_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P15 (&QUAD_2D_P15_)

static FLOAT QUAD_2D_P16_wts[] = {
    Dup3(.04802218868037709055183940458051988),
    Dup21(.01470910030680192710340364286186919),
    Dup21(.02954458654931925599530972679646409),
    Dup21(.02612501735108837749859756549171557),
    Dup21(.00278038735239000697500301613866207),
    Dup21(.03182177300053664950342729005594961),
    Dup21(.00864583434950965990117373416984893),
    Dup111(.01430033290449536514661642536825213),
    Dup111(.02784977720360082995222987342395349),
    Dup111(.00704167340663609756237018808928069),
    Dup111(.01789983825993372860177020907581078),
    Dup111(.02745820038434976307247003810091720),
    Dup111(.00729979693943176208411254408777766)
};
static FLOAT QUAD_2D_P16_pts[Length(QUAD_2D_P16_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.08179498313137387264146559311886101),
    Perm21(.16530060196977965062676193293355656),
    Perm21(.46859210534946138669460289729660561),
    Perm21(.01443881344541668261410895669566020),
    Perm21(.24178428539178335340689445929320769),
    Perm21(.49531034298776996406549508687740551),
    Perm111(.65051340266135229943114468484168666,
	    .33139974453708955658132316818259388),
    Perm111(.60401128149599703984940410303596702,
	    .30324716274994218504155217807834692),
    Perm111(.80216825757474166361686194781166705,
	    .18802805952123717344418211429398875),
    Perm111(.75650560644282839655115407575806082,
	    .18350466852229686368238027743700035),
    Perm111(.46593843871411818488381073359154639,
	    .35964594879750460000000000000001000),
    Perm111(.90639484399204150136249966186534000,
	    .07719437129575543228251522505271386)
};
static QUAD QUAD_2D_P16_ = {
    "2D P16",			/* name */
    2,				/* dim */
    16,				/* order */
    Length(QUAD_2D_P16_wts),	/* npoints = 55 */
    QUAD_2D_P16_pts,		/* points */
    QUAD_2D_P16_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P16 (&QUAD_2D_P16_)

/* A 60-point order 17 rule found by using the number of points reported in:
 *	H. Xiao and Z. Gimbutas,
 *	A numerical algorithm for the construction of efficient quadrature
 *	rules in two and higher dimensions,
 *	Computers and Mathematics with Applications, 59 (2010), 663-676 */
static FLOAT QUAD_2D_P17_wts[] = {
    Dup21(.03829254008003568749425168889491817),
    Dup21(.01669528699775339594318472807122019),
    Dup21(.00143512454359061224492929722268097),
    Dup21(.02864276849185053630399044294140648),
    Dup21(.03408569078206214964786810427776196),
    Dup21(.02467274200053089056925349793140004),
    Dup21(.00586679757537134154263246190805349),
    Dup21(.02321859500422896151112767944153052),
    Dup111(.03084965458251406099116307348593810),
    Dup111(.01881398544005420038782109445200127),
    Dup111(.00512343450397285555007197439694996),
    Dup111(.00701239348475201777118052342883162),
    Dup111(.01538229443504461311363086994295179),
    Dup111(.00303013148261713122418018061550803)
};
static FLOAT QUAD_2D_P17_pts[Length(QUAD_2D_P17_wts) * 3] = {
    Perm21(.24056306963626902977934166278860247),
    Perm21(.08092323589766073062004798772340524),
    Perm21(.01001414912499135088254841140047604),
    Perm21(.15437652078663289107430782196727737),
    Perm21(.41716986201996268598941663596983268),
    Perm21(.47086974573840098186867398532866671),
    Perm21(.49811803384542204444865152799034832),
    Perm21(.36473840565291924199871629076775930),
    Perm111(.10986590708262616153720966373050601,
	    .30466576969866569523225839525499357),
    Perm111(.20493227462918790108024139159058423,
	    .05248758390645425414786013344982922),
    Perm111(.05813921564266244000000000000000000,
	    .01500053995225954378593128753997425),
    Perm111(.13859554086776482539309659376771751,
	    .01501023347973182500884052064335399),
    Perm111(.34660546952009260087829868774027952,
	    .02336212893314653752768977049783837),
    Perm111(.24821986889585591697209834974065293,
	    .00000099999999999965762180770907324)
	    /*9.99999999999657621807709073237881438e-7*/
};
static QUAD QUAD_2D_P17_ = {
    "2D P17",			/* name */
    2,				/* dim */
    17,				/* order */
    Length(QUAD_2D_P17_wts),	/* npoints = 60 */
    QUAD_2D_P17_pts,		/* points */
    QUAD_2D_P17_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P17 (&QUAD_2D_P17_)

/* A 67-point order 18 rule found by using the number of points reported in:
 *	H. Xiao and Z. Gimbutas,
 *	A numerical algorithm for the construction of efficient quadrature
 *	rules in two and higher dimensions,
 *	Computers and Mathematics with Applications, 59 (2010), 663-676 */
static FLOAT QUAD_2D_P18_wts[] = {
    Dup3(.03074852123911585539935333820159969),
    Dup21(.02031833884545839730521676856098738),
    Dup21(.01379028660476693880147269080330003),
    Dup21(.00053200561694778056109294261721746),
    Dup21(.03347199405984789811876973462144190),
    Dup21(.03111639660200613119689389250158563),
    Dup21(.01310702749173875567860153100348528),
    Dup111(.01691165391748007879456553323826843),
    Dup111(.02759288648857947802009593334620683),
    Dup111(.01636590841398656595815221611374510),
    Dup111(.00764170497271963595084711372125680),
    Dup111(.00772983528000622700809279634102600),
    Dup111(.00958612447436150376044024017260990),
    Dup111(.00421751677474444290984387716007124),
    Dup111(.01532825819455314086704628681920691)
};
static FLOAT QUAD_2D_P18_pts[Length(QUAD_2D_P18_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.15163850697260486492387353795772074),
    Perm21(.07243870556733287047426206374480081),
    Perm21(.00375894434106834585702462733286887),
    Perm21(.41106710187591949855469549486746318),
    Perm21(.26561460990537421478430796115175039),
    Perm21(.47491821132404573588789755091754023),
    Perm111(.06612245802840338770053947185398348,
	    .17847912556588763355267204638676643),
    Perm111(.26857330639601384733212028806856623,
	    .14906691012577383920019113944789784),
    Perm111(.30206195771287080772484323648551723,
	    .05401173533902423468044436247084948),
    Perm111(.13277883027138932992144407050471004,
	    .01433152477894195356844867129563809),
    Perm111(.25650615977424154068897765977748937,
	    .01050501881924193559868603344210775),
    Perm111(.41106566867461836291309677848250996,
	    .01169182467466708527042342649785763),
    Perm111(.04727614183265178252228403898505622,
	    .01249893248349544012804819357953175),
    Perm111(.38504403441316367334400254247436861,
	    .52452892523249571422861434426430408)
};
static QUAD QUAD_2D_P18_ = {
    "2D P18",			/* name */
    2,				/* dim */
    18,				/* order */
    Length(QUAD_2D_P18_wts),	/* npoints = 67 */
    QUAD_2D_P18_pts,		/* points */
    QUAD_2D_P18_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P18 (&QUAD_2D_P18_)

/* Note: the rule QUAD_2D_P19 was taken from the book by
 *	P. Solin, K. Segeth, and I. Dolezel,
 *	"Higer-order Finite Element Methods",
 *	Chapman and Hall/CRC Press, 2003. */
static FLOAT QUAD_2D_P19_wts[] = {
    Dup3(.03290633138891865208361434484647497),
    Dup21(.01033073189127205336703996357174833),
    Dup21(.02238724726301639252918455603516271),
    Dup21(.03026612586946807086528019098259122),
    Dup21(.03049096780219778100003158657852042),
    Dup21(.02415921274164090491184803098664001),
    Dup21(.01605080358680087529162277027642948),
    Dup21(.00808458026178406048180567324219442),
    Dup21(.00207936202748478075134750167439841),
    Dup111(.00388487690498138975670499199277266),
    Dup111(.02557416061202190389292970195260027),
    Dup111(.00888090357333805774552592470351753),
    Dup111(.01612454676173139121978526932783766),
    Dup111(.00249194181749067544058464757594956),
    Dup111(.01824284011895057837766571320973615),
    Dup111(.01025856373619852130804807004235813),
    Dup111(.00379992885530191397907315371363970)
};
static FLOAT QUAD_2D_P19_pts[Length(QUAD_2D_P19_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.48960998707300633196613106574829817),
    Perm21(.45453689269789266204675939053572830),
    Perm21(.40141668064943118739399562381068860),
    Perm21(.25555165440309761132218176810926787),
    Perm21(.17707794215212955164267520651590115),
    Perm21(.11006105322795186130008495167737397),
    Perm21(.05552862425183967124867841247135571),
    Perm21(.01262186377722866849023476677870599),
    Perm111(.60063379479464500000000000000000000,
	    .39575478735694286230479469406582787),
    Perm111(.13446675453077978561204319893264695,
	    .55760326158878396836395324250118097),
    Perm111(.72098702581736505521665290233827892,
	    .26456694840652020804030173490121494),
    Perm111(.59452706895587092461388928802650670,
	    .35853935220595058842492699064590088),
    Perm111(.83933147368083857861749007714840520,
	    .15780740596859474473767360335950651),
    Perm111(.22386142409791569130336938950653642,
	    .70108797892617336732328833655951158),
    Perm111(.82293132406985663162747155916053316,
	    .14242160111338343731557475687723745),
    Perm111(.92434425262078402945585913790156314,
	    .06549462808293770339232652498592557)
};
static QUAD QUAD_2D_P19_ = {
    "2D P19",			/* name */
    2,				/* dim */
    19,				/* order */
    Length(QUAD_2D_P19_wts),	/* npoints = 73 */
    QUAD_2D_P19_pts,		/* points */
    QUAD_2D_P19_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P19 (&QUAD_2D_P19_)

/* Rules 20-24, 26-29 are found by Simone Weikl (simone.weikl@googlemail.com),
 * Diploma Thesis, Technische Universiat Munchen, Zentrum Mathematik, 2011 */

static FLOAT QUAD_2D_P20_wts[] = {
    Dup3(.02343898837621685337578235989880370),
    Dup21(.01701187887065179140821050028462978),
    Dup21(.02213462902539847149771471956849632),
    Dup21(.02225012034148936704815054477635356),
    Dup21(.02108801427518765728972259255778044),
    Dup21(.01436673198237250674135242117943876),
    Dup21(.00596064247309054870158068681368087),
    Dup21(.00185446185638856226012710730597991),
    Dup111(.00766503799888173467975505965999393),
    Dup111(.00611096641377269564490800130795800),
    Dup111(.00329750122890750342409287108138500),
    Dup111(.00258504328745784243926241647780699),
    Dup111(.01604829966346833686116840419650012),
    Dup111(.00987379147789446687652271685071374),
    Dup111(.00817314741769008089505196969930370),
    Dup111(.02127212420812707803762062418100071),
    Dup111(.01629559968072678577307785994248523),
    Dup111(.01910541781474788066581373037653881)
};
static FLOAT QUAD_2D_P20_pts[Length(QUAD_2D_P20_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.47253969049374944291236394079678822),
    Perm21(.43559179765819053474788158522088855),
    Perm21(.38548317769095410374903697427852223),
    Perm21(.18589787266938260089793207404361894),
    Perm21(.10294309387227568202927226453268166),
    Perm21(.04420435682210499536228665005842580),
    Perm21(.01187700008194990884008379159291605),
    Perm111(.42317710194393600041367501539791831,
	    .56624681421216737896202019229528315),
    Perm111(.28717803493735130968896269265785627,
	    .70363134375008177073022062562769704),
    Perm111(.16282486571070316869304103317873899,
	    .83237331116054735414989063179341648),
    Perm111(.06468063449817511170284328732719589,
	    .92925769945837560706677619337951412),
    Perm111(.33400627700511908113700959506140627,
	    .61323701639938793580192466071340766),
    Perm111(.21092379552418127847921338445298798,
	    .75151051490601053625741794541954190),
    Perm111(.11508038084136831598057023754719804,
	    .85015113156210283588089253042485358),
    Perm111(.31075208646508429564535326048014931,
	    .56198974953953613108255692415961755),
    Perm111(.20200619801045898902767636571938539,
	    .70171644023616188456192811677305342),
    Perm111(.28902320790895929973608959414472710,
	    .49138856232319209839401293034098827)
};
static QUAD QUAD_2D_P20_ = {
    "2D P20",			/* name */
    2,				/* dim */
    20,				/* order */
    Length(QUAD_2D_P20_wts),	/* npoints = 82 */
    QUAD_2D_P20_pts,		/* points */
    QUAD_2D_P20_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P20 (&QUAD_2D_P20_)

/* The rule below is reported in the paper:
 *	Papanicolopulos, S., A.,
 * 	New fully symmetric and rotationally symmetric cubature rules on the
 * 	triangle using minimal orthonormal bases,
 *	J. Computational and Applied Mathematics, Vol. 294, 2016, pp.39-48 */
static FLOAT QUAD_2D_P21_wts[] = {
    Dup21(.00153252214157029927832972284942362),
    Dup21(.00295964208580089055557643244435822),
    Dup21(.00710507195198322705473634640429004),
    Dup21(.01242202545015119261392701182790142),
    Dup21(.01315385309054860400530165567389379),
    Dup21(.01610711993355940881429849025111080),
    Dup21(.01955699832742153003791726026064669),
    Dup21(.02114714580341115240235728776162335),
    Dup21(.02148724961809553292499438055586582),
    Dup111(.00324321603629715843164230514808509),
    Dup111(.00444606682456729614112175291076191),
    Dup111(.00444713701276898568121864572732943),
    Dup111(.00719283008979440275755795626382300),
    Dup111(.00968818276967735751464842894718971),
    Dup111(.01077186725474600415287816641481312),
    Dup111(.01537644879227419490362875554570800),
    Dup111(.01541820162505099647808429434299382),
    Dup111(.01872799408182348912155361034660658),
    Dup111(.01961890797839586264061345700479913)
};
static FLOAT QUAD_2D_P21_pts[Length(QUAD_2D_P21_wts) * 3] = {
    Perm21(.01083064791389613439818531875282892),
    Perm21(.49868116928006762187511807510022292),
    Perm21(.05320630259370221372937428477043579),
    Perm21(.48436880679907196058128682726473251),
    Perm21(.11717932446409532061312493414817476),
    Perm21(.18619987453160044065356184245386411),
    Perm21(.23770504697050237030777008826766300),
    Perm21(.45111809686333143558277239278860940),
    Perm21(.29890161661837960265935712860196744),
    Perm111(.01017037551397023833029242013076474,.05610607874044113073901605353578031),
    Perm111(.00740148001912942691985111704851672,.23806090893927819107377783880076336),
    Perm111(.00948888021003903598802889438007338,.13371423612729252503412567154133090),
    Perm111(.01078708528953292731070298166591233,.36087827036133643028378433162192850),
    Perm111(.04888641015641196213015335363186247,.12856000707434670174510612755634180),
    Perm111(.04079047843492138579001393428298806,.23192922019831618515287729451119134),
    Perm111(.10225476525427212998164710587805099,.21318238024685212224076314392042087),
    Perm111(.05619510372649343472752614615138017,.34615363893081412151163375832691108),
    Perm111(.19392111402204940534236787859220491,.35741779412597604193763009688130316),
    Perm111(.13139693759954925634229231531863966,.30964180048539107980510336108955521)
};
static QUAD QUAD_2D_P21_ = {
    "2D P21",			/* name */
    2,				/* dim */
    21,				/* order */
    Length(QUAD_2D_P21_wts),	/* npoints = 87 */
    QUAD_2D_P21_pts,		/* points */
    QUAD_2D_P21_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P21 (&QUAD_2D_P21_)

/* The rule below is reported in the paper:
 *	Papanicolopulos, S., A.,
 * 	New fully symmetric and rotationally symmetric cubature rules on the
 * 	triangle using minimal orthonormal bases,
 *	J. Computational and Applied Mathematics, Vol. 294, 2016, pp.39-48 */
static FLOAT QUAD_2D_P22_wts[] = {
    Dup21(.00069714569625074030369942481362133),
    Dup21(.00173365376198036236244040089465219),
    Dup21(.00466131304304557368006266059260170),
    Dup21(.01158457676559956471190194225470023),
    Dup21(.01187897403302190998142733919159934),
    Dup21(.01533880365566670016085333491517060),
    Dup21(.01971637694027233703178135471037246),
    Dup21(.02057215149173475351932757540044250),
    Dup21(.02384066027813703919931347525917147),
    Dup21(.02446119708987487225534932817494781),
    Dup111(.00182862802731120927204804019418561),
    Dup111(.00188044970396283839898767788993490),
    Dup111(.00370410864001110188501003141229496),
    Dup111(.00466834037183480579057625840302880),
    Dup111(.00721134117192958564362665357306283),
    Dup111(.00796743335988734266364119940269571),
    Dup111(.00903580036943713630598503580960509),
    Dup111(.00948064111155901466263790694355664),
    Dup111(.01561737012835320857159572546229795),
    Dup111(.01624531918105698418898193939757981),
    Dup111(.02178480822353151268049778007478454)
};
static FLOAT QUAD_2D_P22_pts[Length(QUAD_2D_P22_wts) * 3] = {
    Perm21(.00722823551590805269240186985118743),
    Perm21(.49971491656223188463531154910591767),
    Perm21(.04195252727280408802705553682804348),
    Perm21(.31413219152050094565940577630042994),
    Perm21(.48001365161711654879356466888729030),
    Perm21(.12308745423016114898448687333895172),
    Perm21(.44571963043911530549256371899531770),
    Perm21(.18986241218389367642303052024426076),
    Perm21(.26033923338175577283598939801891875),
    Perm21(.39636684767162598240715439210378845),
    Perm111(.00773958468860307799587341381217818,.03910016782732837999359532547054414),
    Perm111(.00057706413021840388680988197995853,.29956301031600608000000000000000000),
    Perm111(.00979577185352314036856347829609728,.09916758085225246952608204467401148),
    Perm111(.00918868020649896490029828421437019,.18619068155280570806618576756346898),
    Perm111(.01346708756840181797029316077776570,.40293889185510044331704310704540997),
    Perm111(.05062631246733689522786952921020785,.10358808540929187702277517444504398),
    Perm111(.04838811776183765022487372116607709,.18082300688832890010580439799931826),
    Perm111(.02749143585326034673258117826660649,.28194341507949187524318191991162303),
    Perm111(.06713397444770439007586079560898384,.35071285339799134366628146898304461),
    Perm111(.09670430361686034561495436311127678,.23017640440360132139166340852745074),
    Perm111(.15193045482670229286438888320778608,.31159323586348644974639923203001594)
};
static QUAD QUAD_2D_P22_ = {
    "2D P22",			/* name */
    2,				/* dim */
    22,				/* order */
    Length(QUAD_2D_P22_wts),	/* npoints = 96 */
    QUAD_2D_P22_pts,		/* points */
    QUAD_2D_P22_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P22 (&QUAD_2D_P22_)

/* The rule below is reported in the paper:
 *	Papanicolopulos, S., A.,
 * 	New fully symmetric and rotationally symmetric cubature rules on the
 * 	triangle using minimal orthonormal bases,
 *	J. Computational and Applied Mathematics, Vol. 294, 2016, pp.39-48 */
static FLOAT QUAD_2D_P23_wts[] = {
    Dup21(.00102338493393064825880875292048368),
    Dup21(.00234953285611607429820752203919566),
    Dup21(.00442272294831746458300712854673892),
    Dup21(.00935939493458907159588059346569364),
    Dup21(.01122330490795551618339838001860665),
    Dup21(.01145539386071866483451404196187953),
    Dup21(.01485152819027043031788493609445202),
    Dup21(.01873399097752303244589658710992199),
    Dup21(.02009544889817501015648393973138171),
    Dup21(.02186952160246302231865049077371942),
    Dup111(.00139037413890586280792572004623041),
    Dup111(.00209361317170022977809045175923150),
    Dup111(.00226272789116058493926098904342501),
    Dup111(.00509887607853182356576648513174798),
    Dup111(.00580279248634163562097040517303610),
    Dup111(.00699047412016323154662825915726588),
    Dup111(.01010544741268549508636466193618720),
    Dup111(.01094068682011104235992829469791130),
    Dup111(.01269774746720014444245594705387966),
    Dup111(.01493690521473593308948584780344384),
    Dup111(.01624594488896314707519973030797813),
    Dup111(.02040896492113806885822368822529305)
};
static FLOAT QUAD_2D_P23_pts[Length(QUAD_2D_P23_wts) * 3] = {
    Perm21(.00884309098564000781144468419871075),
    Perm21(.49904231799536473576318688106778703),
    Perm21(.04191849463192120115455956274854522),
    Perm21(.08384395940074188671519383182016759),
    Perm21(.35156602225687808437472423305189879),
    Perm21(.48142250008209757218970635991224348),
    Perm21(.13603683917665686011746620285416514),
    Perm21(.44588621023292908434421744174344724),
    Perm21(.19833791969077397732302473244075886),
    Perm21(.39764873352592070572902821621712745),
    Perm111(.00215375088982479143593969096276917,.11147822164436514858831541609060182),
    Perm111(.00797567048343379974299672675667051,.04599876191192738898335879375393121),
    Perm111(.00222521306870228962165445623994274,.29991704500621364115075519706889153),
    Perm111(.01056799023421332981938693231799616,.19450617255148173513923298602622080),
    Perm111(.02639015796005238716769753666365164,.10487601375183195540194359053325350),
    Perm111(.01372661478891633442412470482374058,.39359274155812221677807114606384301),
    Perm111(.03293167071711912354883994110324428,.27745010154284908600010796990105572),
    Perm111(.05645836928678800749584878194121292,.17041930960722382214358721748321713),
    Perm111(.24905869950604636107649169253437782,.28048464594062623291197233102900262),
    Perm111(.06710022884559872615982757386133093,.35940684385217631018244572992741760),
    Perm111(.10095848404745636455551318905522403,.23967897332407877845308433492438781),
    Perm111(.15208140311691476836002821658866124,.31660538238914823066544783358734965)
};
static QUAD QUAD_2D_P23_ = {
    "2D P23",			/* name */
    2,				/* dim */
    23,				/* order */
    Length(QUAD_2D_P23_wts),	/* npoints = 102 */
    QUAD_2D_P23_pts,		/* points */
    QUAD_2D_P23_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P23 (&QUAD_2D_P23_)

/* The rule below is reported in the paper:
 *	Papanicolopulos, S., A.,
 * 	New fully symmetric and rotationally symmetric cubature rules on the
 * 	triangle using minimal orthonormal bases,
 *	J. Computational and Applied Mathematics, Vol. 294, 2016, pp.39-48 */
static FLOAT QUAD_2D_P24_wts[] = {
    Dup3(.02293794348096749067720820639821200),
    Dup21(.00076737746111581423045153600120047),
    Dup21(.00552357844475169754997038457424443),
    Dup21(.00838499530275631071273403550487762),
    Dup21(.01221738017800235239788392469826439),
    Dup21(.01307039060561178310890784719893180),
    Dup21(.01788122775842957825015047766363903),
    Dup21(.01822174413909730956979133198261050),
    Dup21(.02164149721756761699449458590855473),
    Dup21(.02168831292692260197279166115848309),
    Dup111(.00174618458266172170313203275603945),
    Dup111(.00183857160374278724340785925075360),
    Dup111(.00199893663336212883772988094673110),
    Dup111(.00206369617133590779327617815189614),
    Dup111(.00229539508715841568165484400462521),
    Dup111(.00457952328890823144675590528548258),
    Dup111(.00529323009909540365054590996973504),
    Dup111(.00557874699599088171390666100209646),
    Dup111(.00861933948725664134146173130325259),
    Dup111(.00999235399224706921212863098136616),
    Dup111(.01030561620768130769226672677282150),
    Dup111(.01460454612625024725227714201539116),
    Dup111(.01499850067625046347206078267251109),
    Dup111(.01923078311743667878627312147552622)
};
static FLOAT QUAD_2D_P24_pts[Length(QUAD_2D_P24_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.00764481587209140357148961957868539),
    Perm21(.49512326693489419346010327445636948),
    Perm21(.08533571470774055253577908615445653),
    Perm21(.47540435757943002732921306991884855),
    Perm21(.14361312600254966163076940146917127),
    Perm21(.44000137550057370651541171540277806),
    Perm21(.20438684787130391661942173912629914),
    Perm21(.39155520703268199132653695865910252),
    Perm21(.26936069184956821890376700734821267),
    Perm111(.00128915765322182138873877223282987,.38930032117370399940994358985608046),
    Perm111(.00804615544134750962080148406751868,.03994551899851089671071946872000290),
    Perm111(.00397463904079080448292596145774045,.17756755351844720149250759536631588),
    Perm111(.00565339683877998034115515308702144,.09730437316339079594262256407299041),
    Perm111(.03654164634700071865936106746572505,.04737913646955582393784813835746318),
    Perm111(.00847203125278924422001665909111615,.27654233490622630027478984616955668),
    Perm111(.03186878555848486368527331611156268,.10186004800841345175103882567179717),
    Perm111(.02507448575695932327989859470575696,.17990041142989784948776341885611339),
    Perm111(.02495464920723698331110869690511693,.37476148829145151703198672023817762),
    Perm111(.07180692748992666960708660113790562,.16285371365641890528167019069210662),
    Perm111(.04649536832522560731056542252010275,.26299994692532693286696577835230479),
    Perm111(.07944565832892777248067300362002874,.35387462268603241581179193663132046),
    Perm111(.11210496839891452618514886571897182,.24045272001109686579097131221331152),
    Perm111(.16288704432089312482891199962593472,.31632883636136616749409848630342490)
};
static QUAD QUAD_2D_P24_ = {
    "2D P24",			/* name */
    2,				/* dim */
    24,				/* order */
    Length(QUAD_2D_P24_wts),	/* npoints = 112 */
    QUAD_2D_P24_pts,		/* points */
    QUAD_2D_P24_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P24 (&QUAD_2D_P24_)

/* The rule below is reported in the paper:
 *	S. Wandzura and H. Xiao, Symmetric quadrature rules on a triangle,
 *	Computers and Mathematics with Applications, 45 (2003), 1829C1840,
 * and was communicated by Don Wilton (dwilton@mindspring.com) */
static FLOAT QUAD_2D_P25_wts[] = {
    Dup21(.00800558188002042313368589293942171),
    Dup21(.01594707683239049085408554937789681),
    Dup21(.01310914123079550369839487163291327),
    Dup21(.01958300096563560520647726105123795),
    Dup21(.01647088544153726359394636789647424),
    Dup21(.00854727907409214131204679403754348),
    Dup21(.00816188585722650120293135168156145),
    Dup21(.00612114653998375062550303141747500),
    Dup21(.00290849826493666035989604760244737),
    Dup21(.00069227524566199872959231564688970),
    Dup111(.00124828919927740405463308732687347),
    Dup111(.00340475290880302630290932517884509),
    Dup111(.00335965432606405469389982622818046),
    Dup111(.00171615653949675776835927257382091),
    Dup111(.00148085631671560275966191325505238),
    Dup111(.00351131261072868028754024041382735),
    Dup111(.00739355014970648910670774728325426),
    Dup111(.00798308747737656611293770143977919),
    Dup111(.00435596261315803802370299459187773),
    Dup111(.00736505670141783108374850348433179),
    Dup111(.01096357284641954589593589943582605),
    Dup111(.01174996174354112327739198111865119),
    Dup111(.01001560071379857640896706453029824),
    Dup111(.01330964078762866755490152722632760),
    Dup111(.01415444650522613072733705129605375),
    Dup111(.01488137956116800324975278964173671)
};
static FLOAT QUAD_2D_P25_pts[Length(QUAD_2D_P25_wts) * 3] = {
    Perm21(.48602675846341286632108494106576852),
    Perm21(.43441069933617422686934557925604870),
    Perm21(.38988913524396382753969636952404462),
    Perm21(.29844323401980449068329287355490048),
    Perm21(.23404417233737183658023656970596734),
    Perm21(.15146833460901760000000000000000000),
    Perm21(.11273389354599349281729186486594851),
    Perm21(.07771569209152620223369817320827966),
    Perm21(.03489309361429690849533026177733858),
    Perm21(.00725818462093238916117013110606335),
    Perm111(.00129235270444219584099302931665302,.22721445215336410000000000000000000),
    Perm111(.00539970127211620182189732363132860,.43501055485357173125113362379450230),
    Perm111(.00638400303397498941895749776744540,.32030959927220447113000026445341979),
    Perm111(.00502821150199308271328582097413442,.09175032228000531039287201063543536),
    Perm111(.00682675862178184570668051931419220,.03801083585872443391784793002157854),
    Perm111(.01001619963992951145867446496978043,.15742521848531178511320753380098114),
    Perm111(.02575781317339004661287123576293491,.23988965977853325914298591466950265),
    Perm111(.03022789811991582345896227492462806,.36194311812606053179871201193912355),
    Perm111(.03050499010716207795935512861230592,.08355196095482845510691464351287596),
    Perm111(.04595654736256931928622033280840303,.14844322073241812268238560824628123),
    Perm111(.06744280054027761427028802732221226,.28373970872753497227148332506495505),
    Perm111(.07004509141591061747706842947324321,.40689937511878760390382808292080011),
    Perm111(.08391152464011664050042868280051014,.19411398702489250643935208871855679),
    Perm111(.12037553567715270000000000000000000,.32413434700070320631848835964861372),
    Perm111(.14806689915736669746097550576436943,.22927748355598104616627200389359665),
    Perm111(.19177186586732510675561189736742768,.32561812259598383120936369037062376)
};
static QUAD QUAD_2D_P25_ = {
    "2D P25",			/* name */
    2,				/* dim */
    25,				/* order */
    Length(QUAD_2D_P25_wts),	/* npoints = 126 */
    QUAD_2D_P25_pts,		/* points */
    QUAD_2D_P25_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P25 (&QUAD_2D_P25_)

static FLOAT QUAD_2D_P26_wts[] = {
    Dup3(.01417752160999602353323977972271527),
    Dup21(.01562847738814814970970457453697594),
    Dup21(.01463752622911178264133988219347403),
    Dup21(.01199877346634344861456211855900933),
    Dup21(.01408927503571013898691920328509770),
    Dup21(.01137089506541742371508421522672789),
    Dup21(.00576148405319945074736514087034656),
    Dup21(.00288047484993807908673712870762860),
    Dup21(.00061792400780682863983571128624684),
    Dup111(.00369419331787613967876812943308712),
    Dup111(.00343799094677204927555439258769779),
    Dup111(.00286153444220796869854630479719978),
    Dup111(.00203926220043675486828725055944921),
    Dup111(.00212260415935469294564133350026422),
    Dup111(.00119562615477588655866810063068187),
    Dup111(.00685739162489405400311650380844794),
    Dup111(.00734359958211473751194803942744208),
    Dup111(.00692380910755335710497733455285917),
    Dup111(.00568034562903817703600660475801349),
    Dup111(.00482902212700270888221406835346564),
    Dup111(.01217016111615610869604849372625312),
    Dup111(.01093398470027832184481918666951027),
    Dup111(.00874472678661106729318818910817295),
    Dup111(.00680604517250698803302377412054323),
    Dup111(.01411590919743288381954091229224022),
    Dup111(.01311478562571945830368980380706058),
    Dup111(.01294033945976499045298096058107199)
};
static FLOAT QUAD_2D_P26_pts[Length(QUAD_2D_P26_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.42738077638464831074877265985432388),
    Perm21(.38699172838462112393769349339592202),
    Perm21(.29080160649677600000000000000000000),
    Perm21(.21955119391561192225377283920396941),
    Perm21(.14147766876769242783780816190264115),
    Perm21(.08529773902470504192646771859292695),
    Perm21(.03245379871194203562256093430387330),
    Perm21(.00688528565235726390272245979876787),
    Perm111(.43994521155768505420225073420375411,
	    .55367421644525807832051112152536738),
    Perm111(.32999703483323129491627843183841851,
	    .66364319673874589711499831297210598),
    Perm111(.23082959156933124460906369415091164,
	    .76308863521363336439140145775470392),
    Perm111(.14794411408540751228070615912033131,
	    .84674293184236109088401920967886276),
    Perm111(.08331051165939022562807285094666142,
	    .90927752172075602921190126258082178),
    Perm111(.03550260326758216848726613913161973,
	    .95859557015929357672073151433554495),
    Perm111(.43799285096397419659511807977149749,
	    .52875010002019513801184885338236967),
    Perm111(.34184511530123979780425420810756385,
	    .62501066255799393838930209588631898),
    Perm111(.24321991316551786475075820451965981,
	    .72464470136332536323906998980156002),
    Perm111(.15369391178063810461104521948139224,
	    .81668780811826632451173297381674549),
    Perm111(.08182824840515584556272055876947980,
	    .88137737650647236457017244683395591),
    Perm111(.40543528702386735945093314372836966,
	    .51444288504473371249851667233726474),
    Perm111(.30047523445100120928119574237532588,
	    .62059693664252388102960854157646856),
    Perm111(.21029877498305665945876052946338960,
	    .71260468401313836547438957626142950),
    Perm111(.14192949723680286586293618687501310,
	    .78364422636910025200372459985859611),
    Perm111(.32282570605532179374541311121620042,
	    .53538969633347138690064718160659645),
    Perm111(.22503850086766503651915588373212567,
	    .63399334111941569685209117569438308),
    Perm111(.30622801452292528203795810454570981,
	    .48023900880456248705776905427268046)
};
static QUAD QUAD_2D_P26_ = {
    "2D P26",			/* name */
    2,				/* dim */
    26,				/* order */
    Length(QUAD_2D_P26_wts),	/* npoints = 133 */
    QUAD_2D_P26_pts,		/* points */
    QUAD_2D_P26_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P26 (&QUAD_2D_P26_)

static FLOAT QUAD_2D_P27_wts[] = {
    Dup3(.00132645422676788269875694817310637),
    Dup21(.01017606777254880480746165608356455),
    Dup21(.01355363518955792585297110164615270),
    Dup21(.01435575232352898855810447417832482),
    Dup21(.01762154025479284493331530463863313),
    Dup21(.01286456612407540576521896438320606),
    Dup21(.01021120788721442034062871052526150),
    Dup21(.00805484559136441340259536953879069),
    Dup21(.00485083247712445072994650912354335),
    Dup21(.00276034923845063648517112406186915),
    Dup21(.00064652022402423359706690809995414),
    Dup111(.00298280618704304171833833804758432),
    Dup111(.00286890029157565788749757647924691),
    Dup111(.00146771786779737406777795858954528),
    Dup111(.00163545643437809674920446933139427),
    Dup111(.00326270663499477733596716702887470),
    Dup111(.00127830372794885836417837000658451),
    Dup111(.00355054931897130700729806858502069),
    Dup111(.00705687847901615495175919551339405),
    Dup111(.00710874754932738751234293916033450),
    Dup111(.00619331568447356835579144233234119),
    Dup111(.00430573263634848540647054196708181),
    Dup111(.00538152713709093753671677026319717),
    Dup111(.00946147607081304454837567274132095),
    Dup111(.01038776441184486432462624183330042),
    Dup111(.00693741437082199035643509373698783),
    Dup111(.01056786087493971379972576670902532),
    Dup111(.01001591520410395750929434758482549),
    Dup111(.01145776939470566123752859291178484),
    Dup111(.01297709014466941197797189467632131)
};
static FLOAT QUAD_2D_P27_pts[Length(QUAD_2D_P27_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.46427084805466920349262004314703836),
    Perm21(.43229831434028157352333551631753476),
    Perm21(.39075381477193176882883899825279826),
    Perm21(.29984903083812250736371384535095833),
    Perm21(.24238609336669501198579355664452309),
    Perm21(.19575163384470794764935880541589295),
    Perm21(.11096422071801854111207889228991412),
    Perm21(.06784943782072336611132231104850517),
    Perm21(.03248814431443691367844218208374596),
    Perm21(.00702227048619495308291407220447055),
    Perm111(.44433448769671943201275224300444114,
	    .55016916248187282000891941332861776),
    Perm111(.24271988774832453561075341685216292,
	    .75119868054856110177318171512240453),
    Perm111(.15818892475209601952406305738166283,
	    .83835069531284232651520750772598161),
    Perm111(.08845560649090179633078521783025438,
	    .90629410967510652581883999276555543),
    Perm111(.33999316891507000002332849881468819,
	    .65372187099256441503697325319687970),
    Perm111(.03671154847229659731571109853308589,
	    .95724604370116430180960160528414269),
    Perm111(.08124029610361356005058157071908989,
	    .89177919384281966240532352562349587),
    Perm111(.43194999140455781310320628223711064,
	    .53892333102966923458236030560490706),
    Perm111(.32699693161719831316306130873483095,
	    .64047090201394740296518952785936033),
    Perm111(.23408117072735995645396481889795017,
	    .73431597148508412293269931866205238),
    Perm111(.15347363272308466475181254734395719,
	    .82492267618399551423539156004582949),
    Perm111(.12699941589030054190683503157639795,
	    .81688483424950280690392059398500667),
    Perm111(.36806660226545525465188762517330287,
	    .55934053585742889058858737838306859),
    Perm111(.26979607114851247262701085083588115,
	    .65088590636580683812387505565452156),
    Perm111(.18699471085773505905185124894492060,
	    .74499601198138427785033316282140954),
    Perm111(.34595044287272788784072078462621499,
	    .52709408040032769073500598867000113),
    Perm111(.18245632238005479720023182986667859,
	    .69385768740918414496471841615003464),
    Perm111(.26018384965949842909231289915918049,
	    .59478379886135638965559275913807350),
    Perm111(.31984867358313578155757977176391537,
	    .48237346031069377766871464449285085)
};
static QUAD QUAD_2D_P27_ = {
    "2D P27",			/* name */
    2,				/* dim */
    27,				/* order */
    Length(QUAD_2D_P27_wts),	/* npoints = 145 */
    QUAD_2D_P27_pts,		/* points */
    QUAD_2D_P27_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P27 (&QUAD_2D_P27_)

static FLOAT QUAD_2D_P28_wts[] = {
    Dup3(.00372851181690746808458802773780931),
    Dup21(.00193654415522499089798121523079372),
    Dup21(.00605141039266348349682076643537264),
    Dup21(.01141411355071663950946117311831634),
    Dup21(.01608007376313012939112012516866485),
    Dup21(.01403532910432407033763380729780537),
    Dup21(.00978327794286426243399757092983715),
    Dup21(.01267830169820560106561705330317056),
    Dup21(.01011411585946974486266089228810336),
    Dup21(.00376318422499545225814714605310903),
    Dup21(.00243119330615522129960297283149783),
    Dup21(.00042588994531646428122960119842518),
    Dup111(.00206901772064515543837924811367839),
    Dup111(.00215432386268054430571141067616092),
    Dup111(.00166065394763716989540584667501249),
    Dup111(.00138084032913645059993106848688128),
    Dup111(.00360171025661803306118091200062737),
    Dup111(.00097386114094506619777294737048538),
    Dup111(.00535413394306626012053016995775099),
    Dup111(.00423736286661477466768017827663045),
    Dup111(.00330847570421703082215419515418717),
    Dup111(.00448583942101861046216741271009491),
    Dup111(.00776555845120818901711264608747662),
    Dup111(.00687043734971177067707693439653168),
    Dup111(.00584068837096601687691778384738186),
    Dup111(.00888657317183860444062439413402823),
    Dup111(.01038315778562466496474547463182699),
    Dup111(.00655128753862388719526464995777170),
    Dup111(.00877076875255828946048204111223478),
    Dup111(.01218892935729072907621500755722349),
    Dup111(.01250643549629844281533668106200953),
    Dup111(.01269847559228270197407683124148953)
};
static FLOAT QUAD_2D_P28_pts[Length(QUAD_2D_P28_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.49835341312677973221949148740253129),
    Perm21(.48856275409050881854170094866703248),
    Perm21(.46478147828724737521816425323927792),
    Perm21(.38976627332101772838564635544311420),
    Perm21(.30154675118298200000000000000000000),
    Perm21(.26157407405925900000000000000000000),
    Perm21(.21410788634590951182959860455114779),
    Perm21(.17013819127147552416852263597020987),
    Perm21(.06437078350269442260455184210867187),
    Perm21(.03056003210401320908223320131174623),
    Perm21(.00570940793308473608535324150722078),
    Perm111(.29536153497141490674708319047417597,
	    .70085350685240175269511103394845061),
    Perm111(.20287670215559760434708665743838398,
	    .79193561974577570926640621745254478),
    Perm111(.12817949523631330608909975560928685,
	    .86701504698388816611813701911598314),
    Perm111(.07052544109205498392587648111966164,
	    .92391986491477366531821910182946052),
    Perm111(.39532631740896702860171237522193030,
	    .59771306110677331467243551041521591),
    Perm111(.02956827316914143637172672359648260,
	    .96465253113231383432304266408275803),
    Perm111(.30675094998690715371535728527788425,
	    .66850082953013352645351336823624571),
    Perm111(.22517182313337122500507617369889188,
	    .75132263382025994493510577224942991),
    Perm111(.07635892427059552575901260109062831,
	    .89611941137326587665824353804536658),
    Perm111(.14042475531972069418905256134644577,
	    .83328227859710106355842490700741297),
    Perm111(.39118747052871590865900820029002383,
	    .57082898894634335709509739044406166),
    Perm111(.19396081112987221646366179522225910,
	    .75010271498110326795986200675381153),
    Perm111(.11586020721321567595528110784524463,
	    .81777490624407893257309046195761535),
    Perm111(.28023728574593295635247200998364845,
	    .65528264369963779978719065630966078),
    Perm111(.35489334757487301545619510855666152,
	    .55787563056563336146991239029436233),
    Perm111(.14534210735467833470209926430836432,
	    .74965464658825236845917501382975580),
    Perm111(.21353594460615902118568163630567554,
	    .67815620035398476715714603087527412),
    Perm111(.38905986757978011881345023070696881,
	    .47478610218807292068119420965885141),
    Perm111(.27562890222960030201915925622737738,
	    .58603008200093619992681987776326855),
    Perm111(.31377995329904710006329372044106871,
	    .49151146351194286330016259453399046)
};
static QUAD QUAD_2D_P28_ = {
    "2D P28",			/* name */
    2,				/* dim */
    28,				/* order */
    Length(QUAD_2D_P28_wts),	/* npoints = 154 */
    QUAD_2D_P28_pts,		/* points */
    QUAD_2D_P28_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P28 (&QUAD_2D_P28_)

static FLOAT QUAD_2D_P29_wts[] = {
    Dup3(.01390369197243498012196860526728523),
    Dup21(.00119407074555933681859037971323571),
    Dup21(.00558417807814421700320296020710969),
    Dup21(.01401429650050351710041595861194328),
    Dup21(.01410780604708034305616878409304137),
    Dup21(.01342810431576591351787528351663394),
    Dup21(.01217537497609338458269338763086290),
    Dup21(.00722294427143959319468499698239233),
    Dup21(.00443751867960735637759182913807913),
    Dup21(.00019771881519265609682851845605640),
    Dup111(.00129189419129147303154103509431602),
    Dup111(.00112772642035394166015974617443553),
    Dup111(.00184745171735374848441682404155343),
    Dup111(.00071782203324654941618021167082972),
    Dup111(.00351318664214703198725396103172539),
    Dup111(.00349660600844854338988705837555120),
    Dup111(.00241690948038281274650124841577492),
    Dup111(.00081313466613996608724908914031470),
    Dup111(.00564942974660398293146765321429865),
    Dup111(.00445904031659885067338404631595062),
    Dup111(.00185640152529500022792451101805069),
    Dup111(.00701742231395962656370871380070187),
    Dup111(.00476963067992196310852157152860163),
    Dup111(.00768181583252764607257537723234668),
    Dup111(.00866304121915658321589732638654127),
    Dup111(.00694192073189620264349957702824600),
    Dup111(.00608713825993680733195825320444232),
    Dup111(.00987867211691082287437749173658670),
    Dup111(.01040317740016649468355653503351506),
    Dup111(.00677295750139824628718993144871263),
    Dup111(.00832356466794721739792214655562608),
    Dup111(.01175825678556958331667970045402759),
    Dup111(.01268117819931458364046050771195975)
};
static FLOAT QUAD_2D_P29_pts[Length(QUAD_2D_P29_wts) * 3] = {
    Perm3(.33333333333333333333333333333333333),
    Perm21(.49941626286799955409520464498316269),
    Perm21(.48948346983261497522938052895559610),
    Perm21(.38337490646926000907612840544797942),
    Perm21(.28657967124624950515035657391568590),
    Perm21(.23675743798075908296846185092132762),
    Perm21(.18444854262549379977888738237869426),
    Perm21(.09592097238345002706204055857161251),
    Perm21(.05732663714886085602392016667935097),
    Perm21(.00360814709934401389942946854275571),
    Perm111(.32459168027628713302158859225874986,
	    .67371212175894638940968866052450810),
    Perm111(.20538296110395026907966241605897587,
	    .79285585098032246467154265489876875),
    Perm111(.12781715504878891712709027697510756,
	    .86682261130980615198333080160570653),
    Perm111(.06397213170443202744985506555180679,
	    .93422003016808671513846621034706181),
    Perm111(.40877270304610163463977433263460813,
	    .58330425747295030197062188244089100),
    Perm111(.26000366001505949148390106470940356,
	    .72820244365190777874589416567626502),
    Perm111(.08370103760471207151750106127384500,
	    .89846466640643977698190152996194171),
    Perm111(.02277724243943714846816275979306666,
	    .97158629182957065178007512301223061),
    Perm111(.33249703304933480878170490873619909,
	    .64248824389424048968615511405857584),
    Perm111(.17546771597780866991339541376496896,
	    .80343317590650447549486585236617441),
    Perm111(.04239144337139153742306881985042489,
	    .93728223742102642341436645741650662),
    Perm111(.23808696074926436006355587074260398,
	    .71698190885093363334019663932316818),
    Perm111(.11385025949319543285234976170424461,
	    .84431131334463485469301787175078758),
    Perm111(.40769947121073335745665277255775013,
	    .54824721541790114707748890982833737),
    Perm111(.30971996601029726066117003751273698,
	    .62232557895213827911084197477161010),
    Perm111(.16501257707342404851428639610530038,
	    .76776792910869773214284522469888712),
    Perm111(.43736489346938777507788866536148926,
	    .48468874869866900000000000000000000),
    Perm111(.23036169231961739485460160639223048,
	    .66627592302530221745209390079397421),
    Perm111(.35305476702238759018727511157688575,
	    .54053899274173894698475001785466288),
    Perm111(.15871875580457590021286449358564550,
	    .72119885820756830541154885697690356),
    Perm111(.40214959194205300000000000000000001,
	    .45482738530050760506736521027227478),
    Perm111(.27186848606196062046228695803969211,
	    .57716886061275534659861021805529577),
    Perm111(.32870389995531448574405098549674708,
	    .47881463249708848352487404443818064)
};
static QUAD QUAD_2D_P29_ = {
    "2D P29",			/* name */
    2,				/* dim */
    29,				/* order */
    Length(QUAD_2D_P29_wts),	/* npoints = 166 */
    QUAD_2D_P29_pts,		/* points */
    QUAD_2D_P29_wts,		/* weights */
    -1				/* id */
};
#define QUAD_2D_P29 (&QUAD_2D_P29_)

/*---------------------------- 3D cubature rules ---------------------------*/

static FLOAT QUAD_3D_P1_wts[] = {
    Dup4(1.)
};
static FLOAT QUAD_3D_P1_pts[Length(QUAD_3D_P1_wts) * 4] = {
    Perm4(.25)
};
static QUAD QUAD_3D_P1_ = {
    "3D P1",			/* name */
    3,				/* dim */
    1,				/* order */
    Length(QUAD_3D_P1_wts),	/* npoints = 1 */
    QUAD_3D_P1_pts,		/* points */
    QUAD_3D_P1_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P1 (&QUAD_3D_P1_)

static FLOAT QUAD_3D_P2_wts[] = {
    Dup31(.25)
};
static FLOAT QUAD_3D_P2_pts[Length(QUAD_3D_P2_wts) * 4] = {
    /* (5. - sqrt(5.)) / 20, (5. + 3 * sqrt(5.)) / 20 */
    Perm31(.13819660112501051517954131656343619)
};
static QUAD QUAD_3D_P2_ = {
    "3D P2",			/* name */
    3,				/* dim */
    2,				/* order */
    Length(QUAD_3D_P2_wts),	/* npoints = 4 */
    QUAD_3D_P2_pts,		/* points */
    QUAD_3D_P2_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P2 (&QUAD_3D_P2_)

#if 0
static FLOAT QUAD_3D_P3_wts[] = {
    Dup31(1./40.),
    Dup31(9./40.)
};
static FLOAT QUAD_3D_P3_pts[Length(QUAD_3D_P3_wts) * 4] = {
    Perm31(0., 1.),
    Perm31(1./3., 0.)
};
#else
static FLOAT QUAD_3D_P3_wts[] = {
    /* 1 / 8 + sqrt((1715161837 - 406006699 * sqrt(17)) / 23101) / 3120 */
    Dup31(.13852796651186214232361769837564129),
    /* 1 / 8 - sqrt((1715161837 - 406006699 * sqrt(17)) / 23101) / 3120 */
    Dup31(.11147203348813785767638230162435871)
};
static FLOAT QUAD_3D_P3_pts[Length(QUAD_3D_P3_wts) * 4] = {
    /* (55 - 3 * sqrt(17) + sqrt(1022 - 134 * sqrt(17))) / 196 */
    Perm31(.32805469671142664733580581998119743),
    /* (55 - 3 * sqrt(17) - sqrt(1022 - 134 * sqrt(17))) / 196 */
    Perm31(.10695227393293068277170204157061650)
};
#endif
static QUAD QUAD_3D_P3_ = {
    "3D P3",			/* name */
    3,				/* dim */
    3,				/* order */
    Length(QUAD_3D_P3_wts),	/* npoints = 8 */
    QUAD_3D_P3_pts,		/* points */
    QUAD_3D_P3_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P3 (&QUAD_3D_P3_)

#if 0
static FLOAT QUAD_3D_P4_wts[] = {
    Dup4(-148./1875.),	/* negative weight */
    Dup31(343./7500.),
    Dup22(56./375.)
};
static FLOAT QUAD_3D_P4_pts[Length(QUAD_3D_P4_wts) * 4] = {
    Perm4(0.25),
    Perm31(1./14.),
    Perm22(0.1005964238332008)
};
static QUAD QUAD_3D_P4_ = {
    "3D P4",			/* name */
    3,				/* dim */
    4,				/* order */
    11,				/* npoints = 11 */
    QUAD_3D_P4_pts,		/* points */
    QUAD_3D_P4_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P4 (&QUAD_3D_P4_)
#else
static FLOAT QUAD_3D_P4_wts[] = {
    Dup31(.07349304311636194934358694586367885),
    Dup31(.11268792571801585036501492847638892),
    Dup22(.04254602077708146686093208377328816)
};
static FLOAT QUAD_3D_P4_pts[Length(QUAD_3D_P4_wts) * 4] = {
    Perm31(.09273525031089122628655892066032137),
    Perm31(.31088591926330060975814749494040332),
    Perm22(.04550370412564965000000000000000000)
};
static QUAD QUAD_3D_P4_ = {
    "3D P4",			/* name */
    3,				/* dim */
    4,				/* order */
    Length(QUAD_3D_P4_wts),	/* npoints = 14 */
    QUAD_3D_P4_pts,		/* points */
    QUAD_3D_P4_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P4 (&QUAD_3D_P4_)
#endif

#if 0
/* Stroud T3:5-1 p315 */
static FLOAT QUAD_3D_P5_wts[] = {
    Dup4(16./135.),
    /* (2665 + 14 * sqrt(15)) / 37800 */
    Dup31(.07193708377901862),
    /* (2665 - 14 * sqrt(15)) / 37800 */
    Dup31(.06906820722627239),
    Dup22(20./378.)
};
static FLOAT QUAD_3D_P5_pts[Length(QUAD_3D_P5_wts) * 4] = {
    Perm4(.25),
    /* (7 - sqrt(15)) / 34, (13 + 3 * sqrt(15)) / 34 */
    Perm31(.09197107805272303),
    /* (7 + sqrt(15)) / 34, (13 - 3 * sqrt(15)) / 34 */
    Perm31(.31979362782962991),
    /* (10 - 2 * sqrt(15)) / 40, (10 + 2 * sqrt(15)) / 40 */
    Perm22(.05635083268962916)
};
static QUAD QUAD_3D_P5_ = {
    "3D P5",			/* name */
    3,				/* dim */
    5,				/* order */
    15,				/* npoints = 15 */
    QUAD_3D_P5_pts,		/* points */
    QUAD_3D_P5_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P5 (&QUAD_3D_P5_)
#else
static FLOAT QUAD_3D_P5_wts[] = {
    Dup31(.11268792571801585079918565233328633),
    Dup31(.07349304311636194954371020548632750),
    Dup22(.04254602077708146643806942812025744)

};
static FLOAT QUAD_3D_P5_pts[Length(QUAD_3D_P5_wts) * 4] = {
    Perm31(.31088591926330060979734573376345783),
    Perm31(.09273525031089122640232391373703061),
    Perm22(.04550370412564964949188052627933943)
};
static QUAD QUAD_3D_P5_ = {
    "3D P5",			/* name */
    3,				/* dim */
    5,				/* order */
    Length(QUAD_3D_P5_wts),	/* npoints = 14 */
    QUAD_3D_P5_pts,		/* points */
    QUAD_3D_P5_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P5 (&QUAD_3D_P5_)
#endif

static FLOAT QUAD_3D_P6_wts[] = {
    Dup31(.03992275025816749209969062755747998),
    Dup31(.01007721105532064294801323744593686),
    Dup31(.05535718154365472209515327785372602),
    Dup211(27./560.)
};
static FLOAT QUAD_3D_P6_pts[Length(QUAD_3D_P6_wts) * 4] = {
    Perm31(.21460287125915202928883921938628499),
    Perm31(.04067395853461135311557944895641006),
    Perm31(.32233789014227551034399447076249213),
    /* (3 - sqrt(5)) / 12, (5 + sqrt(5)) / 12, (1 + sqrt(5)) / 12 */
    Perm211(.06366100187501752529923552760572698,
	    .60300566479164914136743113906093969)
};
static QUAD QUAD_3D_P6_ = {
    "3D P6",			/* name */
    3,				/* dim */
    6,				/* order */
    Length(QUAD_3D_P6_wts),	/* npoints = 24 */
    QUAD_3D_P6_pts,		/* points */
    QUAD_3D_P6_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P6 (&QUAD_3D_P6_)

static FLOAT QUAD_3D_P7_wts[] = {
    Dup4(.09548528946413084886057843611722638),
    Dup31(.04232958120996702907628617079854674),
    Dup22(.03189692783285757993427482408294246),
    Dup211(.03720713072833462136961556119148112),
    Dup211(.00811077082990334156610343349109654)
};
static FLOAT QUAD_3D_P7_pts[Length(QUAD_3D_P7_wts) * 4] = {
    Perm4(.25),
    Perm31(.31570114977820279942342999959331149),
    Perm22(.05048982259839636876305382298656247),
    Perm211(.18883383102600104773643110385458576,
	    .57517163758700002348324157702230752),
    Perm211(.02126547254148324598883610149981994,
	    .81083024109854856111810537984823239)
};
static QUAD QUAD_3D_P7_ = {
    "3D P7",                    /* name */
    3,                          /* dim */
    7,                          /* order */
    Length(QUAD_3D_P7_wts),     /* npoints = 35 */
    QUAD_3D_P7_pts,             /* points */
    QUAD_3D_P7_wts,             /* weights */
    -1                          /* id */
};
#define QUAD_3D_P7 (&QUAD_3D_P7_)

static FLOAT QUAD_3D_P8_wts[] = {
    Dup31(.00639714777990232132145142033517302),
    Dup31(.04019044802096617248816115847981783),
    Dup31(.02430797550477032117486910877192260),
    Dup31(.05485889241369744046692412399039144),
    Dup22(.03571961223409918246495096899661762),
    Dup211(.00718319069785253940945110521980376),
    Dup211(.01637218194531911754093813975611913)
};
static FLOAT QUAD_3D_P8_pts[Length(QUAD_3D_P8_wts) * 4] = {
    Perm31(.03967542307038990126507132953938949),
    Perm31(.31448780069809631378416056269714830),
    Perm31(.10198669306270330000000000000000000),
    Perm31(.18420369694919151227594641734890918),
    Perm22(.06343628775453989240514123870189827),
    Perm211(.02169016206772800480266248262493018,
	    .71993192203946593588943495335273478),
    Perm211(.20448008063679571424133557487274534,
	    .58057719012880922417539817139062041)
};
static QUAD QUAD_3D_P8_ = {
    "3D P8",			/* name */
    3,				/* dim */
    8,				/* order */
    Length(QUAD_3D_P8_wts),	/* npoints = 46 */
    QUAD_3D_P8_pts,		/* points */
    QUAD_3D_P8_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P8 (&QUAD_3D_P8_)

static FLOAT QUAD_3D_P9_wts[] = {
    Dup4(.05489853459364812686895885032391298),
    Dup31(.00421825735654367356185795185819147),
    Dup31(.02348412311384798927791501022996111),
    Dup31(.00421283454980389148648831814037819),
    Dup31(.02994712640542812769203037546126163),
    Dup22(.03695441750679136335292416138761121),
    Dup211(.00817349224171051348425319650294732),
    Dup211(.00987978656102278957913113314297149),
    Dup211(.02160718741919244401497646690335203)
};
static FLOAT QUAD_3D_P9_pts[Length(QUAD_3D_P9_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.03785502061999503609086515586175707),
    Perm31(.16954439965012220000000000000000000),
    Perm31(.05484140424416689000000000000000000),
    Perm31(.32229717190921058836777748445908171),
    Perm22(.10961777508972033704050355954365052),
    Perm211(.45915766038590539763886410168178216,.08004485927247373376034330857923567),
    Perm211(.03296694775357210169727386483414899,.71879584022434055051132299796383374),
    Perm211(.18174359672117481549870278661377760,.60023700739524674102301240348069459)
};
static QUAD QUAD_3D_P9_ = {
    "3D P9",			/* name */
    3,				/* dim */
    9,				/* order */
    Length(QUAD_3D_P9_wts),	/* npoints = 59 */
    QUAD_3D_P9_pts,		/* points */
    QUAD_3D_P9_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P9 (&QUAD_3D_P9_)

static FLOAT QUAD_3D_P10_wts[] = {
    Dup4(.04574189830483037077884770618329337),
    Dup31(.01092727610912416907498417206565671),
    Dup31(.00055352334192264689534558564012282),
    Dup31(.02569337913913269580782688316792080),
    Dup22(.00055387649657283109312967562590035),
    Dup211(.01044842402938294329072628200105773),
    Dup211(.02513844602651287118280517785487423),
    Dup211(.01178620679249594711782155323755017),
    Dup211(.01332022473886650471019828463616468),
    Dup211(.00615987577565961666092767531756180)
};
static FLOAT QUAD_3D_P10_pts[Length(QUAD_3D_P10_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.11425191803006935688146412277598412),
    Perm31(.01063790234539248531264164411274776),
    Perm31(.31274070833535645859816704980806110),
    Perm22(.01631296303281644000000000000000000),
    Perm211(.03430622963180452385835196582344460,.59830121060139461905983787517050400),
    Perm211(.12346418534551115945916818783743644,.47120066204746310257913700590727081),
    Perm211(.40991962933181117418479812480531207,.16546413290740130923509687990363569),
    Perm211(.17397243903011716743177479785668929,.62916375300275643773181882027844514),
    Perm211(.03002157005631784150255786784038011,.81213056814351208262160080755918730)
};
static QUAD QUAD_3D_P10_ = {
    "3D P10",			/* name */
    3,				/* dim */
    10,				/* order */
    Length(QUAD_3D_P10_wts),	/* npoints = 79 */
    QUAD_3D_P10_pts,		/* points */
    QUAD_3D_P10_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P10 (&QUAD_3D_P10_)

static FLOAT QUAD_3D_P11_wts[] = {
    Dup31(.01612698613577620369120244222737879),
    Dup31(.00178872341812357138976990346996962),
    Dup31(.00847529348343123401863799968389086),
    Dup31(.01238021263944669050859562763135516),
    Dup31(.02205586697199415746140963638568037),
    Dup31(.02295765467664274421265594265203307),
    Dup22(.00120553827014535727045055662252294),
    Dup22(.02479381575164443454447803302296997),
    Dup211(.01203878836480353606935457416590660),
    Dup211(.00189370204498242146248858917618493),
    Dup211(.01838752922255814184581020943433469),
    Dup211(.00375249249801662461193260176157591),
    Dup211(.00633289841693951300885921328914879)
};
static FLOAT QUAD_3D_P11_pts[Length(QUAD_3D_P11_wts) * 4] = {
    Perm31(.12460560449278830000000000000000000),
    Perm31(.02609630765687464746851542316261877),
    Perm31(.07193883255798884087330011042809557),
    Perm31(.32611122454203676937273102302894204),
    Perm31(.29405882789858127213310307732130217),
    Perm31(.19271399104965490000000000000000000),
    Perm22(.00047127204692773946587837159205225),
    Perm22(.10321360207480949336085123341390539),
    Perm211(.04349989920159741251267172033621503,.63045319723555591476353398203997141),
    Perm211(.01414839289422299290755441603794058,.82491678632147090000000000000000000),
    Perm211(.21646077368258425486341884576246642,.52711130286496480000000000000000000),
    Perm211(.13301884366834711587538262083530116,.73318551371398651551736762818473584),
    Perm211(.44054756810613723082959230959880706,.11506799584377921703650823955291194)
};
static QUAD QUAD_3D_P11_ = {
    "3D P11",			/* name */
    3,				/* dim */
    11,				/* order */
    Length(QUAD_3D_P11_wts),	/* npoints = 96 */
    QUAD_3D_P11_pts,		/* points */
    QUAD_3D_P11_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P11 (&QUAD_3D_P11_)

#if 0
/* This rule has smaller smallest weight, but larger smallest coordinate */
static FLOAT QUAD_3D_P12_wts[] = {
    Dup4(.02589965672379885946221733044466074),
    Dup31(.01188011778542489263304669307765255),
    Dup31(.00019243842802940139599667156916414),
    Dup31(.01460564220714648400941139428792250),
    Dup31(.02353236994618624831565909171056252),
    Dup31(.00346404243764658661894167546736912),
    Dup31(.00228568518874660364931057482041380),
    Dup22(.00501950062495183938689269420528004),
    Dup211(.00320174248310251480919195429036897),
    Dup211(.00202024177312536986954908485107823),
    Dup211(.01899921243817155551496634864579523),
    Dup211(.01117477555012353260111605364799274),
    Dup211(.00207779882840923556600240825180423),
    Dup211(.00869161875227804588294414185879858),
    Dup1111(.00692322823546859111673842508505270)
};
static FLOAT QUAD_3D_P12_pts[Length(QUAD_3D_P12_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.19116879305510430000000000000000000),
    Perm31(.00682229647466825300000000000000000),
    Perm31(.11103797219861743807174062535414434),
    Perm31(.30431537393096840008351569498769254),
    Perm31(.33330701922933059830641111348885293),
    Perm31(.03749731365321851391723610755748038),
    Perm22(.02908058522435483091440010450122699),
    Perm211(.10629116753733978623182625071275481,.77130194925321140000000000000000000),
    Perm211(.01502748327185297263655744616273496,.65443537701179976723333225063505233),
    Perm211(.11858644579813568530889450851753765,.47382134604605374894284625141111954),
    Perm211(.23794356469277477534447903853264153,.49612597976538932876414383840091269),
    Perm211(.01843178364329910061032558678799065,.83375846651196750385382238298017745),
    Perm211(.42701814417313713339071532305024250,.12504688768243536523870060457848538),
    Perm1111(.64187643174850151718866301627283112,.24168463603891561876101692273289702,.09328358047945690018548146926510585)
};
static QUAD QUAD_3D_P12_ = {
    "3D P12",			/* name */
    3,				/* dim */
    12,				/* order */
    Length(QUAD_3D_P12_wts),	/* npoints = 127 */
    QUAD_3D_P12_pts,		/* points */
    QUAD_3D_P12_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P12 (&QUAD_3D_P12_)
#else
/* This rule has larger smallest weight, but smaller smallest coordinate */
static FLOAT QUAD_3D_P12_wts[] = {
    Dup4(.02340581914868067999082580773836836),
    Dup31(.00484469946470415656870798306091558),
    Dup31(.00079865303812732982185563521014343),
    Dup31(.01311872008808756207964488505025527),
    Dup31(.02352182961292765917274505054313770),
    Dup31(.00210860882494149803857437048649497),
    Dup31(.00047839298963616600187228601742259),
    Dup22(.00204546234216855322941711800170502),
    Dup211(.00334576331671817115245418532677178),
    Dup211(.01181044822479275264785338274950585),
    Dup211(.00290156990282342152841364375092118),
    Dup211(.00949250645501753676094846901252898),
    Dup211(.02094018358085748583183796760479700),
    Dup211(.00171435866337409051521874943702732),
    Dup1111(.00759915954173370886076474450830409)
};
static FLOAT QUAD_3D_P12_pts[Length(QUAD_3D_P12_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.19318721110347230000000000000000000),
    Perm31(.01811701371436566878506928822499717),
    Perm31(.10700751831426066518406159227423033),
    Perm31(.29936173715970702940603127680004538),
    Perm31(.33333033333333333042835213613025030),
    Perm31(.16575369007421640000000000000000000),
    Perm22(.04009986052352575650366980228640728),
    Perm211(.01951844463761131301132122485607343,.59982639757597731668263005976738196),
    Perm211(.24970741896308715787490891769354198,.47400425629911050000000000000000000),
    Perm211(.07674205857869954726322831328843659,.83056291375422969598432041821082569),
    Perm211(.43011409627915217536723647418133112,.02265922072588833582931396831630072),
    Perm211(.12197854304894211937147375564906792,.47765370899783134571567376444973682),
    Perm211(.01480482319031682427540691439704854,.81083799468092699988474915243749073),
    Perm1111(.65250697573013212016385330106711095,.22646235632397177636617160407210034,.02251830769546778956654013747639605)
};
static QUAD QUAD_3D_P12_ = {
    "3D P12",			/* name */
    3,				/* dim */
    12,				/* order */
    Length(QUAD_3D_P12_wts),	/* npoints = 127 */
    QUAD_3D_P12_pts,		/* points */
    QUAD_3D_P12_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P12 (&QUAD_3D_P12_)
#endif

static FLOAT QUAD_3D_P13_wts[] = {
    Dup4(.02191579945212728678229670892998658),
    Dup31(.00809592740005652573580359966615063),
    Dup31(.00130319185047278813746994806952476),
    Dup31(.01996610676014222116016391561580003),
    Dup31(.02125705756007566772097136088386650),
    Dup22(.00077331890737182713690269661719116),
    Dup22(.01755491389570430512641028370006205),
    Dup211(.00213830361001659899343287397434178),
    Dup211(.00256560169283338620814651902766716),
    Dup211(.00338953948455728203040932651810398),
    Dup211(.01135828330503278417235563981454793),
    Dup211(.01103203882197761043040360052454856),
    Dup211(.00457602573785952356043458354199517),
    Dup211(.00827343104220868129752243222682095),
    Dup211(.00586641165391940007076312979369247),
    Dup1111(.00313458521939849614410720196518793)
};
static FLOAT QUAD_3D_P13_pts[Length(QUAD_3D_P13_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.09935339765028269917868020572165369),
    Perm31(.02361873260499568532036302265004401),
    Perm31(.30089166537572662790706731844610997),
    Perm31(.18156624280757148139366685840064601),
    Perm22(.00428160639152879988718710754508354),
    Perm22(.12290357421888442998582785890620434),
    Perm211(.28318219770202728236417353077594322,.43037955664247500440987356786807501),
    Perm211(.02239485904524970717572425710098278,.83488749018470024820940398932904512),
    Perm211(.02191788402113435132324662419880111,.67691762094326571059673391273529166),
    Perm211(.21481417044274656673534260788169227,.52280311286258745560867693994038579),
    Perm211(.08000490008644308882018405418010744,.24689045570275147370034631014113188),
    Perm211(.11579466150271899371721034492503850,.74997281767443310000000000000000000),
    Perm211(.39129315347000474438672195978809687,.18835457382799180000000000000000000),
    Perm211(.45315745821242834581317282468854978,.02202033169457796534173826092007299),
    Perm1111(.27324999892429634023602493512400674,.60775441245653315696274741541102470,.00561877924700169073874366184065955)
};
static QUAD QUAD_3D_P13_ = {
    "3D P13",			/* name */
    3,				/* dim */
    13,				/* order */
    Length(QUAD_3D_P13_wts),	/* npoints = 149 */
    QUAD_3D_P13_pts,		/* points */
    QUAD_3D_P13_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P13 (&QUAD_3D_P13_)

static FLOAT QUAD_3D_P14_wts[] = {
    Dup31(.00898427322254918127543126682598773),
    Dup31(.00235414897468188299910869230818368),
    Dup31(.00733553866836377016223467789336265),
    Dup31(.00360629336228634011530354432318077),
    Dup31(.00022796656022189240650071390651338),
    Dup22(.00425068731230945391542573203967906),
    Dup211(.00502229674184657212637707578731437),
    Dup211(.00664105199619194276141547967835717),
    Dup211(.00648663075652078221084713724389357),
    Dup211(.01084924609520658118048627917429636),
    Dup211(.00698225572400728567899793615355807),
    Dup211(.01057643198113441258335538488635301),
    Dup211(.00172517387494940531214061228255136),
    Dup211(.01064026039260234415487304925754523),
    Dup211(.00031627239419231128593612508289817),
    Dup211(.00676212093730203740266276007684025),
    Dup1111(.00293371746826111669254642316791922),
    Dup1111(.00091803679200083798695474146748587)
};
static FLOAT QUAD_3D_P14_pts[Length(QUAD_3D_P14_wts) * 4] = {
    Perm31(.12703434587701869604797950660749487),
    Perm31(.03716308713428675181759859706979325),
    Perm31(.30931161817607732544635505822019770),
    Perm31(.07778813507287403019691221965639750),
    Perm31(.01187611663683786502091234677477106),
    Perm22(.02371189715571358237825633505545476),
    Perm211(.04551422172971295738029708158398140,.73884882267833978290969755547076243),
    Perm211(.19457055431059420000000000000000000,.36138202354403612356128050094846106),
    Perm211(.42158193164647035846631052119479790,.13481021809330111977392354242291205),
    Perm211(.36227661803202431683389679069549247,.09100846759454444774082592541447308),
    Perm211(.26662003783461096351186917353420086,.45135951603290056428206454329600320),
    Perm211(.07870367664603755989163074150395650,.53854007868617855365162509332690316),
    Perm211(.01462604843949452202375023818416595,.68140642280720592407050422036244765),
    Perm211(.20755902173331721318141636044536441,.49641284136813420000000000000000000),
    Perm211(.00317672566580133046838579859910808,.88571644680187933415518991697343211),
    Perm211(.16634658949265576428233847556684871,.64221464654291632524678940601354742),
    Perm1111(.59698804897542365623933181080626979,.30344194369885264264500117734906354,.00772105989990930297678960227638472),
    Perm1111(.81379652801439184798325669233364806,.06021328978843793059084645285790579,.12582571438467239382589793638340901)
};
static QUAD QUAD_3D_P14_ = {
    "3D P14",			/* name */
    3,				/* dim */
    14,				/* order */
    Length(QUAD_3D_P14_wts),	/* npoints = 194 */
    QUAD_3D_P14_pts,		/* points */
    QUAD_3D_P14_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P14 (&QUAD_3D_P14_)

static FLOAT QUAD_3D_P15_wts[] = {
    Dup31(.01511655113441068628579262410695901),
    Dup31(.00001738706704490033047765207649289),
    Dup31(.00408585202038717648728016969643145),
    Dup22(.00592951036834067574154481489521970),
    Dup22(.01420051324006323918208630429532935),
    Dup22(.00136583559622061392953778218648684),
    Dup211(.00597843624352069400428887732014643),
    Dup211(.00213385927130234729441847373974791),
    Dup211(.00085751208108799141852494440382306),
    Dup211(.00655418423314395143320591423869070),
    Dup211(.00145239359342879306554178830466918),
    Dup211(.00147765208012100448758842442963730),
    Dup211(.01081554170660306739887132139435944),
    Dup211(.00024706437793471016224470871566645),
    Dup211(.00234657677419497479387086599232896),
    Dup211(.00558455102470039972935684386805533),
    Dup211(.00047614970218433417418631138964354),
    Dup211(.00652552745936288648367228758797825),
    Dup1111(.00355529314103980065711359565274541),
    Dup1111(.00254671621466224217846844420241250),
    Dup1111(.00476266986570878721098194646156262)
};
static FLOAT QUAD_3D_P15_pts[Length(QUAD_3D_P15_wts) * 4] = {
    Perm31(.28124082071166706712228812256180659),
    Perm31(.00000100000000000000000000000000000),
    Perm31(.33056317367432518802610420354554872),
    Perm22(.05655437237844684197147304064357931),
    Perm22(.13406515374085695587554535149192519),
    Perm22(.01239081855247817851688132222166487),
    Perm211(.14221122178861693892726683983688389,.64809821878560890000000000000000000),
    Perm211(.02090030455681822945106611831783482,.65116321211987558801152908926761095),
    Perm211(.10144207052995866487339983352935483,.79447457077349830086964982075533754),
    Perm211(.08775565461483070674887889035957709,.53891506037733579601146950816566679),
    Perm211(.01998436504573363744360581546507844,.84228234042896665795195102873353839),
    Perm211(.06649943952962487000000000000000000,.80627017415793485464777412253196755),
    Perm211(.25438425646033346908988464012136442,.42513796317252088424321606777763436),
    Perm211(.00234540856303606208380148727978905,.77743944851625139876389227055364820),
    Perm211(.21804126228722166267028321193653146,.56369987819744481913063704381874069),
    Perm211(.17628473381389930000000000000000000,.47113514937830371190183410485213220),
    Perm211(.03692599014419112524447544153674980,.92319344206103834904944651746567873),
    Perm211(.39915131927633474627502159614222501,.18025052210917373840254964287864445),
    Perm1111(.70992232018321836731926292111215212,.07781901333037738366765196393633786,.01956139662389449507339296707905076),
    Perm1111(.55032805389206083155759265306174001,.08164397664371474524823001052216509,.00913454545923239001997189364340146),
    Perm1111(.55025255453513500000000000000000000,.14593285191012480000000000000000000,.04144548457433058363391383686956707)
};
static QUAD QUAD_3D_P15_ = {
    "3D P15",			/* name */
    3,				/* dim */
    15,				/* order */
    Length(QUAD_3D_P15_wts),	/* npoints = 246 */
    QUAD_3D_P15_pts,		/* points */
    QUAD_3D_P15_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P15 (&QUAD_3D_P15_)

/* Note the rules P16-P20 are from the following papers, mainly [2], by
 * Jan Ja\'skowiec and N. Sukumar:
 *  [1]	High-order cubature rules for tetrahedra,
 *	Int. J. for Numer. Meth. in Engng, vol.121, no.11, 2020.
 *  [2]	High-order symmetric cubature rules for tetrahedra and pyramids,
 *	Int. J. for Numer. Meth. in Engng, vol.122, no.1, 2021.
 *  [3]	Addendum to ``High-order symmetric cubature rules for tetrahedra
 *	and pyramids'', Int. J. for Numer. Meth. in Engng, vol.122, no.7, 2021.
 */

static FLOAT QUAD_3D_P16_wts[] = {
    Dup31(.00403487893723887049265039601220684),
    Dup31(.00526342800804762849619159416605960),
    Dup31(.01078639106857763822747522856875491),
    Dup31(.00189234002903099684224605393918402),
    Dup22(.00601451100300045870650067420901317),
    Dup22(.00869219123287302312727334847940610),
    Dup211(.00350762328578499275659307009126951),
    Dup211(.00118866227331919807192940951748929),
    Dup211(.00434522531446666750864079816261451),
    Dup211(.00266068657020316603764648612019192),
    Dup211(.00555317430212401341478384714866174),
    Dup211(.00015314314053958076996931089638380),
    Dup211(.00223120413671567928866289542090939),
    Dup1111(.00247237715624996985149659692307816),
    Dup1111(.00659612289181792506876909773112724),
    Dup1111(.00060043490676974216087269159340661),
    Dup1111(.00224233099687652742449689510982133),
    Dup1111(.00082444223624718372748546097521409),
    Dup1111(.00438801583526791034381358666584691),
    Dup1111(.00345427842574096232228714634129452),
    Dup1111(.00392928947333557070846156486164535)
};
static FLOAT QUAD_3D_P16_pts[Length(QUAD_3D_P16_wts) * 4] = {
    Perm31(.32967147384406063619375162258031196),
    Perm31(.11204210441737877557977355269085785),
    Perm31(.28044602591109291917326968759374922),
    Perm31(.03942164444076165530186041315194336),
    Perm22(.07491741856476755331936887653337858),
    Perm22(.33569310295563458148449388353009909),
    Perm211(.04904898759556674851708836681755199,.76468706758018040128352585522097679),
    Perm211(.01412609568309253397023383730394044,.23282680458942511289537501209852151),
    Perm211(.06239652058154325208658365747436279,.28324176830779468643565585504428986),
    Perm211(.18909592756965597717224790600688877,.01283187405611823970074593204830391),
    Perm211(.27501760012954439487094433006628105,.38727096031949030862955433360477075),
    Perm211(.00594489825256994551853672034278369,.03723805935523541954759090988386045),
    Perm211(.11830580710999444802339227394482751,.74829410783088587547640692441989412),
    Perm1111(.08011846127872502380489538529429122,.51463578878883950389557459439302904,.39080211141879205490649181473579692),
    Perm1111(.31025854986272726854690199497600369,.16457394683790985618365497081112626,.06995093322963368912711775566495230),
    Perm1111(.10852408019289846676496859793631046,.03435867950145695762069918674064249,.85571569922057519215400444464572650),
    Perm1111(.24838249878149546329329939696635675,.66253175448505093003700617661466167,.01098323448764900444073955046178437),
    Perm1111(.39600912110670350629865233312005293,.01226898678006518846085017274454891,.01878187449597509734542135006798163),
    Perm1111(.06367516197137305787610880659547363,.20546049913241051283959332798606714,.13624495088858952521524101996191479),
    Perm1111(.17576504661391044061489056539266476,.46106788607969942837687869968339046,.13875357096122530918456923931101452),
    Perm1111(.47799425320067043636083307018835951,.01344788610299629067374252417192062,.32213983065389956084144880408640740)
};
static QUAD QUAD_3D_P16_ = {
    "3D P16",			/* name */
    3,				/* dim */
    16,				/* order */
    Length(QUAD_3D_P16_wts),	/* npoints = 304 */
    QUAD_3D_P16_pts,		/* points */
    QUAD_3D_P16_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P16 (&QUAD_3D_P16_)

static FLOAT QUAD_3D_P17_wts[] = {
    Dup31(.00294341105468265476465301375384412),
    Dup31(.00048212545621309734601171163982517),
    Dup31(.00163341188233597072740743878709148),
    Dup31(.00893726054473396705331939750119304),
    Dup22(.00353928104113144424344560299599883),
    Dup22(.00512787677512291314745392610872317),
    Dup22(.00850596170577665595130514210900874),
    Dup22(.00136200105956508960247502855469429),
    Dup211(.00195270359469908288636965201463818),
    Dup211(.00355248233270215575244004573548898),
    Dup211(.00473503787208788085100738794395656),
    Dup211(.00407620405252378067703062647719036),
    Dup211(.00439788961603859075211255573367740),
    Dup211(.00081599154180394796242381112514100),
    Dup211(.00643692740335644074712927900064204),
    Dup211(.00022909370299782243803380784018618),
    Dup211(.00318874669420498006347680515275568),
    Dup1111(.00199126625996987858124341877247173),
    Dup1111(.00120994663686878080515564954290316),
    Dup1111(.00294341798218390226317743909215644),
    Dup1111(.00345409455481056401303307608535922),
    Dup1111(.00082411354147775710633069434554843),
    Dup1111(.00138354237817018513010163693168215),
    Dup1111(.00178144523592653809416848795126912),
    Dup1111(.00069693163510014018882843141646732),
    Dup1111(.00572288840189160536821399512787235)
};
static FLOAT QUAD_3D_P17_pts[Length(QUAD_3D_P17_wts) * 4] = {
    Perm31(.10925941103913998430204301973365113),
    Perm31(.01706905335350990735233658563172093),
    Perm31(.06030276440208671041148300589992563),
    Perm31(.18029367787524873964221439158029196),
    Perm22(.20756424943199227708813154528934740),
    Perm22(.06350561875036179085311820815634410),
    Perm22(.14257409485698342092173200695525142),
    Perm22(.01525498961135818137188378685194694),
    Perm211(.28177174686618235750025213072518816,.00660562854593635408136647911947504),
    Perm211(.25327928966163938165119622260815635,.34730767552697886873897363824258190),
    Perm211(.11944468368879918724692767840075227,.51296319321353043709739747408669749),
    Perm211(.27969758921799776150948437970230280,.40401351501313789547139720358969314),
    Perm211(.05914965001755915999816377132594456,.27715057680379788257740604891784941),
    Perm211(.01156645687972039208391530434001723,.33726932317139624255819399053021162),
    Perm211(.25462009461186186959704161075935864,.08899213511967390325069750206575321),
    Perm211(.00667291467786515853481064175679727,.08335377000797281870216898876250216),
    Perm211(.05954996366173629310959666232435279,.14887385146092256658164922763170033),
    Perm1111(.09563829425828948509178626386370740,.01308047471312759739620741802517124,.16834930641823021217921939706352555),
    Perm1111(.06035751534893870614944044579308337,.63765519934162523922069584308760886,.01062246299591423181542590103314523),
    Perm1111(.57206296627532713186500555970761976,.15750628240845837465004819774824245,.01289545879798303789248123781877379),
    Perm1111(.59828716184995476688552410530098191,.15309636122213675391083109364989746,.06489065131906320289333003800823760),
    Perm1111(.08721077921772252622580524433496784,.01165500297046612232695518298817505,.04707766223753579371327370056012835),
    Perm1111(.41377996806619141367438605480046339,.40853289101632561493997744003602994,.01048009320013414570655932142212393),
    Perm1111(.39049895837194248184640032407508961,.01167932299246963888982294164451026,.07360595669274641968965107244513106),
    Perm1111(.77350174035347173789449604002255541,.00816368037123298165733860303389830,.02545430962429987850849469655859670),
    Perm1111(.05603440494408158076279736877131529,.15298860550317515420176869220407768,.32269864692600432835740366361829820)
};
static QUAD QUAD_3D_P17_ = {
    "3D P17",			/* name */
    3,				/* dim */
    17,				/* order */
    Length(QUAD_3D_P17_wts),	/* npoints = 364 */
    QUAD_3D_P17_pts,		/* points */
    QUAD_3D_P17_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P17 (&QUAD_3D_P17_)

static FLOAT QUAD_3D_P18_wts[] = {
    Dup31(.00150538840675059550939000404900735),
    Dup31(.00720144153152843635234534325040342),
    Dup31(.00580180123369481459326923021054914),
    Dup31(.00246508839284979077884008187708316),
    Dup31(.00082352710591100206362657393620512),
    Dup31(.00239615339582495960337918135010688),
    Dup31(.00016620265380624528892162500311399),
    Dup22(.00004747626606883917555964059922030),
    Dup22(.00056549604041758050804532222606099),
    Dup22(.00112664484758759813802379280337283),
    Dup22(.00134824615188020064598750975399724),
    Dup22(.00036570690966776828700167755772269),
    Dup22(.00585317199256511398038065347825921),
    Dup22(.00195669103482143031882918763661692),
    Dup22(.00167324425217903940207775488200997),
    Dup211(.00168440997312563439024289254590929),
    Dup211(.00094897330309711501222542143922268),
    Dup211(.00103908313593165271940704307856968),
    Dup211(.00286855832424034792608365072660944),
    Dup211(.00367220278457213190378223801121348),
    Dup211(.00474715554659636351994856331242133),
    Dup211(.00041508840782129715979522657645241),
    Dup211(.00250499012224768278660807899148718),
    Dup211(.00026299196277102376543518488345529),
    Dup211(.00523794881864567374677735091822929),
    Dup1111(.00095305173455027987048815049539869),
    Dup1111(.00044240794980280443175959008111272),
    Dup1111(.00175617900842293827016067596499792),
    Dup1111(.00243426688175015351865672660825327),
    Dup1111(.00393651196593819293400605150166542),
    Dup1111(.00319979126910645663073621997553739),
    Dup1111(.00379761031215874816994913442636149),
    Dup1111(.00149593856263098105511616834730418),
    Dup1111(.00170399618122472474047327649205935),
    Dup1111(.00362877511769905893456278951846466)
};
static FLOAT QUAD_3D_P18_pts[Length(QUAD_3D_P18_wts) * 4] = {
    Perm31(.20637218186812094831874994465860079),
    Perm31(.16253879451764062506834535785204538),
    Perm31(.31162667282556428912198240292306574),
    Perm31(.33072791608903129844033810913174527),
    Perm31(.03374408201299505718840639177648074),
    Perm31(.06568138278425954114940798552336974),
    Perm31(.01169072420259710552476429728400502),
    Perm22(.30517291412147938784702996343534374),
    Perm22(.24981716534153994708400572938943935),
    Perm22(.01336652291605620228062484485653133),
    Perm22(.25034234357588552255727548609692542),
    Perm22(.33245177225428393514094828962254825),
    Perm22(.33289359747054658799564663094712728),
    Perm22(.10538899829412932124089743642335363),
    Perm22(.04317721941366494186982910130815837),
    Perm211(.03310306761504428482935143338531439,.13527540213032008696909436342150919),
    Perm211(.19461857844676746862218241517897150,.00117187904704725294876226187321645),
    Perm211(.01321252126131118174856539794164524,.32789600981495032580983907620683060),
    Perm211(.12293207217705982973054677254397158,.02028399843152169835305329015438707),
    Perm211(.06199506095168379549434485292454695,.34989612196236531140882046780985109),
    Perm211(.08407187546991697844734445141488466,.16668307969529238098765523293208347),
    Perm211(.00786704887445389128372700669340647,.18591795912287515392973915203683775),
    Perm211(.04217582498871236016971219632748999,.24827074115031171594992829323368830),
    Perm211(.00868349187213883954904996522992908,.06698102226768764333745716748307399),
    Perm211(.11111853675762082397698238363868776,.29184170779811623486181017809182540),
    Perm1111(.00368546384560602231072732004278589,.06377078964518405834434983865340637,.21619828180153020323211376960477319),
    Perm1111(.09147563979493069900846946773224557,.00402409810322379786328969726798001,.04866034767929566089881579671571736),
    Perm1111(.13265637401840363707743066731939639,.41687745973852601234526723695730683,.02814320586294361943768548321489690),
    Perm1111(.44391986692788096226284828151223304,.24643302248016774539112971890988080,.02919443405619611208406286467450974),
    Perm1111(.23954508858951902643817205103405676,.12712074880700960661285656191692246,.24575744971175612092625433280343212),
    Perm1111(.16571308871687793514357066875308956,.21370490618618504771762492996867050,.07023964653694080294694717571506430),
    Perm1111(.17887766860263659085416261279999145,.32903530148779738446718897618493448,.06661063766146717863106835995631984),
    Perm1111(.33401761167261064600434070818132600,.00495031595694936929642574814441724,.18879993728241271548972551550155508),
    Perm1111(.54587730091263853880335928447213718,.00784628836168125343141768324038601,.07104964990519175274939928927478563),
    Perm1111(.02510439859007851265720415998138543,.12935575346620128932243421367170461,.25298824003743208130810905513607930)
};
static QUAD QUAD_3D_P18_ = {
    "3D P18",			/* name */
    3,				/* dim */
    18,				/* order */
    Length(QUAD_3D_P18_wts),	/* npoints = 436 */
    QUAD_3D_P18_pts,		/* points */
    QUAD_3D_P18_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P18 (&QUAD_3D_P18_)

static FLOAT QUAD_3D_P19_wts[] = {
    Dup4(.00947742496442155508008294740829810),
    Dup31(.00230965204657903163237137292244626),
    Dup31(.00409149276224073342013747716996419),
    Dup31(.00117365466744828713444585940431339),
    Dup22(.00579775930281866761588403679414374),
    Dup211(.00202899263910692140662266087981858),
    Dup211(.00020058584851064325045002199245815),
    Dup211(.00290805997245689848626775197241993),
    Dup211(.00253207846328713423882002523367059),
    Dup211(.00073436957363161391760254060591427),
    Dup211(.00107618357453939976048047460390580),
    Dup211(.00198641567713146362216974323643499),
    Dup211(.00504631736429394686887589732337180),
    Dup211(.00269228246053105267720003799089884),
    Dup211(.00133063628850380104094097889836554),
    Dup211(.00178292890085285491443863898758591),
    Dup211(.00012630158261844536917238658174156),
    Dup211(.00324426094381917293591387861667230),
    Dup1111(.00104849818571252428946726948641068),
    Dup1111(.00360574074573460450279363329809823),
    Dup1111(.00256155840786984467591166461715481),
    Dup1111(.00149891846783441627334563730166632),
    Dup1111(.00181432457232748321803780083936445),
    Dup1111(.00288393807399617041467050243561064),
    Dup1111(.00319141130522126073068820516876795),
    Dup1111(.00039552823369867568024057454067835),
    Dup1111(.00164221123191576201087252886440027),
    Dup1111(.00046409208974596886481088101654514),
    Dup1111(.00121086533999402766637991850011750),
    Dup1111(.00365328301727806526371302465646532),
    Dup1111(.00174479123876261510112392388975554)
};
static FLOAT QUAD_3D_P19_pts[Length(QUAD_3D_P19_wts) * 4] = {
    Perm4(.25000000000000000000000000000000000),
    Perm31(.09623346794170115682843661810745564),
    Perm31(.28407109711855550694760238206329715),
    Perm31(.04201218049762310023294342381067319),
    Perm22(.12939250121795255262407399777726367),
    Perm211(.05339312125330306082662734975025929,.76796999473938670425874024338800455),
    Perm211(.00525055390691960340931789274984064,.16603392532052993697544499131221726),
    Perm211(.21289933236946590293254879214565083,.10340459950933276792921112697675824),
    Perm211(.40341353259772296356533702716263227,.13333563464320216092315671202191507),
    Perm211(.01188811930811271581673901297044056,.55323796780708960811813085049408284),
    Perm211(.08903116551206627518388874619843094,.80806951519091020624013971788185101),
    Perm211(.05151678695899160110499245072631945,.48732803652949014505867532769976467),
    Perm211(.11799928522976708702060877252751872,.24661499436440831090169133762930345),
    Perm211(.04608512334928590257704383565231945,.27814143188561275980758733246497043),
    Perm211(.14101867080978981796248254978518357,.00817464994838945075466265008535057),
    Perm211(.14110344086992665101709129629216790,.58558687675989695108610852319349722),
    Perm211(.00791186220482110832109344071689470,.03035883809061935055253591299033074),
    Perm211(.17610121147031741683183590818996742,.24612395878168493709871863788383733),
    Perm1111(.04531137441520980265340890372498654,.76941240411498146873609511929554205,.01162671237541302911562892975975269),
    Perm1111(.19024697703095114520826246601395148,.11399073433897683731317897877451058,.04902896398807803213985295513489661),
    Perm1111(.20258821073146207966536039150941453,.50452241971895422861276766239189983,.05200356315054190488715867196383142),
    Perm1111(.06280459865457698742893580593204246,.38993421379383935685284236089267603,.00965102192701457104655349894995258),
    Perm1111(.16890346110683013920222245742843094,.01025101977116908429012454841152492,.25422603378974590295703465667087002),
    Perm1111(.12828022988265455660846166936172150,.37147093146218235254643496221860588,.28262413489405257282007849851392446),
    Perm1111(.37531643022483341407725715439433305,.23237382312598924059318143933753765,.05648574604597608098186328999474539),
    Perm1111(.08176634693298535065683591581670699,.02823323910477210279895385815051264,.88403219212764701562003110579772895),
    Perm1111(.37272150088782103974796125070359468,.46913734429268586725215706013826440,.01052014400647360986109980510489185),
    Perm1111(.28810770126174551901021064902969459,.00624115043425393373538120988958117,.02040787180394685833335361621209153),
    Perm1111(.00848367703048867278258339437197483,.25485710093645495083578464316883060,.08369886684600136902880385112335355),
    Perm1111(.11931280362120332486142610418974982,.50812259065716173048760089369471029,.05013138003585081057894901608692511),
    Perm1111(.41983692014174260599999844401142465,.01094996106379020782992576987763220,.31550288568364136415900674243531029)
};
static QUAD QUAD_3D_P19_ = {
    "3D P19",			/* name */
    3,				/* dim */
    19,				/* order */
    Length(QUAD_3D_P19_wts),	/* npoints = 487 */
    QUAD_3D_P19_pts,		/* points */
    QUAD_3D_P19_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P19 (&QUAD_3D_P19_)

static FLOAT QUAD_3D_P20_wts[] = {
    Dup31(.00541845479008464844266042950338791),
    Dup31(.00382089798824862717803157892822955),
    Dup31(.00405745815233404841102859722892786),
    Dup31(.00414767029775032534107585928601921),
    Dup31(.00528956660993436102816644500411132),
    Dup31(.00097204181986235321024077863040270),
    Dup22(.00298817613678045206304827900197170),
    Dup22(.00706174692352836166081435748925490),
    Dup211(.00113801416486596895314666302511097),
    Dup211(.00032843280894395849755448705673389),
    Dup211(.00451730507453316513478688839078141),
    Dup211(.00274395709813969322955101996756146),
    Dup211(.00053451040298663535531793716083169),
    Dup211(.00085276027733658347807799443155017),
    Dup211(.00160867332095061101842094724535529),
    Dup211(.00216402178962303418274829778319015),
    Dup211(.00129896455199082090427866338260162),
    Dup211(.00075402210849808482092436291249904),
    Dup211(.00393639217719707601633204110760105),
    Dup211(.00008260437254311267094071848124006),
    Dup211(.00220259358126582095432288848211762),
    Dup1111(.00114291228831241623474370378864408),
    Dup1111(.00080373411798849844580652034154695),
    Dup1111(.00064410550856333934513745910752036),
    Dup1111(.00228480306156802812049971515659450),
    Dup1111(.00176821517340358779671325581922173),
    Dup1111(.00136409311660403457082174629799031),
    Dup1111(.00140951302024202324345386525099322),
    Dup1111(.00535219617282092571003475179474768),
    Dup1111(.00235725175379895578017599665362554),
    Dup1111(.00023355002815190851186076876557116),
    Dup1111(.00082991911104483886886209062815467),
    Dup1111(.00034803272756201589332552610373593),
    Dup1111(.00108130649745930925610128237926640),
    Dup1111(.00336359299264356607379658271245219),
    Dup1111(.00113881952395300550763233993336166)
};
static FLOAT QUAD_3D_P20_pts[Length(QUAD_3D_P20_wts) * 4] = {
    Perm31(.29677595969341314868427235778625470),
    Perm31(.12090479721121854148078230391603485),
    Perm31(.31779590718810443277953963729820270),
    Perm31(.20126557124147898430344311317642095),
    Perm31(.16788389692728846339259222826338419),
    Perm31(.03621493960968947309735459157157271),
    Perm22(.05260244961748377555865976442058052),
    Perm22(.30457855633130420953689618594802443),
    Perm211(.03228230549839515735049487170602264,.81815327336878022241263542264936301),
    Perm211(.00812651447051963846684892317335956,.16719639318282120252546756714801737),
    Perm211(.18514595229943469765208229721657251,.06611011876662430240253685200385615),
    Perm211(.41107753820177699615657859166025852,.12818318452527443048794127586757668),
    Perm211(.01005979740685445653213222827193388,.55663662483071551701753544086804232),
    Perm211(.08230161503723588086546160998275955,.82425158114285030704580541117516694),
    Perm211(.03801282860266466649609606564631546,.60729227143911592502315651109099416),
    Perm211(.08297816905794757843367594649759300,.19275912042141616461263249973186296),
    Perm211(.03232830149045374197744190875775188,.22908997931138216311903152374339998),
    Perm211(.14065219401777622478221224940740411,.00406245917858537144207040023902170),
    Perm211(.11397194391129145670046589640691138,.51686565726937732324859493808006746),
    Perm211(.00745357137717489582861251414256797,.02517856316811187446121630478028910),
    Perm211(.11101712673026890919102311376811169,.39070706747913118351952602085373379),
    Perm1111(.05313810503913766898066271788410422,.53337671427373923387059460515514504,.00976849266758000907062423952540026),
    Perm1111(.09439207428728113481616095915241311,.09450517146275738278704148402108422,.76094809236243660895857862121556936),
    Perm1111(.05505445164272957561995811570406455,.76539556922700233779295319519889284,.00566074794761922284069332309490366),
    Perm1111(.17986373012343050572524767570084283,.09751720382220438284828296737143364,.03466187077541209079689109276935945),
    Perm1111(.21219205477521472828171301626865181,.40950365861709435790152951408587814,.04613078410418590185511868456570520),
    Perm1111(.12901615123519603449412839506351029,.47655572075000693498967614515309517,.00995603037378283621709559105258562),
    Perm1111(.16148732230661144632503933383552419,.01376084748677020270201676986113829,.22648131940555421980131365241676330),
    Perm1111(.10592830789398597475795402871788125,.41435007414024702454226148321091634,.19442024171940289325016704594696281),
    Perm1111(.20462293284568089824434005206556529,.28640831552549532863272158634366950,.03607794123452725499958632945136388),
    Perm1111(.07441796869877018298864166580428725,.02361583233015298006806139657497592,.89952402926324102160060975003150478),
    Perm1111(.29383523596867846114665738009636032,.50787457592864031878177340661973596,.00437977236379033181967350653685296),
    Perm1111(.28990049199313030326043570519138733,.00238861494051180749685397733700936,.02095834844884251581596274617519235),
    Perm1111(.00692039552760895284534243255473138,.27800902334886384816306368910153963,.08666224435610116666891461610758740),
    Perm1111(.10531910689721521701010637843977199,.54311305749058153814413665551492196,.04625008859127536400281615129260684),
    Perm1111(.33876157002929620384534905084048037,.00879232521925877358609174528034727,.40025053885716892834357257404592430)
};
static QUAD QUAD_3D_P20_ = {
    "3D P20",			/* name */
    3,				/* dim */
    20,				/* order */
    Length(QUAD_3D_P20_wts),	/* npoints = 552 */
    QUAD_3D_P20_pts,		/* points */
    QUAD_3D_P20_wts,		/* weights */
    -1				/* id */
};
#define QUAD_3D_P20 (&QUAD_3D_P20_)

/*------------------------- End of quadrature rules ----------------------*/

typedef QUAD *(*QGEN_FUNC) (int dim, int order);

void
phgQuadFree(QUAD **quad)
{
    if ((*quad) == NULL)
	return;
    phgFree((*quad)->name);
    phgFree((*quad)->points);
    phgFree((*quad)->weights);
    phgFree((*quad));

    *quad = NULL;
}

static void
init_table(int n0, QUAD **table0, int *n, QUAD ***table)
{
#if USE_OMP
#pragma omp critical (init_table)
#endif	/* USE_OMP */
    if (*table == NULL) {
	void *p = phgAlloc(n0 * sizeof(*table0));
	/* table0[i] := table0[min_j{j>=i && table[j] != NULL}] */
	int i, j;
	for (i = 0; i < n0 - 1; i++)
	    for (j = i; j < n0 && (table0[i] = table0[j]) == NULL; j++);
	memcpy(p, table0, n0 * sizeof(*table0));
	*n = n0;
	*table = p;
    }
}

#define nquad0	(sizeof(table0) / sizeof(*table0))
#define GetQuadrature(qgen_func) {					\
    static int nquad;							\
    static QUAD **table = NULL;						\
    static BOOLEAN warned = FALSE;					\
									\
    if (order < 0) {							\
	/* free dynamically generated quadrature rules */		\
	CheckThread							\
	if (table != NULL) {						\
	    int i, j;							\
	    for (i = nquad0; i < nquad; i++) {				\
		for (j = i + 1; j < nquad && table[j] == table[i]; j++)	\
		    table[j] = NULL;					\
		phgQuadFree(&table[i]);					\
	    }								\
	    phgFree(table);						\
	    table = NULL;						\
	}								\
	return NULL;							\
    }									\
    if (table == NULL) {						\
	/* initialization */						\
	init_table(nquad0, table0, &nquad, &table);			\
    }									\
    if (order >= nquad) {						\
	if (/*qgen_func == NULL*/FALSE) {				\
	    if (!warned && phgRank == 0) {				\
		phgWarning("%dD quad rule of order %d unavailable.\n",	\
				table[0]->dim, order);			\
		warned = TRUE;						\
	    }								\
	    order = nquad - 1;						\
	}								\
	else {								\
	    if (qgen_func == phgQuadTensorProductRule)			\
		order = (order / 2) * 2	+ 1;				\
	    CheckThread							\
	    table = phgRealloc_(table, (order + 1) * sizeof(*table),	\
					nquad * sizeof(*table));	\
	    memset(table + nquad, 0, (order - nquad + 1) * sizeof(*table)); \
	    nquad = order + 1;						\
	}								\
    }									\
    if (table[order] == NULL) {						\
	if (FALSE && table[0]->dim > 1 && phgRank == 0) {		\
	    phgWarning("using %dD-%d tensor product quadrature rule.\n",\
			table[0]->dim, order);				\
	}								\
	CheckThread							\
	table[order] = (qgen_func)(table[0]->dim, order);		\
	if (order > nquad0 && qgen_func == phgQuadTensorProductRule)	\
	    table[order - 1] = table[order];				\
    }									\
    return table[order];						\
}

QUAD *
phgQuadGetQuad1D(int order)
{
    /* Table of static 1D quadrature rules */
    static QUAD *table0[] = {NULL,
	QUAD_1D_P1,  NULL,	QUAD_1D_P3,  NULL,
	QUAD_1D_P5,  NULL,	QUAD_1D_P7,  NULL,
	QUAD_1D_P9,  NULL,	QUAD_1D_P11, NULL,
	QUAD_1D_P13, NULL,	QUAD_1D_P15, NULL,
	QUAD_1D_P17, NULL,	QUAD_1D_P19, NULL,
	QUAD_1D_P21, NULL
    };
    GetQuadrature(phgQuadTensorProductRule)
}

QUAD *
phgQuadGetQuad2D(int order)
{
    /* Table of static 2D quadrature rules */
    static QUAD *table0[] = {NULL,
	QUAD_2D_P1,	QUAD_2D_P2,	QUAD_2D_P3,	QUAD_2D_P4,
	QUAD_2D_P5,	QUAD_2D_P6,	QUAD_2D_P7,	QUAD_2D_P8,
	QUAD_2D_P9,	QUAD_2D_P10,	QUAD_2D_P11,	QUAD_2D_P12,
	QUAD_2D_P13,	QUAD_2D_P14,	QUAD_2D_P15,	QUAD_2D_P16,
	QUAD_2D_P17,	QUAD_2D_P18,	QUAD_2D_P19,	QUAD_2D_P20,
	QUAD_2D_P21,	QUAD_2D_P22,	QUAD_2D_P23,	QUAD_2D_P24,
	QUAD_2D_P25,	QUAD_2D_P26,	QUAD_2D_P27,	QUAD_2D_P28,
	QUAD_2D_P29
    };
    GetQuadrature(phgQuadTensorProductRule)
}

QUAD *
phgQuadGetQuad3D(int order)
{
    /* Table of static 3D quadrature (cubature) rules */
    static QUAD *table0[] = {NULL,
	QUAD_3D_P1,	QUAD_3D_P2,	QUAD_3D_P3,	QUAD_3D_P4,
	QUAD_3D_P5,	QUAD_3D_P6,	QUAD_3D_P7,	QUAD_3D_P8,
	QUAD_3D_P9,	QUAD_3D_P10,	QUAD_3D_P11,	QUAD_3D_P12,
	QUAD_3D_P13,	QUAD_3D_P14,	QUAD_3D_P15,	QUAD_3D_P16,
	QUAD_3D_P17,	QUAD_3D_P18,	QUAD_3D_P19,	QUAD_3D_P20
    };
    GetQuadrature(phgQuadTensorProductRule)
}

FLOAT *
phgQuadGetRule_(GRID *g, ELEMENT *e, int which, int order)
/* returns a rule of order "order" for integration in the element "e", or
 * one of its face or edge. "which" specifies which part of the element is 
 * the integration domain:
 * 		which = 3 * no + (dim - 1)
 * where "no" is the face ("dim" == 2) or edge ("dim" == 1) number. */
{
    QUAD *quad;
    int dim = which % 3 + 1, no = which / 3;
    FLOAT *pts, lambda[Dim + 1], *p, *q, scale;
    int i, v0, v1, v2;

    if (order <= 0)
	order = 1;
    quad = (dim == 3 ? phgQuadGetQuad3D :
	   (dim == 2 ? phgQuadGetQuad2D : phgQuadGetQuad1D))(order);
    p = pts = phgAlloc(quad->npoints * Dim * sizeof(*pts));
    q = quad->points;
    if (dim == 3) {
	for (i = 0; i < quad->npoints; i++, p += Dim, q += 4)
	    phgGeomLambda2XYZ(g, e, q, p + 0, p + 1, p + 2);
	scale = phgGeomGetVolume(g, e);
    }
    else if (dim == 2) {
	assert(no >= 0 && no < NFace);
	GetFaceVertices(e, no, v0, v1, v2, i);
	lambda[no] = 0.0;
	for (i = 0; i < quad->npoints; i++, p += Dim, q += 3) {
	    lambda[v0] = q[0];
	    lambda[v1] = q[1];
	    lambda[v2] = q[2];
	    phgGeomLambda2XYZ(g, e, lambda, p + 0, p + 1, p + 2);
	}
	scale = phgGeomGetFaceArea(g, e, no);
    }
    else {
	COORD *c0, *c1;
	FLOAT dx, dy, dz;
	assert(no >= 0 && no < NEdge);
	GetEdgeVertices(e, no, v0, v1);
	lambda[0] = lambda[1] = lambda[2] = lambda[3] = 0.0;
	for (i = 0; i < quad->npoints; i++, p += Dim, q += 2) {
	    lambda[v0] = q[0];
	    lambda[v1] = q[1];
	    phgGeomLambda2XYZ(g, e, lambda, p + 0, p + 1, p + 2);
	}
	c0 = g->verts + e->verts[v0];
	c1 = g->verts + e->verts[v1];
	dx = (*c1)[0] - (*c0)[0];
	dy = (*c1)[1] - (*c0)[1];
	dz = (*c1)[2] - (*c0)[2];
	scale = Sqrt(dx * dx + dy + dy + dz * dz);
    }
    q = phgQuadInterfaceRuleCreate(Dim, quad->npoints, pts, Dim,
					quad->weights, 1, scale, NULL, 0);
    phgFree(pts);

    return q;
}

/*---------------- functions managing caches and quad_list ------------------*/

static QUAD **quad_list = NULL;
static size_t quad_list_count = 0, quad_list_allocated = 0;

#if 0
static inline QUAD_CACHE *
#else
static QUAD_CACHE *
#endif
get_cache(void **clist_ptr, QUAD *quad)
/* returns the cache in '**clist_ptr' matching 'quad' */
{
    QUAD_CACHE_LIST *clist;
    QUAD_CACHE *cache;

    if (quad->id < 0) {
#if USE_OMP
#pragma omp critical (get_cache1)
      if (quad->id < 0) {
#endif	/* USE_OMP */
	/* assign an id to quad */
	if (quad_list_count >= quad_list_allocated) {
	    quad_list = phgRealloc_(quad_list,
				(quad_list_allocated + 8) * sizeof(*quad_list),
				quad_list_allocated * sizeof(*quad_list));
#if USE_OMP
#pragma omp atomic
#endif	/* USE_OMP */
	    quad_list_allocated += 8;
	}
	quad_list[quad_list_count] = quad;
#if USE_OMP
#pragma omp atomic
#endif	/* USE_OMP */
	quad_list_count++;
	quad->id = quad_list_count - 1;
#if USE_OMP
      }
#endif	/* USE_OMP */
    }

    assert(quad->id < quad_list_count && quad_list[quad->id] == quad);

    if ((clist = *clist_ptr) == NULL) {
#if USE_OMP
#pragma omp critical (get_cache2)
      if ((clist = *clist_ptr) == NULL)
#endif	/* USE_OMP */
	*clist_ptr = clist = phgCalloc(phgMaxThreads, sizeof(*clist));
    }
    clist += phgThreadId;

    if (clist->n <= quad->id) {
	/* expand the list to quad->id + 1 entries */
	clist->caches = phgRealloc_(clist->caches,
				   (quad->id + 1) * sizeof(*cache),
				   clist->n * sizeof(*cache));
	while (clist->n <= quad->id)
	    clist->caches[clist->n++] = NULL;
    }

    if ((cache = clist->caches[quad->id]) == NULL) {
	cache = clist->caches[quad->id] = phgAlloc(sizeof(*cache));
	cache->e = cache->e1 = NULL;
	cache->face = cache->face1 = -1;
	cache->data = cache->data1 = NULL;
    }

    return cache;
}

void
phgQuadReset(void)
{
    int i;

    /* Free quad_list entries */
    for (i = 0; i < quad_list_count; i++) {
	quad_list[i]->id = -1;
    }
    phgFree(quad_list);
    quad_list = NULL;
    quad_list_count = quad_list_allocated = 0;

    /* The calls below will free dynamically generated quadrature rules */
    phgQuadGetQuad1D(-1);
    phgQuadGetQuad2D(-1);
    phgQuadGetQuad3D(-1);
}

void
phgQuadClearDofCache(void **clist0, QUAD *quad, BOOLEAN final)
/* clear one or all cached DOF (basis) values in clist */
{
    QUAD_CACHE_LIST **clist, *pl;
    int i, n;

    if (quad == NULL) {
#if USE_OMP
	assert(phgThreadId == 0);
#pragma omp parallel for schedule(static)
	for (i = 0; i < phgMaxThreads; i++)
#endif	/* USE_OMP */
	phgQuadGetFuncValues(NULL, NULL, 0, NULL, NULL);
    }

    if (*(clist = (QUAD_CACHE_LIST **)clist0) == NULL ||
	(quad != NULL && quad->id == -1))
	return;

#if USE_OMP
    for (pl = *clist; pl < *clist + phgMaxThreads; pl++) {
#else	/* USE_OMP */
    pl = *clist;
#endif	/* USE_OMP */

    /* clear cache for 'quad' */
    if (quad != NULL) {
	i = quad->id;
	assert(i < quad_list_count && quad_list[i] == quad);
	n = i + 1;
    }
    else {
	i = 0;
	n = pl->n;
    }

    for (; i < n; i++) {
	if (pl->caches[i] == NULL)
	    continue;
	pl->caches[i]->e = pl->caches[i]->e1 = NULL;
	pl->caches[i]->face = pl->caches[i]->face1 = -1;
	phgFree(pl->caches[i]->data);
	phgFree(pl->caches[i]->data1);
	pl->caches[i]->data = pl->caches[i]->data1 = NULL;
	if (final) {
	    phgFree(pl->caches[i]);
	    pl->caches[i] = NULL;
	}
    }

    if (quad == NULL && final)
	phgFree(pl->caches);

#if USE_OMP
    }
#endif	/* USE_OMP */

    if (quad == NULL && final) {
	phgFree(*clist);
	*clist = NULL;
    }
}

/*-------------------------- 3D caching utilities ---------------------------*/

const FLOAT *
phgQuadGetFuncValues(GRID *g, ELEMENT *e, int dim, DOF_USER_FUNC userfunc,
		     QUAD *quad)
/* cache and returns the function values of 'userfunc' at quadrature points of
 * 'quad'. if quad == NULL then clear cached values */
{
    static FLOAT *funcvalues = NULL;
    static QUAD *cached_quad = NULL;
    static ELEMENT *cached_e = NULL;
    static INT cached_serial_no = -1;
    static DOF_USER_FUNC cached_userfunc = NULL;
#if USE_OMP
# pragma omp threadprivate(funcvalues, cached_quad, cached_e, cached_serial_no, cached_userfunc)
#endif  /* USE_OMP */

    int i;
    FLOAT *v;
    const FLOAT *lambda;
    FLOAT x, y, z;

    if (quad == NULL) {
	/* clear cache */
	phgFree(funcvalues);
	funcvalues = NULL;
	cached_quad = NULL;
	cached_e = NULL;
	cached_serial_no = -1;
	cached_userfunc = NULL;
	return NULL;
    }

    assert(quad->dim == Dim);

    if (cached_quad != quad || cached_e != e || cached_userfunc != userfunc
	|| cached_serial_no != g->serial_no) {
	cached_quad = quad;
	cached_e = e;
	cached_serial_no = g->serial_no;
	cached_userfunc = userfunc;

	/* compute function values */
	lambda = quad->points;
	phgFree(funcvalues);
	funcvalues = phgAlloc(dim * quad->npoints * sizeof(*funcvalues));
	for (i = 0, v = funcvalues; i < quad->npoints; i++, v += dim) {
	    phgGeomLambda2XYZ(g, e, lambda, &x, &y, &z);
	    userfunc(x, y, z, v);
	    lambda += Dim + 1;
	}
    }

    return funcvalues;
}

const FLOAT *
phgQuadGetBasisValues(ELEMENT *e, DOF *u, int n, QUAD *quad)
/* returns the address of an array containing the values of the n-th
 * basis function at the quadrature points of 'quad'. The values are
 * returned in the order FLOAT[quad->npoints][type->dim]
 *
 * Note: in the internal buffer the values are stored as:
 *	FLOAT[nbas][quad->npoints][type->dim]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    const FLOAT *v, *lambda;
    FLOAT *bas;
    int i, j, nbas;

    assert(quad->dim == Dim);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&type->cache_basfunc, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_basfunc, quad);
    }

    if (cache->data != NULL &&
	((!DofIsHP(u) && type->invariant) || cache->e == e))
	return cache->data + n * quad->npoints * type->dim;

    if (type->BasFuncs == NULL)
	phgError(1, "no basis function for DOF \"%s\"!\n", u->name);

    cache->e = e;
    phgFree(cache->data);
    bas = cache->data =
		phgAlloc(nbas * quad->npoints * type->dim * sizeof(*bas));
    lambda = quad->points;
    for (i = 0; i < quad->npoints; i++) {
	v = type->BasFuncs(u, e, 0, -1, lambda);
	bas = cache->data + i * type->dim;
	for (j = 0; j < nbas; j++) {
	    memcpy(bas, v, type->dim * sizeof(*v));
	    v += type->dim;
	    bas += quad->npoints * type->dim;
	}
	lambda += Dim + 1;
    }

    return cache->data + n * quad->npoints * type->dim;
}

static inline const FLOAT *
get_grad_lambda(ELEMENT *e, DOF *u, int n, QUAD *quad)
/* returns the address of an array containing the values of the lambda
 * gradient of the n-th basis function at the quadrature points of 'quad'.
 * The values are returned as:
 *	FLOAT[quad->npoints][type->dim][Dim + 1]
 *
 * Note: in the internal buffer the values are stored as:
 *	FLOAT[nbas][quad->npoints][type->dim][Dim + 1]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    const FLOAT *v;
    FLOAT *grad, *lambda;
    int i, j, nbas, ngrad, nvalues;

    assert(quad->dim == Dim);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&u->type->cache_basgrad, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_basgrad, quad);
    }
    ngrad = nbas * type->dim;

    if (cache->data != NULL &&
	((!DofIsHP(u) && type->invariant) || cache->e == e))
	return cache->data + n * quad->npoints * type->dim * (Dim + 1);

    if (type->BasGrads == NULL)
	phgError(1, "no gradient function for DOF \"%s\"!\n", u->name);

    cache->e = e;
    phgFree(cache->data);
    cache->data = phgAlloc(quad->npoints * ngrad * (Dim + 1) * sizeof(*grad));
    lambda = quad->points;
    nvalues = (Dim + 1) * type->dim;
    for (i = 0; i < quad->npoints; i++) {
	v = type->BasGrads(u, e, 0, -1, lambda);
	grad = cache->data + i * nvalues;
	for (j = 0; j < nbas; j++) {
	    memcpy(grad, v, nvalues * sizeof(*v));
	    v += nvalues;
	    grad += quad->npoints * nvalues;
	}
	lambda += Dim + 1;
    }

    return cache->data + n * quad->npoints * type->dim * (Dim + 1);
}

const FLOAT *
phgQuadGetBasisGradient(ELEMENT *e, DOF *u, int n, QUAD *quad)
/* returns the xyz gradients of the n-th basis function on element e
 * The values are returned as
 *	FLOAT[quad->npoints][type->dim][Dim]
 *
 * Note: in the internal buffer the values are stored as:
 *	FLOAT[nbas][quad->npoints][type->dim][Dim]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    int i, j, k;
    int nbas, nvalues, npoints = quad->npoints;
    FLOAT *data, *p;
    const FLOAT *J, *J1, *G;

    assert(quad->dim == Dim);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&u->type->cache_gradient, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_gradient, quad);
    }
    nvalues = Dim * type->dim;

    if (cache->data != NULL && cache->e == e)
	return cache->data + n * npoints * nvalues;

    cache->e = e;
    phgFree(cache->data);
    data = cache->data = phgAlloc(nbas * npoints * nvalues * sizeof(*data));

    J = phgGeomGetJacobian(u->g, e);
    for (k = 0; k < nbas; k++, data += npoints * nvalues) {
	if (k < NVert && !DofIsHP(u) && type->order >= 0 && type->order < 16
		&& type == DOF_Pn[type->order]) {
	    /* faster code for Pn basis functions on the vertices */
	    p = data;
	    if (type == DOF_P0) {
		npoints *= Dim;
		for (i = 0; i < npoints; i++) {
		    *(p++) = 0.;
		}
	    }
	    else if (type == DOF_P1) {
		/* D\phi / D\lambda is the unit matrix */
		J1 = J + k * (Dim + 1);
		for (i = 0; i < npoints; i++) {
		    memcpy(p, J1, Dim * sizeof(*data));
		    p += Dim;
		}
	    }
	    else {
		/* the first NVert rows of D\phi / D\lambda are diagonal */
		G = get_grad_lambda(e, u, k, quad) + k;
		J1 = J + k * (Dim + 1);
		for (i = 0; i < npoints; i++) {
		    FLOAT d = *G;
		    *(p++) = d * J1[0];
		    *(p++) = d * J1[1];
		    *(p++) = d * J1[2];
		    G += Dim + 1;
		}
	    }
	}
	else {
	    G = get_grad_lambda(e, u, k, quad);
	    /* compute data[npoints][Dim] = G[npoints][Dim+1] * J[Dim+1][Dim] */
#if 0
	    if (npoints > 4) {
		static FLOAT a = 1.0, b = 0.0;
		int k = (Dim + 1) * type->dim, j = Dim * type->dim;
		assert(sizeof(BLAS_INT) == sizeof(int));
		F77_FUNC(dgemm,DGEMM)("t", "t", &npoints, &j, &k, &a, G, &k,
				J, &k, &b, data, &k);
		return data;
	    }
#else
	    p = data;
	    for (i = 0; i < npoints; i++) {
		for (j = 0; j < type->dim; j++) {
		    *(p++) = G[0] * J[0 * (Dim + 1) + 0] +
			G[1] * J[1 * (Dim + 1) + 0] +
			G[2] * J[2 * (Dim + 1) + 0] +
			G[3] * J[3 * (Dim + 1) + 0];
		    *(p++) = G[0] * J[0 * (Dim + 1) + 1] +
			G[1] * J[1 * (Dim + 1) + 1] +
			G[2] * J[2 * (Dim + 1) + 1] +
			G[3] * J[3 * (Dim + 1) + 1];
		    *(p++) = G[0] * J[0 * (Dim + 1) + 2] +
			G[1] * J[1 * (Dim + 1) + 2] +
			G[2] * J[2 * (Dim + 1) + 2] +
			G[3] * J[3 * (Dim + 1) + 2];
		    G += Dim + 1;
		}
	    }
#endif
	}
    }

    return cache->data + n * npoints * nvalues;
}

const FLOAT *
phgQuadGetBasisCurl(ELEMENT *e, DOF *u, int n, QUAD *quad)
/* returns the curl of the n-th basis functions at quadrature points 
 * the values are cached as FLOAT[nbas][quad->npoints][type->dim]
 * The requested values are returned as
 *	FLOAT[quad->npoints][type->dim]
 * (type->dim % Dim == 0)
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    FLOAT *curl;
    int i, j, nbas;
    int I, J;

    assert(quad->dim == Dim);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&u->type->cache_curl, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_curl, quad);
    }

    if (type->dim % Dim != 0)
	phgError(1, "%s:%d, cannot compute curl of \"%s\" whose dimension is "
		 "not multiple of %d\n", u->name, Dim);

    if (cache->data != NULL && cache->e == e)
	return cache->data + n * quad->npoints * type->dim;

    cache->e = e;
    phgFree(cache->data);
    cache->data =
	phgAlloc(nbas * quad->npoints * type->dim * sizeof(*curl));

    if (!DofIsHP(u) && type == DOF_ND1) {
	/* faster code (?) for Nedelec-1 element */
	FLOAT (*nabla)[Dim + 1] = (void *)(phgGeomGetJacobian(u->g, e));
	for (i = 0; i < quad->npoints; i++) {
	    curl = cache->data + i * type->dim;
	    for (j = 0; j < nbas; j++) {
		GetEdgeVertices(e, j, I, J);
		curl[0] =
		    (nabla[I][1] * nabla[J][2] -
		     nabla[I][2] * nabla[J][1]) * 2.;
		curl[1] =
		    (nabla[I][2] * nabla[J][0] -
		     nabla[I][0] * nabla[J][2]) * 2.;
		curl[2] =
		    (nabla[I][0] * nabla[J][1] -
		     nabla[I][1] * nabla[J][0]) * 2.;
		curl += quad->npoints * type->dim;
	    }
	}
    }
    else {
	FLOAT (*g)[Dim];
	for (i = 0; i < quad->npoints; i++) {
	    curl = cache->data + i * type->dim;
	    for (j = 0; j < nbas; j++) {
		g = (void *)(phgQuadGetBasisGradient(e, u, j, quad) +
			     i * type->dim * Dim);
		curl[0] = g[2][1] - g[1][2];
		curl[1] = g[0][2] - g[2][0];
		curl[2] = g[1][0] - g[0][1];
		curl += quad->npoints * type->dim;
	    }
	}
    }

    return cache->data + n * quad->npoints * type->dim;
}

const FLOAT *
phgQuadGetBasisHessian(ELEMENT *e, DOF *u, int n, QUAD *quad)
/* returns (the lower triangular part of) the Hessian matrix of the n-th basis
 * functions at quadrature points the values are cached as
 * 	FLOAT[nbas][quad->npoints][type->dim][Dim*(Dim+1)/2]
 * The requested values are returned as
 *	FLOAT[quad->npoints][type->dim][Dim*(Dim+1)/2]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    FLOAT *buffer;
    int i, j, nbas, N = Dim * (Dim + 1) / 2;

    assert(quad->dim == Dim);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&u->type->cache_hessian, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_hessian, quad);
    }

    N *= type->dim;
    if (cache->data != NULL && cache->e == e)
	return cache->data + n * quad->npoints * N;

    cache->e = e;
    phgFree(cache->data);
    cache->data =
	phgAlloc(nbas * quad->npoints * N * sizeof(*cache->data));

    buffer = phgAlloc(nbas * N * sizeof(*buffer));
    for (i = 0; i < quad->npoints; i++) {
	phgDofEvalBasisHessian(u, e, quad->points+i*(Dim+1), "Lower", buffer);
	for (j = 0; j < nbas; j++)
	    memcpy(cache->data + (i + j * quad->npoints) * N,
		   buffer + j * N, N * sizeof(*buffer));
    }
    phgFree(buffer);

    return cache->data + n * quad->npoints * N;
}

const FLOAT *
phgQuadGetDofValues(ELEMENT *e, DOF *u, QUAD *quad)
/* returns the address of an array containing the values of dof
 * at the quadrature points of 'quad', the values are stored in the order
 * FLOAT[quad->npoints][DofDim(u)].
 */
{
    QUAD_CACHE *cache;
    FLOAT *v;
    const FLOAT *bas, *lambda;
    int nvalues = DofDim(u);
    int i;

    assert(quad->dim == Dim);

    cache = get_cache(&u->cache_func, quad);
    if (cache->data != NULL && (u->invariant || cache->e == e))
	return cache->data;

    cache->e = e;
    phgFree(cache->data);
    v = cache->data = phgAlloc(quad->npoints * nvalues * sizeof(*v));
    /* Note: calling phgQuadGetBasisValues may further save recomputation
     * of basis functions if u->type->invariant == TRUE (or when computing
     * u dot u). By requesting values for basis function 0 we eventually
     * get the start address of values of all basis functions at the
     * quadrature points, stored as
     *          FLOAT[nbas][quad->npoints][type->dim]
     */
    if (!SpecialDofType(u->type) && !DofIsHP(u))
	bas = phgQuadGetBasisValues(e, u, 0, quad);
    else
	bas = NULL;
    lambda = quad->points;
    for (i = 0; i < quad->npoints; i++) {
	phgDofEval_(u, e, lambda, bas, quad->npoints * DofTypeDim(u), v, NULL);
	v += nvalues;
	if (bas != NULL)
	    bas += u->type->dim;
	lambda += Dim + 1;
    }
    return cache->data;
}

/*--------------------------- 2D cache functions ---------------------------*/

static inline void
update_face_cache(ELEMENT *e, int face, QUAD_CACHE *cache, FLOAT *data)
{
    phgFree(cache->data1);
    cache->data1 = NULL;
    cache->e1 = NULL;
    cache->face1 = -1;

    if (cache->data != NULL && cache->e != NULL &&
	cache->e->faces[(int)cache->face] == e->faces[face]) {
	/* cache->data contains data on the face for the peer element ==>
	 *	save data in (e1,face1,data1) */
	cache->e1 = e;
	cache->face1 = face;
	cache->data1 = data;
    }
    else {
	cache->e = e;
	cache->face = face;
	phgFree(cache->data);
	cache->data = data;
    }
}

const FLOAT *
phgQuadFaceGetBasisValues(ELEMENT *e, int face, DOF *u, int n, QUAD *quad)
/* returns the address of an array containing the values of the n-th
 * basis function at the quadrature points of 'quad'. The values are
 * returned in the order FLOAT[quad->npoints][type->dim]
 *
 * Note: in the internal buffer the values are stored as:
 *	FLOAT[nbas][quad->npoints][type->dim]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    const FLOAT *src, *p;
    FLOAT *dst, *data, lambda[Dim + 1];
    int i, j, nbas, v0, v1, v2;

    /* Note: we store data for both (cache->e,face) and (cache->e1,face1),
     * even if the set of basis functions in the two elements are the same.
     *
     * TODO:
     *    only store basis functions returned by phgDofGetBasesOnFace,
     *	  the other basis functions have zero trace on the face.
     */

    assert(quad->dim == Dim - 1);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&type->cache_basfunc, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_basfunc, quad);
    }

    if (type->BasFuncs == NULL)
	phgError(1, "no basis function for DOF \"%s\"!\n", u->name);

    if (cache->data != NULL && cache->e == e && cache->face == face)
	return cache->data + n * quad->npoints * type->dim;
    if (cache->data1 != NULL && cache->e1 == e && cache->face1 == face)
	return cache->data1 + n * quad->npoints * type->dim;

#if 0
    if (cache->data != NULL && !DofIsHP(u) && type->invariant) {
	/* TODO: find mapping (n,i) <=> (m,j) such that
	 *     \phi_n(p_i) in (e,face) == \phi_m(p_j) in (cache->e,cache->face)
	 */
    }
    else
#endif
  {
    dst = data = phgAlloc(nbas * quad->npoints * type->dim * sizeof(*dst));
    p = quad->points;
    GetFaceVertices(e, face, v0, v1, v2, i);
    lambda[face] = 0.;
    for (i = 0; i < quad->npoints; i++) {
	lambda[v0] = *(p++);
	lambda[v1] = *(p++);
	lambda[v2] = *(p++);
	src = type->BasFuncs(u, e, 0, -1, lambda);
	dst = data + i * type->dim;
	for (j = 0; j < nbas; j++) {
	    memcpy(dst, src, type->dim * sizeof(*src));
	    src += type->dim;
	    dst += quad->npoints * type->dim;
	}
    }
  }

    update_face_cache(e, face, cache, data);

    return data + n * quad->npoints * type->dim;
}

const FLOAT *
phgQuadFaceGetBasisGradient(ELEMENT *e, int face, DOF *u, int n, QUAD *quad)
/* returns the xyz gradients of the n-th basis function on element e
 * The values are returned as
 *	FLOAT[quad->npoints][type->dim][Dim]
 *
 * Note: in the internal buffer the values are stored as:
 *	FLOAT[nbas][quad->npoints][type->dim][Dim]
 */
{
    DOF_TYPE *type;
    QUAD_CACHE *cache;
    int i, j, k, v0, v1, v2;
    int nbas, nvalues, npoints = quad->npoints;
    FLOAT *data, *p, lambda[Dim + 1];
    const FLOAT *J, *G, *pt;

    assert(quad->dim == Dim - 1);
    assert(!SpecialDofType(u->type));

    if (!DofIsHP(u)) {
	type = u->type;
	nbas = type->nbas;
	cache = get_cache(&u->type->cache_gradient, quad);
    }
    else {
	type = u->hp->info->types[u->hp->max_order];
	nbas = DofNBas(u, e);
	cache = get_cache(&u->hp->cache_gradient, quad);
    }
    nvalues = Dim * type->dim;

    if (cache->data != NULL && cache->e == e && cache->face == face)
	return cache->data + n * npoints * nvalues;
    if (cache->data1 != NULL && cache->e1 == e && cache->face1 == face)
	return cache->data1 + n * npoints * nvalues;

    data = phgAlloc(nbas * npoints * nvalues * sizeof(*data));

    J = phgGeomGetJacobian(u->g, e);
    GetFaceVertices(e, face, v0, v1, v2, i);
    lambda[face] = 0.;
    pt = quad->points;
    for (k = 0; k < npoints; k++) {
	lambda[v0] = *(pt++);
	lambda[v1] = *(pt++);
	lambda[v2] = *(pt++);
	/* FIXME: make use of type->invariant? */
	G = type->BasGrads(u, e, 0, -1, lambda);
	for (j = 0; j < nbas; j++) {
	    p = data + (j * npoints + k) * nvalues;
	    /* compute p[dim][Dim] = G[npoints][Dim+1] * J[Dim+1][Dim] */
	    for (i = 0; i < type->dim; i++, G += Dim + 1) {
		*(p++) = G[0] * J[0 * (Dim + 1) + 0] +
			 G[1] * J[1 * (Dim + 1) + 0] +
			 G[2] * J[2 * (Dim + 1) + 0] +
			 G[3] * J[3 * (Dim + 1) + 0];
		*(p++) = G[0] * J[0 * (Dim + 1) + 1] +
			 G[1] * J[1 * (Dim + 1) + 1] +
			 G[2] * J[2 * (Dim + 1) + 1] +
			 G[3] * J[3 * (Dim + 1) + 1];
		*(p++) = G[0] * J[0 * (Dim + 1) + 2] +
			 G[1] * J[1 * (Dim + 1) + 2] +
			 G[2] * J[2 * (Dim + 1) + 2] +
			 G[3] * J[3 * (Dim + 1) + 2];
	    }
	}
    }

    update_face_cache(e, face, cache, data);

    return data + n * npoints * nvalues;
}

const FLOAT *
phgQuadFaceGetDofValues(ELEMENT *e, int face, DOF *u, QUAD *quad)
/* returns the address of an array containing the values of dof
 * at the quadrature points of 'quad', the values are stored in the order
 * FLOAT[quad->npoints][DofDim(u)].
 */
{
    QUAD_CACHE *cache;
    const FLOAT *pt, *bas;
    int nvalues = DofDim(u);
    FLOAT *v, *data, lambda[Dim + 1];
    int i, v0, v1, v2;

    assert(quad->dim == Dim - 1);

    cache = get_cache(&u->cache_func, quad);
    if (cache->data != NULL && cache->e == e && cache->face == face)
	return cache->data;
    if (cache->data1 != NULL && cache->e1 == e && cache->face1 == face)
	return cache->data1;

    GetFaceVertices(e, face, v0, v1, v2, i);
    lambda[face] = 0.;

    v = data = phgAlloc(quad->npoints * nvalues * sizeof(*v));
    if (SpecialDofType(u->type))
	bas = NULL;
    else
	bas = phgQuadFaceGetBasisValues(e, face, u, 0, quad);
    pt = quad->points;
    for (i = 0; i < quad->npoints; i++, v += nvalues) {
	lambda[v0] = *(pt++);
	lambda[v1] = *(pt++);
	lambda[v2] = *(pt++);
	if (bas == NULL) {
	    phgDofEval_(u, e, lambda, NULL, 0, v, NULL);
	    continue;
	}
	phgDofEval_(u, e, lambda, bas, quad->npoints * DofTypeDim(u), v, NULL);
	bas += u->type->dim;
    }

    update_face_cache(e, face, cache, data);

    return data;
}

/*--------------------------- 2D functions for DG ---------------------------*/

FLOAT
phgQuadFaceDofABas(ELEMENT *e, int face, DOF *u, DOF *A, DOF *v, int m,
		   int order)
/* Computes and returns \int_F u^T A \phi_m, where:
 * - F is the 'face'-th face of e,
 * - phi_m is the m-th element basis function of v
 * - A is the coefficient function (A==NULL ==> A=1)
 *
 * The arguments are similar as those in the function phgQuadFaceDofADnBas()
 */
{
    int i, j, k, nvalues, dimA;
    FLOAT d, d0, tmp;
    const FLOAT *bas, *w;
    QUAD *quad;
    const FLOAT *val_A, *val_u;

    assert(!SpecialDofType(v->type));
    assert(face >= 0 && face < NFace);

    assert(u != NULL && DofDim(u) == DofTypeDim(v));
    assert(A == NULL || DofDim(A) == 1);		/* TODO */

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
	i = (A == NULL ? 0 : DofTypeOrder(A, e));
	if (i > 0)
	    order += i;
    }
    quad = phgQuadGetQuad2D(order);

    nvalues = DofTypeDim(v);
    dimA = (A == NULL ? 1 : DofDim(A));
    assert(dimA == 1 || dimA == nvalues || dimA == nvalues * nvalues);

    val_A = (A == NULL ? NULL : phgQuadFaceGetDofValues(e, face, A, quad));
    val_u = phgQuadFaceGetDofValues(e, face, u, quad);

    w = quad->weights;
    bas = phgQuadFaceGetBasisValues(e, face, v, m, quad);

    d = 0.;
    for (i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	if (dimA == 1) {
	    for (j = 0; j < nvalues; j++)
		d0 += *(val_u++) * *(bas++);
	    if (val_A != NULL)
		d0 *= *(val_A++);
	}
	else if (dimA == nvalues) {
	    for (j = 0; j < nvalues; j++)
		d0 += *(val_A++) * *(val_u++) * *(bas++);
	}
	else {
	    assert(dimA == nvalues * nvalues);
	    for (j = 0; j < nvalues; j++, val_A += nvalues) {
		tmp = 0.;
		for (k = 0; k < nvalues; k++)
		    tmp += val_A[k] * bas[k];
		d0 += *(val_u++) * tmp;
	    }
	    bas += nvalues;
	}
	d += d0 * *(w++);
    }

    return d * phgGeomGetFaceArea(u->g, e, face);
}

FLOAT
phgQuadFaceDofADnBas(ELEMENT *e, int face, DOF *u, DOF *A, DOF *v, int m,
		    int order)
/* Computes and returns \int_F u (A\grad phi_m) . nv, where:
 * - 'F' denotes the face referenced by "(e,face)"
 * - "nv" denotes the outward unit normal vector of "(e,face)"
 * - "phi_m" is the "m"-th basis function of 'v' in the element
 * - dim('A') can be '1' (scalar), "Dim" (diagonal matrix) or "Dim^2" (matrix),
 * - A==NULL -> A==1.
 * - u==NULL -> u==1
 */
{
    int i, j;
    FLOAT d, d0;
    const FLOAT *grd_v, *val_u, *val_A, *w;
    QUAD *quad;
    FLOAT nv[Dim];

    assert(!SpecialDofType(v->type));
    assert(face >= 0 && face < NFace);

    phgGeomGetFaceOutNormal(v->g, e, face, nv);

    assert(DofTypeDim(v) == 1);
    assert(A == NULL || DofDim(A) == 1 || DofDim(A) == Dim ||
	   DofDim(A) == Dim * Dim);

    assert(u == NULL || DofDim(u) == 1);		/* TODO: dim!=1 */
    assert(A == NULL || DofDim(A) == 1);		/* TODO: dim!=1 */

    if (order < 0) {
	order = DofTypeOrder(v, e);
	assert(order >= 0);
	i = (u == NULL ? 0 : DofTypeOrder(u, e));
	j = (A == NULL ? 0 : DofTypeOrder(A, e));
	if (i < 0)
	    i = order;
	if (j < 0)
	    j = 0;
	order += i + j - 1;
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad2D(order);

    w = quad->weights;
    grd_v = phgQuadFaceGetBasisGradient(e, face, v, m, quad);
    val_u = (u == NULL ? NULL : phgQuadFaceGetDofValues(e, face, u, quad));
    val_A = (A == NULL ? NULL : phgQuadFaceGetDofValues(e, face, A, quad));
    d = 0.;
    for (i = 0; i < quad->npoints; i++, grd_v += Dim) {
	d0 = *(w++);
	if (u != NULL)
	    d0 *= *(val_u++);
	if (A != NULL)
	    d0 *= *(val_A++);
	d += d0 * (grd_v[0] * nv[0] + grd_v[1] * nv[1] + grd_v[2] * nv[2]);
    }

    return d * phgGeomGetFaceArea(v->g, e, face);
}

FLOAT
phgQuadFaceABasABas(DOF *A_u, ELEMENT *e_u, int face_u, DOF *u, int n,
		    DOF *A_v, ELEMENT *e_v, int face_v, DOF *v, int m,
		    int order)
/* Computes and returns \int_F A_u phi_n A_v phi_m, where:
 * - 'F' denotes the face referenced by both "(e_u,face_u)" and "(e_v,face_v)"
 *   (they must represent the same face), "nv" denotes the unit normal vector.
 * - "phi_n" is the 'n'-th basis function of 'u' in the element "e_u"
 * - "phi_m" is the 'm'-th basis function of 'v' in the element "e_v"
 * - The dimension of "A_u" (resp. "A_v") must be '1' (scalar).
 *
 *   If "A_u" (resp. "A_v") is NULL, then "A_u"='1' is assumed.
 */
{
    int i, j;
    FLOAT d, d0;
    const FLOAT *w, *bas_u, *bas_v, *val_Au = NULL, *val_Av = NULL;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(face_u >= 0 && face_u < NFace && face_v >= 0 && face_v < NFace);
    assert(e_u->faces[face_u] == e_v->faces[face_v]);
    assert(DofTypeDim(u) == 1 && DofTypeDim(v) == 1);
    assert(A_u == NULL || DofDim(A_u) == 1);
    assert(A_v == NULL || DofDim(A_v) == 1);
    assert(u->g == v->g);

    if (order < 0) {
	i = DofTypeOrder(u, e_u);
	j = DofTypeOrder(v, e_v);
	assert(i >= 0 && j >= 0);
	order = i + j;
	i = (A_u == NULL ? 0 : DofTypeOrder(A_u, e_u));
	if (i < 0)
	    i = 0;
	j = (A_v == NULL ? 0 : DofTypeOrder(A_v, e_v));
	if (j < 0)
	    j = 0;
	order += i + j;
    }
    quad = phgQuadGetQuad2D(order);

    w = quad->weights;
    bas_u = phgQuadFaceGetBasisValues(e_u, face_u, u, n, quad);
    bas_v = phgQuadFaceGetBasisValues(e_v, face_v, v, m, quad);
    if (A_u != NULL)
	val_Au = phgQuadFaceGetDofValues(e_u, face_u, A_u, quad);
    if (A_v != NULL)
	val_Av = phgQuadFaceGetDofValues(e_v, face_v, A_v, quad);

    d = 0.;
    for (i = 0; i < quad->npoints; i++) {
	/* A_u phi_n */
	d0 = *(bas_u++);
	if (A_u != NULL)
	    d0 *= *(val_Au++);

	/* A_v phi_m */
	d0 *= *(bas_v++);
	if (A_v != NULL)
	    d0 *= *(val_Av++);

	d += d0 * *(w++);
    }

    return d * phgGeomGetFaceArea(u->g, e_u, face_u);
}

FLOAT
phgQuadFaceABasADnBas(DOF *A_u, ELEMENT *e_u, int face_u, DOF *u, int n,
		      DOF *A_v, ELEMENT *e_v, int face_v, DOF *v, int m,
		      int order)
/* Computes and returns \int_F (A_u\grad phi_n).nv (A_v\grad phi_m).nv, where:
 * - 'F' denotes the face referenced by both "(e_u,face_u)" and "(e_v,face_v)"
 *   (they must represent the same face)
 * - "nv" denotes the outward unit normal vector of (e_v,face_v).
 * - "phi_n" is the 'n'-th basis function of 'u' in the element "e_u"
 * - "phi_m" is the 'm'-th basis function of 'v' in the element "e_v"
 * - The dimension of "A_u" must be '1' (scalar), and the dimension of "A_v"
 *   can be '1' (scalar), "Dim" (diagonal matrix) or "Dim*Dim" (full matrix).
 *
 *   If "A_u" (resp. "A_v") is NULL, then "A_u"='1' is assumed.
 */
{
    int i, j;
    FLOAT d, d0;
    const FLOAT *grd_v, *w, *bas_u, *val_Au = NULL, *val_Av = NULL;
    QUAD *quad;
    FLOAT nv[Dim];

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(face_u >= 0 && face_u < NFace && face_v >= 0 && face_v < NFace);
    assert(e_u->faces[face_u] == e_v->faces[face_v]);
    assert(DofTypeDim(u) == 1 && DofTypeDim(v) == 1);
    assert(A_u == NULL || DofDim(A_u) == 1);
    assert(A_v == NULL || DofDim(A_v) == 1 || DofDim(A_v) == Dim ||
	   DofDim(A_v) == Dim * Dim);
    assert(u->g == v->g);

    phgGeomGetFaceOutNormal(v->g, e_v, face_v, nv);

    assert(A_v == NULL || DofDim(A_v) == 1);		/* TODO */

    if (order < 0) {
	i = DofTypeOrder(u, e_u);
	j = DofTypeOrder(v, e_v);
	assert(i >= 0 && j >= 0);
	order = i + j - 1;
	i = (A_u == NULL ? 0 : DofTypeOrder(A_u, e_u));
	if (i < 0)
	    i = 0;
	j = (A_v == NULL ? 0 : DofTypeOrder(A_v, e_v));
	if (j < 0)
	    j = 0;
	order += i + j;
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad2D(order);

    w = quad->weights;
    bas_u = phgQuadFaceGetBasisValues(e_u, face_u, u, n, quad);
    grd_v = phgQuadFaceGetBasisGradient(e_v, face_v, v, m, quad);
    if (A_u != NULL)
	val_Au = phgQuadFaceGetDofValues(e_u, face_u, A_u, quad);
    if (A_v != NULL)
	val_Av = phgQuadFaceGetDofValues(e_v, face_v, A_v, quad);

    d = 0.;
    for (i = 0; i < quad->npoints; i++, grd_v += Dim) {
	/* A_u phi_n */
	d0 = *(w++) * *(bas_u++);
	if (A_u != NULL)
	    d0 *= *(val_Au++);

	/* (A_v\grad phi_m).nv */
	d0 *= nv[0] * grd_v[0] + nv[1] * grd_v[1] + nv[2] * grd_v[2];
	if (A_v != NULL)
	    d0 *= *(val_Av++);

	d += d0;
    }

    return d * phgGeomGetFaceArea(u->g, e_u, face_u);
}

FLOAT
phgQuadFaceADnBasADnBas(DOF *A_u, ELEMENT *e_u, int face_u, DOF *u, int n,
			DOF *A_v, ELEMENT *e_v, int face_v, DOF *v, int m,
			int order)
/* Computes and returns \int_F (A_u\grad phi_n).nv (A_v\grad phi_m).nv, where:
 * - 'F' denotes the face referenced by both "(e_u,face_u)" and "(e_v,face_v)"
 *   (they must represent the same face)
 * - "nv" denotes the outward unit normal vector of the face w.r.t. e_v.
 * - "phi_n" is the 'n'-th basis function of 'u' in the element "e_u"
 * - "phi_m" is the 'm'-th basis function of 'v' in the element "e_v"
 * - The dimension of "A_u" (resp. "A_v") can be '1' (scalar), "Dim" (diagonal
 *   matrix), or "Dim*Dim" (full matrix).
 *
 *   If "A_u" (resp. "A_v") is NULL, then "A_u"='1' is assumed.
 */
{
    int i, j;
    FLOAT d, d0;
    const FLOAT *grd_u, *grd_v, *w, *val_Au = NULL, *val_Av = NULL;
    QUAD *quad;
    FLOAT nv[Dim];

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(face_u >= 0 && face_u < NFace && face_v >= 0 && face_v < NFace);
    assert(e_u->faces[face_u] == e_v->faces[face_v]);
    assert(DofTypeDim(u) == 1 && DofTypeDim(v) == 1);
    assert(A_u == NULL || DofDim(A_u) == 1 || DofDim(A_u) == Dim ||
	   DofDim(A_u) == Dim * Dim);
    assert(A_v == NULL || DofDim(A_v) == 1 || DofDim(A_v) == Dim ||
	   DofDim(A_v) == Dim * Dim);
    assert(u->g == v->g);

    assert((A_u == NULL || DofDim(A_u) == 1) &&
	   (A_v == NULL || DofDim(A_v) == 1));		/* TODO */

    phgGeomGetFaceOutNormal(v->g, e_v, face_v, nv);

    if (order < 0) {
	i = DofTypeOrder(u, e_u);
	j = DofTypeOrder(v, e_v);
	assert(i >= 0 && j >= 0);
	order = i + j - 2;
	i = (A_u == NULL ? 0 : DofTypeOrder(A_u, e_u));
	if (i < 0)
	    i = 0;
	j = (A_v == NULL ? 0 : DofTypeOrder(A_v, e_v));
	if (j < 0)
	    j = 0;
	order += i + j;
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad2D(order);

    w = quad->weights;
    grd_u = phgQuadFaceGetBasisGradient(e_u, face_u, u, n, quad);
    grd_v = phgQuadFaceGetBasisGradient(e_v, face_v, v, m, quad);
    if (A_u != NULL)
	val_Au = phgQuadFaceGetDofValues(e_u, face_u, A_u, quad);
    if (A_v != NULL)
	val_Av = phgQuadFaceGetDofValues(e_v, face_v, A_v, quad);

    d = 0.;
    for (i = 0; i < quad->npoints; i++, grd_u += Dim, grd_v += Dim) {
	/* (A_u\grad phi_n).nv */
	d0 = nv[0] * grd_u[0] + nv[1] * grd_u[1] + nv[2] * grd_u[2];
	if (A_u != NULL)
	    d0 *= *(val_Au++);

	/* (A_v\grad phi_m).nv */
	d0 *= nv[0] * grd_v[0] + nv[1] * grd_v[1] + nv[2] * grd_v[2];
	if (A_v != NULL)
	    d0 *= *(val_Av++);

	d += d0 * *(w++);
    }

    return d * phgGeomGetFaceArea(u->g, e_u, face_u);
}

/*----------------------------- old 2D functions ----------------------------*/

FLOAT
phgQuadFaceDofDotBas(ELEMENT *e, int face, DOF *u, DOF_PROJ proj,
		     DOF *v, int N, int order)
{
    GRID *g = u->g;
    int i, j, k, nvalues, v0, v1, v2, dim;
    FLOAT d, d0, lambda[Dim + 1];
    FLOAT *dof, *buffer, *p0, *p1;
    const FLOAT *bas, *p, *w;
    QUAD *quad;
    FLOAT n[Dim];	/* out normal vector */
    DOF_TYPE *type;

    assert(!SpecialDofType(v->type));
    assert(face >= 0 && face <= 3);

    type = (DofIsHP(v) ? v->hp->info->types[v->hp->max_order] : v->type);

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad2D(order);

    v0 = GetFaceVertex(face, 0);
    v1 = GetFaceVertex(face, 1);
    v2 = GetFaceVertex(face, 2);
    lambda[face] = 0.;

    dim = DofDim(u) / (proj == DOF_PROJ_DOT ? Dim : 1);
    nvalues = DofTypeDim(v);

    if (nvalues != dim)
	phgError(1, "%s: dimensions mismatch\n", __func__);

    buffer = phgAlloc(nvalues * sizeof(*buffer));
    p = quad->points;
    w = quad->weights;

    d = 0.;
    switch (proj) {
        case DOF_PROJ_NONE:
             for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
             
		 dof = phgDofEval(u, e, lambda, buffer);
                 bas = (FLOAT *)type->BasFuncs(v, e, N, N + 1, lambda);
                 d0 = 0.;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(bas++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
	     phgFree(buffer);
             break;
	     
        case DOF_PROJ_DOT:
             p0 = phgAlloc(nvalues * Dim * sizeof(*p0));
	     phgGeomGetFaceOutNormal(g, e, face, n);
             for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
                 
		 p1 = phgDofEval(u, e, lambda, p0);
                 bas = type->BasFuncs(v, e, N, N + 1, lambda);
		 dof = buffer;
		 for (k = 0; k < nvalues; k++) {
                      *(dof++) = n[0] * p1[0] + n[1] * p1[1] + n[2] * p1[2];
		      p1 += Dim;
		 }
                 d0 = 0.;
		 dof = buffer;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(bas++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
             phgFree(buffer);
             phgFree(p0);
             break;
	     
        case DOF_PROJ_CROSS:
             p0 = phgAlloc(nvalues * sizeof(*p0));
	     phgGeomGetFaceOutNormal(g, e, face, n);
             for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
                 
		 p1 = phgDofEval(u, e, lambda, p0);
                 bas = type->BasFuncs(v, e, N, N + 1, lambda);
		 dof = buffer;
		 for (k = 0; k < nvalues / Dim; k++) {
                      *(dof++) = p1[1] * n[2] - p1[2] * n[1];
		      *(dof++) = p1[2] * n[0] - p1[0] * n[2];
                      *(dof++) = p1[0] * n[1] - p1[1] * n[0];
		      p1 += Dim;
		 }
                 d0 = 0.;
		 dof = buffer;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(bas++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
             phgFree(buffer);
             phgFree(p0);
             break;
	     
        default:
             phgError(1, "%s: unknown projection %d\n", __func__, proj);
    }

    return d * phgGeomGetFaceArea(u->g, e, face);
}

FLOAT
phgQuadFaceBasDotBas(ELEMENT *e, int face, DOF *u, int n, DOF *v, int m,
		     int order)
/* Computes and returns \int_F \phi_n \cdot \phi_m, where:
 *	- F is the 'face'-th face of e,
 *	- phi_n is the n-th element basis function of u,
 *	- phi_m is the m-th element basis function of v */
{
    int i, j, nvalues, v0, v1, v2;
    FLOAT d, d0, lambda[Dim + 1];
    FLOAT *buffer;
    const FLOAT *bas0, *bas1, *p, *w;
    QUAD *quad;
    DOF_TYPE *type_u, *type_v;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(face >= 0 && face < NFace);

    type_u = (DofIsHP(u) ? u->hp->info->types[u->hp->max_order] : u->type);
    type_v = (DofIsHP(v) ? v->hp->info->types[v->hp->max_order] : v->type);
    assert(DofTypeDim(u) == DofTypeDim(v));

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad2D(order);

    v0 = GetFaceVertex(face, 0);
    v1 = GetFaceVertex(face, 1);
    v2 = GetFaceVertex(face, 2);
    lambda[face] = 0.;

    nvalues = DofTypeDim(v);

    if (n != m || u != v)
	buffer = phgAlloc(nvalues * sizeof(*buffer));
    else
	buffer = NULL;
    p = quad->points;
    w = quad->weights;

    d = 0.;
    for (i = 0; i < quad->npoints; i++) {
        lambda[v0] = *(p++);
        lambda[v1] = *(p++);
        lambda[v2] = *(p++);
	/* Note: type->BasFuncs returns an internal static buffer, its contents
	 * are changed by the next call if type_u==type_v */
	bas0 = type_u->BasFuncs(u, e, n, n + 1, lambda);
	if (n == m && u == v) {
	    bas1 = bas0;
	}
	else {
	    memcpy(buffer, bas0, nvalues * sizeof(*buffer));
	    bas0 = buffer;
	    bas1 = type_v->BasFuncs(v, e, m, m + 1, lambda);
	}
	d0 = 0.;
	for (j = 0; j < nvalues; j++)
	    d0 += *(bas0++) * *(bas1++);
	d += d0 * *(w++);
    }
	     
    phgFree(buffer);

    return d * phgGeomGetFaceArea(u->g, e, face);
}

FLOAT
phgQuadFaceBasABas(ELEMENT * e, int face, DOF *u, int n, DOF *A, DOF *v,
		   int m, int order)
/* Computes and returns \int_F \phi_n^T A \phi_m, where:
 * - F is the 'face'-th face of e,
 * - phi_n is the n-th element basis function of u,
 * - phi_m is the m-th element basis function of v,
 * - A is a DOF representing the coefficient function.
 *
 * Note:
 *   1. u and v must satisfy DofTypeDim(u) == DofTypeDim(v)
 *   2. Let n = DofTypeDim(u), then phi_n and phi_m are regarded as n-component
 *	column vectors, and DofDim(A) is allowed to take one of the following
 *	values:
 *		DofDim(A)==1	=> A is regarded as a scalar function
 *		DofDim(A)==n	=> A is regarded as an nxn diagonal matrix
 *		DofDim(A)==n*n	=> A is regarded as an nxn matrix
 *   3. A can be NULL, in this case it's replaced by the constant function 1.
 */
{
    int i, j, k, nvalues, dimA, v0, v1, v2;
    FLOAT d, d0, tmp, lambda[Dim + 1];
    FLOAT *buffer, *bufferA;
    const FLOAT *bas0, *bas1, *p, *w;
    QUAD *quad;
    DOF_TYPE *type_u, *type_v;
    const FLOAT *Au;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(DofTypeDim(u) == DofTypeDim(v));
    assert(face >= 0 && face < NFace);

    type_u = (DofIsHP(u) ? u->hp->info->types[u->hp->max_order] : u->type);
    type_v = (DofIsHP(v) ? v->hp->info->types[v->hp->max_order] : v->type);
    assert(DofTypeDim(u) == DofTypeDim(v));

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
	if (A != NULL && (i = DofTypeOrder(A, e)) > 0)
	    order += i;
    }
    quad = phgQuadGetQuad2D(order);

    v0 = GetFaceVertex(face, 0);
    v1 = GetFaceVertex(face, 1);
    v2 = GetFaceVertex(face, 2);
    lambda[face] = 0.;

    nvalues = DofTypeDim(u);
    if (n != m || u != v)
	buffer = phgAlloc(nvalues * sizeof(*buffer));
    else
	buffer = NULL;

    if (A == NULL) {
	dimA = 1;
	bufferA = NULL;
    }
    else {
	bufferA = phgAlloc(DofDim(A) * sizeof(*bufferA));
	dimA = DofDim(A);
	assert(dimA == 1 || dimA == nvalues || dimA == nvalues * nvalues);
    }

    p = quad->points;
    w = quad->weights;

    d = 0.;
    for (i = 0; i < quad->npoints; i++) {
	lambda[v0] = *(p++);
	lambda[v1] = *(p++);
	lambda[v2] = *(p++);
	/* Note: type->BasFuncs returns an internal static buffer, its contents
	 * are changed by the next call if type_u==type_v */
	if (A != NULL)
	    Au = phgDofEval(A, e, lambda, bufferA);
	else
	    Au = NULL;
	bas0 = type_u->BasFuncs(u, e, n, n + 1, lambda);
	if (n == m && u == v) {
	    bas1 = bas0;
	}
	else {
	    memcpy(buffer, bas0, nvalues * sizeof(*buffer));
	    bas0 = buffer;
	    bas1 = type_v->BasFuncs(v, e, m, m + 1, lambda);
	}
	d0 = 0.;
	if (dimA == 1) {
	    for (j = 0; j < nvalues; j++)
		d0 += *(bas0++) * *(bas1++);
	    if (Au != NULL)
		d0 *= *Au;
	}
	else if (dimA == nvalues) {
	    assert(Au != NULL);
	    for (j = 0; j < nvalues; j++)
		d0 += *(Au++) * *(bas0++) * *(bas1++);
	}
	else {
	    assert(Au != NULL && dimA == nvalues * nvalues);
	    for (j = 0; j < nvalues; j++, Au += nvalues) {
		tmp = 0.;
		for (k = 0; k < nvalues; k++)
		    tmp += Au[k] * bas1[k];
		d0 += *(bas0++) * tmp;
	    }
	}
	d += d0 * *(w++);
    }

    phgFree(buffer);
    phgFree(bufferA);

    return d * phgGeomGetFaceArea(u->g, e, face);
}

FLOAT
phgQuadFaceDofDotDof(ELEMENT *e, int face, DOF *u, DOF_PROJ proj,
		     DOF *v, int order)
{
    GRID *g = u->g;
    int i, j, k, nvalues, v0, v1, v2, dim;
    FLOAT d, d0, lambda[Dim + 1];
    FLOAT *dof, *buffer, *p0, *p1;
    FLOAT *dofv, *pv;
    const FLOAT *p, *w;
    QUAD *quad;
    FLOAT n[Dim];	/* out normal vector */

    assert(face >= 0 && face <= 3);

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad2D(order);

    v0 = GetFaceVertex(face, 0);
    v1 = GetFaceVertex(face, 1);
    v2 = GetFaceVertex(face, 2);
    lambda[face] = 0.;

    dim = DofDim(u) / (proj == DOF_PROJ_DOT ? Dim : 1);
    nvalues = DofDim(v);

    if (nvalues != dim)
	phgError(1, "%s: dimensions mismatch\n", __func__);

    buffer = phgAlloc(nvalues * sizeof(*buffer));
    dofv = phgAlloc(nvalues * sizeof(*dofv));
    p = quad->points;
    w = quad->weights;

    d = 0.;
    switch (proj) {
        case DOF_PROJ_NONE:
             for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
             
		 dof = phgDofEval(u, e, lambda, buffer);
                 pv = phgDofEval(v, e, lambda, dofv);
                 d0 = 0.;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(pv++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
             phgFree(buffer);
	     phgFree(dofv);
             break;
	     
        case DOF_PROJ_DOT:
             p0 = phgAlloc(nvalues * Dim * sizeof(*p0));
	     phgGeomGetFaceOutNormal(g, e, face, n);
	     
             for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
                 
		 p1 = phgDofEval(u, e, lambda, p0);
		 pv = phgDofEval(v, e, lambda, dofv);
		 dof = buffer;
		 for (k = 0; k < nvalues; k++) {
                      *(dof++) = n[0] * p1[0] + n[1] * p1[1] + n[2] * p1[2];
		      p1 += Dim;
		 }
		 
                 d0 = 0.;
		 dof = buffer;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(pv++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
             phgFree(buffer);
	     phgFree(dofv);
             phgFree(p0);
             break;
	     
        case DOF_PROJ_CROSS:
	     assert(DofDim(u) % Dim == 0);
             p0 = phgAlloc(nvalues * sizeof(*p0));
	     phgGeomGetFaceOutNormal(g, e, face, n);
             
	     for (i = 0; i < quad->npoints; i++) {
                 lambda[v0] = *(p++);
                 lambda[v1] = *(p++);
                 lambda[v2] = *(p++);
                 
		 p1 = phgDofEval(u, e, lambda, p0);
		 pv = phgDofEval(v, e, lambda, dofv);
		 dof = buffer;
		 for (k = 0; k < nvalues / Dim; k++) {
                      *(dof++) = p1[1] * n[2] - p1[2] * n[1];
		      *(dof++) = p1[2] * n[0] - p1[0] * n[2];
                      *(dof++) = p1[0] * n[1] - p1[1] * n[0];
		      p1 += Dim;
		 }
                 d0 = 0.;
		 dof = buffer;
                 for (j = 0; j < nvalues; j++) {
                     d0 += *(pv++) * *(dof++);
		 }
		 d += d0 * *(w++);
	     }
	     
             phgFree(buffer);
	     phgFree(dofv);
             phgFree(p0);
             break;
	     
        default:
             phgError(1, "%s: unknown projection %d\n", __func__, proj);
    }
    return d * phgGeomGetFaceArea(u->g, e, face);
}

/* a x b */
#define OP_CROSS0(a,b)  \
	     ((*((a)+1)) * (*((b)+2)) - (*((a)+2)) * (*((b)+1)))
#define OP_CROSS1(a,b)  \
	     ((*((a)+2)) * (*(b)) - (*(a)) * (*((b)+2)))
#define OP_CROSS2(a,b)  \
	     ((*(a)) * (*((b)+1)) - (*((a)+1)) * (*(b)))

/* a \dot b */
#define OP_DOT(a,b) \
    ((*(a)) * (*(b)) + (*((a)+1)) * (*((b)+1)) + (*((a)+2)) * (*((b)+2)))

FLOAT *
phgQuadFaceADofCrossDof(ELEMENT *e, int face, DOF *A, DOF *u, DOF_PROJ u_proj,
			DOF *v, DOF_PROJ v_proj, int order, FLOAT *reval)
/* \int A ( u \corss n ) \cross ( v \cross n )  */
{
    GRID *g = u->g;
    int i, j, v0, v1, v2;
    int udim, vdim, dim;
    FLOAT *pd, lambda[Dim + 1], alpha, area;
    FLOAT *dofu, *pu;
    FLOAT *dofv, *pv;
    FLOAT *buffer0, *buffer1, *p0 = NULL, *p1 = NULL;
    const FLOAT *p, *w;
    QUAD *quad;
    FLOAT n[Dim];	/* out normal vector */

    assert(face >= 0 && face <= 3);
    assert(u != NULL && (DofDim(u) % Dim == 0));
    assert(reval!=NULL);
    if(A!=NULL)
       assert(DofDim(A)==1);

    if (order < 0) {
	i = DofTypeOrder(u, e);
	if (v != NULL)
	    j = DofTypeOrder(v, e);
	else
	    j = 0;
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad2D(order);

    v0 = GetFaceVertex(face, 0);
    v1 = GetFaceVertex(face, 1);
    v2 = GetFaceVertex(face, 2);
    lambda[face] = 0.;

    udim = DofDim(u) / (u_proj == DOF_PROJ_DOT ? Dim : 1);

    if (v != NULL){
	vdim = DofDim(v) / (v_proj == DOF_PROJ_DOT ? Dim : 1);
	if (vdim != udim)
	    phgError(1, "%s: dimensions mismatch\n", __func__);
    }

    dim = DofDim(u);
    dofu = phgAlloc(dim * sizeof(*dofu) * 4);
    dofv = dofu + dim;
    buffer0 = dofu + dim * 2;
    buffer1 = dofu + dim * 3;

    p = quad->points;
    w = quad->weights;

    pd=reval;
    for(i = 0; i < udim; i++) 
        (*pd++) = 0.;

    phgGeomGetFaceOutNormal(g, e, face, n);
    area = phgGeomGetFaceArea(g, e, face);
    for (i = 0; i < quad->npoints; i++, w++){
        lambda[v0] = *(p++);
        lambda[v1] = *(p++);
        lambda[v2] = *(p++);
        switch (u_proj) {
             /* u */
	    case DOF_PROJ_NONE:
		 p0 = phgDofEval(u, e, lambda, buffer0);
	         break;
	     /* ( (u \dot n) */
	    case DOF_PROJ_DOT:
		 pu = phgDofEval(u, e, lambda, dofu);
		 p0 = buffer0;
	         for (j = 0; j < dim/Dim ; j++) {
	             (*p0++) = OP_DOT (pu,n);
		     pu += Dim;
	  	 } 
	        break;
	     /* ( (u  \cross  n) */
            case DOF_PROJ_CROSS:
		 pu = phgDofEval(u, e, lambda, dofu);
		 p0 = buffer0;
                 for (j = 0; j < dim/Dim; j++) {
		     (*p0++) = OP_CROSS0(pu, n);
		     (*p0++) = OP_CROSS1(pu, n);
		     (*p0++) = OP_CROSS2(pu, n);
		     pu += Dim;
	         }
		 break;
           default:
                 phgError(1, "%s: unknown projection %d\n", __func__, u_proj);
        }
	
        if(v == NULL){
            p0=buffer0;
            pd=reval;
	    if (A != NULL){
	        phgDofEval(A, e, lambda, &alpha);
	        for (j = 0; j < udim ; j++)
	            (*pd++) += (*p0++)*(*w)*alpha; 
	    }else{
	        for(j = 0; j < udim ; j++)
	        (*pd++) += (*p0++)*(*w); 
	    }
        }else{
            switch(v_proj) {
              /* v */
	      case DOF_PROJ_NONE:
	           p1 = phgDofEval(v, e, lambda, buffer1);
	           break;
	      /* ( (v \dot n) */
	      case DOF_PROJ_DOT:
		   pv = phgDofEval(v, e, lambda, dofv);
		   p1 = buffer1;
	           for (j = 0; j < dim/Dim ; j++) {
	               (*p1++) = OP_DOT ( pv , n ) ;
		        pv += Dim;
	  	   } 
	           break;
	      /* ( (v  \cross  n) */
              case DOF_PROJ_CROSS:
		   pv = phgDofEval(v, e, lambda, dofv);
		   p1 = buffer1;
                   for (j = 0; j < dim/Dim; j++) {
		       (*p1++) = OP_CROSS0(pv, n);
		       (*p1++) = OP_CROSS1(pv, n);
		       (*p1++) = OP_CROSS2(pv, n);
		       pv += Dim;
	           }
		   break;
              default:
                   phgError(1, "%s: unknown projection %d\n", __func__, v_proj);
            }

            p0=buffer0;
            p1=buffer1;
            pd=reval;
            if (A!=NULL){
                phgDofEval(A, e, lambda, &alpha);
                for (j = 0; j < udim/Dim; j++){
	            (*pd++) += OP_CROSS0(p0, p1)*(*w)*alpha;
	            (*pd++) += OP_CROSS1(p0, p1)*(*w)*alpha;
	            (*pd++) += OP_CROSS2(p0, p1)*(*w)*alpha;
                    p0 += Dim;
	            p1 += Dim;
                }
            }else{
                for (j = 0; j < udim/Dim; j++) {
	            (*pd++) += OP_CROSS0(p0, p1)*(*w);
	            (*pd++) += OP_CROSS1(p0, p1)*(*w);
	            (*pd++) += OP_CROSS2(p0, p1)*(*w);
                    p0 += Dim;
	            p1 += Dim;
                }
           }
        }
    }/* end-for-i */ 

    for(i = 0; i< udim; i++, pd++)
        reval[i] *= area;
    phgFree(dofu);

    return reval;
}

FLOAT
phgQuadDofNormP(ELEMENT *e, DOF *u, int order, int p)
{
    int i, j, nvalues;
    FLOAT d, d0, tmp;
    const FLOAT *v1, *w;
    QUAD *quad;

    assert(u != NULL);
    nvalues = DofDim(u);

    if (order < 0) {
        i = DofTypeOrder(u, e) * p;
        if (i < 0)
            i = 1;
	order = i;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    w = quad->weights;
    v1 = phgQuadGetDofValues(e, u, quad);
    for (i = 0; i < quad->npoints; i++){
        tmp = 0.;
        for (j = 0; j < nvalues; j++){
            d0 = *(v1++);
            tmp += Pow(Fabs(d0), p);
	}
        d += tmp * *(w++);
    }

    return d * phgGeomGetVolume(u->g, e);
}

DOF *
phgQuadFaceJumpN(DOF *u, DOF_PROJ proj, const char *name, int order, DOF *gn)
/* returns a DOF with one value on each face which is the (L^2 norm)^2 over
 * the face of the jump of 'u' acrossing the face.
 *
 * 'proj' specifies the projection to use: DOF_PROJ_NONE means no projection,
 * DOF_PROJ_DOT means $\f\vec{u} \cdot \vec{n}\f$, DOF_PROJ_CROSS means
 * $\f\vec{u} \times \vec{n}\f$.
 *
 * 'name' specifies the name of the returned DOF.
 *
 * 'order' specifies numerical integration order, if 'order' < 0 then the
 * numerical integration order is set to 2 times the order of 'u'.
 * 
 * 'gn', if not NULL, specifies Neumann boundary condition, on a Neumann
 * face the jump is replaced by:
 * 	 u - gn		if 'proj' == DOF_PROJ_NONE
 * 	 u.n - gn	if 'proj' == DOF_PROJ_DOT, FIXME: use (u-gn).n instead?
 * 	 uxn - gn	if 'proj' == DOF_PROJ_CROSS
 *
 * Note: the normal vector used in this function is obtained by calling
 * 	 phgGeomGetFaceNormal(), which does not necessarily point to the
 * 	 outward direction.
 */
{
    static DOF_TYPE DOF_JUMP_ = { DofReserved,
	"Face jump", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, FE_None,
	FALSE, TRUE, FALSE, -1, NFace, 0, 0, -1, 1, 0, 0, 1, 0
    };
    char s[1024];
    GRID *g = u->g;
    ELEMENT *e;
    int ii, jj, face, j, k, dim, dim0 = DofDim(u);
    INT i;
    DOF *jump, tmp;
    DOF_TYPE *type;
    FLOAT values[dim0], values1[dim0];
    FLOAT lambda[Dim + 1];
    FLOAT d, d0, d1, *p, *p0, *p1;
    FLOAT *w, *pts, *buffer = NULL;
    const FLOAT *n = NULL, *bas, *pb;
    NEIGHBOUR_DATA *neigh;
    SHORT *bases0 = NULL, *bases1 = NULL;
    int nbases0 = 0, nbases1 = 0, nbas0, nbas1, v0, v1, v2, v3;
    QUAD *quad;
    VEF_MAP *vef;
    BOOLEAN neumann;
    FE_SPACE fe_space = (!DofIsHP(u) ? u->type->fe_space :
				       u->hp->info->fe_space);

    assert(!SpecialDofType(u->type));	/* return 0 in this case? */

    /* Note: only DG type is allowed (to be fixed when needed) */
    if (fe_space != FE_L2 && fe_space != FE_None)
	phgError(1, "%s: can't compute jumps of DOF \"%s\" "
		    "(only DG types are allowed).\n", __func__, u->name);

    if (proj != DOF_PROJ_NONE && DofDim(u) % Dim != 0)
	phgError(1, "phgDofJumpFace: DOF \"%s\" has incorrect dimension for "
		 "the operation %d\n", u->name, proj);

    dim = dim0 / (proj == DOF_PROJ_DOT ? Dim : 1);
    assert(gn == NULL || DofDim(gn) == dim);

    if (name == NULL) {
	sprintf(s, "Jumps of %s", u->name);
	name = s;
    }
    jump = phgDofNew(g, &DOF_JUMP_, 1, name, DofNoAction);

    vef = phgDofSetupVEFMap(g, jump, FACE_FLAG);
    neigh = phgDofInitNeighbourData(u, NULL);

    if (order < 0 && !DofIsHP(u))
	order = u->type->order * 2;

    if (order >= 0)
	quad = phgQuadGetQuad2D(order);
    else
	quad = NULL;		/* make gcc happy */

    if ((type = u->type) == NULL) {
	/* create a temporary non hp DOF whose type will be set by
	 * phgDofNeighbourNBas() to match the order of the neighbour.
	 * This DOF is used to get the list of the bases for the neighbouring
	 * element (bases1). */
	DOF *dof;
	dof = phgDofNew(g, type = u->hp->info->types[u->hp->max_order], u->dim,
			"temp", DofNoData);
	phgDofUnrefId(dof->type);
	memcpy(&tmp, dof, sizeof(tmp));
	dof->type = NULL;	/* shouldn't call phgDofUnrefId */
	phgDofFree(&dof);
    }

#if USE_OMP
#pragma omp parallel \
	firstprivate(tmp, quad, nbases0, nbases1, bases0, bases1) \
	private(i, j, k, e, face, neumann, nbas0, nbas1, ii, jj, v0, v1, v2, \
		pts, w, lambda, d, d0, d1, values, values1, \
		p0, p, p1, pb, bas, n)
{
#pragma omp for
#endif	/* USE_OMP */
    for (i = 0; i < (g->halo != NULL ? g->halo->nface_bak : g->nface); i++) {
	if (g->types_face[i] == UNREFERENCED)
	    continue;
	e = vef->Fmap[i];
	face = vef->Find[i];

	if (!(e->bound_type[face] & (INTERIOR | NEUMANN))) 
	    continue;		/* non Neumann boundary */

	neumann = (e->bound_type[face] & NEUMANN);
	if (neumann && gn == NULL)
	    continue;

	nbas0 = phgDofGetBasesOnFace(u, e, face, NULL);
	if (!neumann) {
	    if (!DofIsHP(u)) {
		nbas1 = nbas0;
	    }
	    else {
		nbas1 = phgDofNeighbourNBas(neigh, e, face, &tmp.type);
		if (order < 0) {
		    assert(DofIsHP(u));
		    j = u->hp->info->types[u->hp->elem_order[e->index]]->order;
		    quad = phgQuadGetQuad2D(j + tmp.type->order);
		}
	    }
	}
	else {
	    nbas1 = 0;
	    if (order < 0) {
		assert(DofIsHP(u));
		j = u->hp->info->types[u->hp->elem_order[e->index]]->order;
		if (gn->type == DOF_CONSTANT)
		    k = 0;
		else if (gn->type == DOF_ANALYTIC)
		    k = j;
		else
		    k = DofFaceOrder(gn, i);
		quad = phgQuadGetQuad2D(j + k);
	    }
	}

	if (nbases0 < nbas0) {
	    nbases0 = nbas0;
	    phgFree(bases0);
	    bases0 = phgAlloc(nbases0 * sizeof(*bases0));
	}
	phgDofGetBasesOnFace(u, e, face, bases0);

	if (!neumann && nbas0 != nbas1) {
	    if (nbases1 < nbas1) {
		nbases1 = nbas1;
		phgFree(bases1);
		bases1 = phgAlloc(nbases1 * sizeof(*bases1));
	    }
	    phgDofGetBasesOnFace(&tmp, e, face, bases1);
	}

	GetFaceVertices(e, face, v0, v1, v2, v3);

	pts = quad->points;
	w   = quad->weights;
	lambda[face] = 0.;

#define CACHE_BASES	TRUE
	if (CACHE_BASES && !DofIsHP(u) && buffer == NULL) {
	    /* pre-compute values of basis functions at quadrature points */
#if USE_OMP
#pragma omp flush(buffer)
#pragma omp critical (face_jump)
#endif	/* USE_OMP */
	    if (buffer == NULL) {
		/* only one thread will execute this block */
		FLOAT *buffer_tmp;
		int max, min;
		min = max = bases0[0];
		for (jj = 1; jj < nbas0; jj++) {
		    if (min > bases0[jj])
			min = bases0[jj];
		    else if (max < bases0[jj])
			max = bases0[jj];
		}
		buffer_tmp = phgAlloc(quad->npoints * nbas0 * type->dim
						* sizeof(*buffer_tmp));
		for (k = 0; k < quad->npoints; k++) {
		    lambda[v0] = *(pts++);
		    lambda[v1] = *(pts++);
		    lambda[v2] = *(pts++);
		    p = buffer_tmp + k * nbas0 * type->dim;
		    bas = type->BasFuncs(u, e, min, max + 1, lambda);
		    for (jj = 0; jj < nbas0; jj++, p += type->dim)
			memcpy(p, bas + (bases0[jj] - min) * type->dim,
				  type->dim * sizeof(*buffer_tmp));
		}
		pts = quad->points;	/* restore pts */
		buffer = buffer_tmp;
#if USE_OMP
#pragma omp flush(buffer)
#endif	/* USE_OMP */
	    }
	}

	d = 0.;
	for (k = 0; k < quad->npoints; k++) {
	    lambda[v0] = *(pts++);
	    lambda[v1] = *(pts++);
	    lambda[v2] = *(pts++);
	    memset(values, 0, dim0 * sizeof(*values));
	    for (j = 0; j < nbas0; j++) {
		ii = bases0[j];
		if (CACHE_BASES && !DofIsHP(u)) {
		    bas = buffer + (k * nbas0 + j) * type->dim;
		}
		else {
		    bas = type->BasFuncs(u, e, ii, ii + 1, lambda);
		}
		p0 = u->data + phgDofMapE2D(u, e, ii * u->dim);
		p = values;
		if (neumann || nbas0 != nbas1) {
		    for (ii = 0; ii < u->dim; ii++) {
			d0 = *(p0++);
			for (jj = 0, pb = bas; jj < type->dim; jj++)
			    *(p++) += d0 * *(pb++);
		    }
		}
		else {
		    p1 = phgDofNeighbourData(neigh, e, face, j, NULL);
		    for (ii = 0; ii < u->dim; ii++) {
			d0 = *(p0++) - *(p1++);
			for (jj = 0, pb = bas; jj < type->dim; jj++)
			    *(p++) += d0 * *(pb++);
		    }
		}
	    }
#if 0
/*if (i == 4)*/ {
FLOAT values0[dim0], lambda1[Dim + 1];
int u0, u1, u2;
phgDofEval(u, e, lambda, values0);
ELEMENT *e1 = e->neighbours[face];
ii = phgOppositeFace(g, e, face, e1);
GetFaceVertices(e1, ii, u0, u1, u2);
pts -= 3;
lambda1[ii] = 0.;
lambda1[u0] = *(pts++);
lambda1[u1] = *(pts++);
lambda1[u2] = *(pts++);
phgDofEval(u, e1, lambda1, values1);
for (ii = 0; ii < dim0; ii++)
phgInfo(-1, "face=%d, k=%d, ii = %d, value=%e, error=%e\n", i, k, ii, values[ii], values[ii] - values0[ii] + values1[ii]);
}
#endif

	    if (neumann) {
		phgDofEval(gn, e, lambda, values1);
	    }
	    else if (nbas0 != nbas1) {
		for (j = 0; j < nbas1; j++) {
		    ii = bases1[j];
		    bas = type->BasFuncs(&tmp, e, ii, ii + 1, lambda);
		    p0 = phgDofNeighbourData(neigh, e, face, j, NULL);
		    p = values;
		    for (ii = 0; ii < u->dim; ii++) {
			d0 = *(p0++);
			for (jj = 0, pb = bas; jj < type->dim; jj++)
			    *(p++) -= d0 * *(pb++);
		    }
		}
	    }

	    /* projection */
	    d0 = 0.;
	    switch (proj) {
	        case DOF_PROJ_NONE:
		    if (neumann) {
			p1 = values1;
			for (ii = 0, p = values; ii < dim0; ii++) {
			    d1 = *(p++) - *(p1++);
			    d0 += d1 * d1;
			}
		    }
		    else {
			for (ii = 0, p = values; ii < dim0; ii++, p++)
			    d0 += *p * *p;
		    }
		    break;
	        case DOF_PROJ_DOT:
		    n = phgGeomGetFaceNormal(g, e, face);
		    if (neumann) {
			p1 = values1;
			for (ii = 0, p = values; ii < dim; ii++, p += Dim) {
			    d1 = n[0]*p[0] + n[1]*p[1] + n[2]*p[2] - *(p1++);
		            d0 += d1 * d1;
			}
		    }
		    else {
			for (ii = 0, p = values; ii < dim; ii++, p += Dim) {
			    d1 = n[0] * p[0] + n[1] * p[1] + n[2] * p[2];
		            d0 += d1 * d1;
			}
		    }
		    break;
	        case DOF_PROJ_CROSS:
		    n = phgGeomGetFaceNormal(g, e, face);
		    if (neumann) {
			p1 = values1;
			for (ii = 0, p = values; ii < dim / Dim; ii++) {
		            d1 = p[1] * n[2] - p[2] * n[1] - *(p1++);
			    d0 += d1 * d1;
		            d1 = p[2] * n[0] - p[0] * n[2] - *(p1++);
			    d0 += d1 * d1;
		            d1 = p[0] * n[1] - p[1] * n[0] - *(p1++);
			    d0 += d1 * d1;
			    p += Dim;
			}
		    }
		    else {
			for (ii = 0, p = values; ii < dim / Dim; ii++) {
		            d1 = p[1] * n[2] - p[2] * n[1];
			    d0 += d1 * d1;
		            d1 = p[2] * n[0] - p[0] * n[2];
			    d0 += d1 * d1;
		            d1 = p[0] * n[1] - p[1] * n[0];
			    d0 += d1 * d1;
			    p += Dim;
			}
		    }
		    break;
	        default:
		    phgError(1, "%s: invalid projection %d.\n", __func__, proj);
	    }		/* endswitch */
	    d += d0 * *(w++);
	}	/* endfor k */
	*DofFaceData(jump, i) = d * phgGeomGetFaceAreaByIndex(g, i);
    }	/* endfor i */

    phgFree(bases0);
    phgFree(bases1);

#if USE_OMP
}
#endif	/* USE_OMP */

    phgFree(buffer);

    phgDofFreeVEFMap(&vef);
    phgDofReleaseNeighbourData(&neigh);

    return jump;
}

/*------------------------------ 3D functions --------------------------------*/

FLOAT
phgQuadDofDotDof(ELEMENT *e, DOF *u, DOF *v, int order)
/* computes \int u \cdot v on element 'e' (inner product),
 * using quadrature rule of order 'order'.
 */
{
    int i, j, nvalues;
    FLOAT d, d0;
    const FLOAT *v1, *v2, *w;
    QUAD *quad;

    nvalues = DofDim(u);
    if (v != NULL && nvalues != DofDim(v))
	phgError(1, "%s:%d: dimensions of \"%s\" and \"%s\" don't match\n",
		 __FILE__, __LINE__, u->name, v->name);

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0 && j < 0) {
	    phgInfo(-1, "phgQuadDofDotDof: don't use QUAD_DEFAULT when both "
		    "DOF types are analytic.\n");
	    phgError(1, "phgQuadDofDotDof: can't determine quadrature order, "
			"abort.\n");
	}
	if (i < 0)
	    i = j;
	else if (j < 0)
	    j = i;
	order = i + j;
    }
    quad = phgQuadGetQuad3D(order);

    w = quad->weights;
    v1 = phgQuadGetDofValues(e, u, quad);
    v2 = phgQuadGetDofValues(e, v, quad);

    if (nvalues == 1) {		/* faster code for special case */
	d = 0.;
	for (i = 0; i < quad->npoints; i++)
	    d += *(v1++) * *(v2++) * *(w++);
    }
    else {
	d = 0.;
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++)
		d0 += *(v1++) * *(v2++);
	    d += d0 * *(w++);
	}
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadGradBasAGradBas(ELEMENT *e, DOF *u, int n, DOF *A, DOF *v, int m,
		       int order)
{
    int i, j, k, nvalues = DofTypeDim(u), nn, An;
    FLOAT d, d0;
    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(nvalues == DofTypeDim(v));

    if (order < 0) {
	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
	if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetBasisGradient(e, u, n, quad);
    g2 = phgQuadGetBasisGradient(e, v, m, quad);
    w = quad->weights;
    if (NULL == A) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += g1[0] * g2[0] + g1[1] * g2[1] + g1[2] * g2[2];
		g1 += Dim;
		g2 += Dim;
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += g1[0] * g2[0] + g1[1] * g2[1] + g1[2] * g2[2];
		g1 += Dim;
		g2 += Dim;
	    }
	    d += d0 * (*(w++)) * *(coef++);
	}
    }
    else if (An == (nn = nvalues * Dim)) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 +=
		    g1[0] * g2[0] * coef[0] + g1[1] * g2[1] * coef[1] +
		    g1[2] * g2[2] * coef[2];
		g1 += Dim;
		g2 += Dim;
		coef += Dim;
	    }
	    d += d0 * (*(w++));
	}
    }
    else if (An == nn * nn) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nn; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nn; k++) {
		    d0 += *(g1) * *(g2++) * *(coef++);
		}
		g1++;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadDivBasADivBas(ELEMENT *e, DOF *u, int n, DOF *A, DOF *v, int m,
		       int order)
{
    int i, j, k, nvalues = DofTypeDim(u), nn, An;
    FLOAT d, d0;
    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(nvalues == Dim && nvalues == DofTypeDim(v));

    if (order < 0) {
	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
	if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetBasisGradient(e, u, n, quad);
    g2 = phgQuadGetBasisGradient(e, v, m, quad);
    w = quad->weights;
    if (NULL == A) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues / Dim; j++) {
		d0 += (g1[0 + 0 * Dim] + g1[1 + 1 * Dim] + g1[2 + 2 * Dim]) *
		      (g2[0 + 0 * Dim] + g2[1 + 1 * Dim] + g2[2 + 2 * Dim]);
		g1 += Dim * Dim;
		g2 += Dim * Dim;
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	static BOOLEAN warned = FALSE;
	if (!warned) {
	    phgWarning("untested case.\n");
	    warned = TRUE;
	}
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues / Dim; j++) {
		d0 += (g1[0 + 0 * Dim] + g1[1 + 1 * Dim] + g1[2 + 2 * Dim]) *
		      (g2[0 + 0 * Dim] + g2[1 + 1 * Dim] + g2[2 + 2 * Dim]);
		g1 += Dim * Dim;
		g2 += Dim * Dim;
	    }
	    d += d0 * (*(w++)) * *(coef++);
	}
    }
    else if (An == (nn = nvalues / Dim)) {
	static BOOLEAN warned = FALSE;
	if (!warned) {
	    phgWarning("untested case.\n");
	    warned = TRUE;
	}
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues / Dim; j++) {
		d0 += (g1[0 + 0 * Dim] + g1[1 + 1 * Dim] + g1[2 + 2 * Dim]) *
		      (g2[0 + 0 * Dim] + g2[1 + 1 * Dim] + g2[2 + 2 * Dim]) *
		      (*(coef++));
		g1 += Dim;
		g2 += Dim;
	    }
	    d += d0 * (*(w++));
	}
    }
    else if (An == nn * nn) {
	static BOOLEAN warned = FALSE;
	if (!warned) {
	    phgWarning("untested case.\n");
	    warned = TRUE;
	}
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nn; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nn; k++) {
		    d0 += *(coef++) *
			(g1[0 + 0 * Dim] + g1[1 + 1 * Dim] + g1[2 + 2 * Dim]) *
                        (g2[0 + 0 * Dim] + g2[1 + 1 * Dim] + g2[2 + 2 * Dim]);
		    g2 += Dim * Dim;
		}
		g1 += Dim * Dim;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadLapBasDotLapBas(ELEMENT *e, DOF *u, int n, DOF *v, int m, int order)
{
    int i;
    FLOAT d;
    const FLOAT *g1, *g2, *w;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(DofTypeDim(u) == 1 && DofTypeDim(u) == DofTypeDim(v));

    if (order < 0) {
	order = BasisOrder(u, e, n) - 2 + BasisOrder(v, e, m) - 2;
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetBasisHessian(e, u, n, quad);
    g2 = phgQuadGetBasisHessian(e, v, m, quad);
    w = quad->weights;
    for (i = 0; i < quad->npoints; i++, g1 += 6, g2 += 6)
	d += (g1[0]+g1[2]+g1[5]) * (g2[0]+g2[2]+g2[5]) * *(w++);

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT *
phgQuadDofTimesBas(ELEMENT *e, DOF *u, DOF *v, int n, int order, FLOAT *res)
/* computes \int 'u' * ('n'-th basis function of 'v') on element 'e'
 * using quadrature rule of order 'order'.
 * The results are returned in the user provided array 'res' whose size should
 * be greater than or equal to u->dim.
 */
{
    int i, j, nvalues;
    const FLOAT *bas, *w, *f;
    FLOAT d;
    QUAD *quad;

    assert(v != NULL && !SpecialDofType(v->type) && DofTypeDim(v) == 1);

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad3D(order);

    nvalues = DofDim(u);
    f = phgQuadGetDofValues(e, u, quad);
    bas = phgQuadGetBasisValues(e, v, n, quad);

    w = quad->weights;
    if (nvalues == 1) {		/* faster code for special case */
	d = 0.0;
	for (i = 0; i < quad->npoints; i++) {
	    d += *(bas++) * *(w++) * *(f++);
	}
	res[0] = d * phgGeomGetVolume(u->g, e);
    }
    else {
	for (j = 0; j < nvalues; j++)
	    res[j] = 0;
	for (i = 0; i < quad->npoints; i++) {
	    d = *(bas++) * *(w++);
	    for (j = 0; j < nvalues; j++)
		res[j] += d * *(f++);
	}
	d = phgGeomGetVolume(u->g, e);
	for (j = 0; j < nvalues; j++)
	    res[j] *= d;
    }

    return res;
}

#if 0				/* note: use phgQuadBasABas */
/* computes integration of 
 *  	('n'-th basis function of 'u') 
 *  	\cdot 
 *  	('m'-th basis function of 'v')
 * on element 'e' (inner product), using quadrature rule of order 'order'.
 */
FLOAT
phgQuadBasDotBas(ELEMENT *e, DOF *u, int n, DOF *v, int m, int order)
{
    int i, j, nvalues = DofTypeDim(u);
    FLOAT *g1, *g2, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));

    if (nvalues != DofTypeDim(v))
	phgError(1, "%s:%d: dimensions mismatch: %s (%d) <==> %s ($d))\n",
		 __FILE__, __LINE__, DofTypeName(u), DofTypeDim(u),
		 DofTypeName(v), DofTypeDim(v));

    if (order < 0) {
	if (u->type == v->type && u->type != NULL &&
	    u->type->mass_lumping != NULL &&
	    u->type->mass_lumping->weights != NULL) {
	    return n == m ? u->type->mass_lumping->weights[n]
				* phgGeomGetVolume(u->g, e)
			    : 0.0;
	}
	order = BasisOrder(u, e, n) + BasisOrder(v, e, m);
    }
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisValues(e, u, n, quad);
    g2 = phgQuadGetBasisValues(e, v, m, quad);
    d = 0.;
    w = quad->weights;
    for (i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	for (j = 0; j < nvalues; j++) {
	    d0 += *(g1++) * (*(g2++));
	}
	d += d0 * (*(w++));
    }
    return d * phgGeomGetVolume(u->g, e);
}
#endif

FLOAT
phgQuadBasABas(ELEMENT *e, DOF *u, int n, DOF *A, DOF *v, int m, int order)
/* computes integration of 
 *  	('n'-th basis function of 'u') 
 *  	\cdot 
 *       (coefficient function 'A')
 *       \cdot
 *  	('m'-th basis function of 'v')
 * on element 'e' (inner product), using quadrature rule of order 'order'.
 *
 */
{
    int i, j, k, nvalues = DofTypeDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));

    if (nvalues != DofTypeDim(v))
	phgError(1, "%s:%d: dimensions mismatch: %s (%d) <==> %s ($d))\n",
		 __FILE__, __LINE__, DofTypeName(u), DofTypeDim(u),
		 DofTypeName(v), DofTypeDim(v));

    if (order < 0) {
	if (A == NULL && u->type == v->type && u->type != NULL &&
	    u->type->mass_lumping != NULL &&
	    u->type->mass_lumping->weights != NULL) {
	    return n == m ? u->type->mass_lumping->weights[n]
				* phgGeomGetVolume(u->g, e)
			    : 0.0;
	}
	order = BasisOrder(u, e, n) + BasisOrder(v, e, m);
	if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
    }
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisValues(e, u, n, quad);
    g2 = phgQuadGetBasisValues(e, v, m, quad);
    d = 0.;
    w = quad->weights;
    if (NULL == A) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++);
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * (*(g2++));
	    }
	    d += d0 * (*(w++)) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}
    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++) {
		    d0 += *(g1) * *(g2++) * *(coef++);
		}
		g1++;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

#if 0				/* note: use phgQuadCurlBasACurlBas */
/* computes integration of
 *        (curl of 'n'-th basis function of 'u')
 *        \cdot
 *        (curl of 'm'-th basis function of 'v')
 * on element 'e' using quadrature rule of order 'order'.
 */
FLOAT
phgQuadCurlBasDotCurlBas(ELEMENT *e, DOF *u, int n, DOF *v, int m, int order)
{
    int i, j, nvalues = DofTypeDim(u);
    FLOAT *g1, *g2, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));

    if (nvalues != DofTypeDim(v))
	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
		 __FILE__, __LINE__, u->name, v->name);

    if (order < 0)
	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisCurl(e, u, n, quad);
    g2 = phgQuadGetBasisCurl(e, v, m, quad);

    d = 0.;
    w = quad->weights;
    for (i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	for (j = 0; j < nvalues; j++) {
	    d0 += *(g1++) * (*(g2++));
	}
	d += d0 * (*(w++));
    }

    return d * phgGeomGetVolume(u->g, e);
}
#endif

FLOAT
phgQuadCurlBasACurlBas(ELEMENT *e, DOF *u, int n, DOF *A, DOF *v, int m,
		       int order)
{
    int i, j, k, nvalues = DofTypeDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));

    if (nvalues != DofTypeDim(v))
	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
		 __FILE__, __LINE__, u->name, v->name);

    if (order < 0) {
	order = BasisOrder(u, e, n) - 1 + BasisOrder(v, e, m) - 1;
        if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisCurl(e, u, n, quad);
    g2 = phgQuadGetBasisCurl(e, v, m, quad);
    d = 0.;
    w = quad->weights;
    if (NULL == A) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * (*(g2++));
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}

    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++) {
		    d0 += *(g1) * *(g2++) * *(coef++);
		}
		g1++;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadBasACurlBas(ELEMENT *e, DOF *u, int n, DOF *A, DOF *v, int m,
		       int order)
{
    int i, j, k, nvalues = DofTypeDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *w, *coef;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));

    if (nvalues != DofTypeDim(v))
	phgError(1, "%s:%d, dimensions mismatch: curl(%s) <==> curl(%s)\n",
		 __FILE__, __LINE__, u->name, v->name);

    if (order < 0) {
	order = BasisOrder(u, e, n) + BasisOrder(v, e, m) - 1;
        if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisValues(e, u, n, quad);
    g2 = phgQuadGetBasisCurl(e, v, m, quad);
    d = 0.;
    w = quad->weights;
    if (NULL == A) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * (*(g2++));
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}

    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++) {
		    d0 += *(g1) * *(g2++) * *(coef++);
		}
		g1++;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadFuncDotBas(ELEMENT *e, DOF_USER_FUNC userfunc, DOF *u, int n,
		  int order)
/* computes \int f * ('n'-th basis function of 'u') on element 'e'
 * using quadrature rule of order 'order'. */
{
    int i, j, nvalues;
    const FLOAT *v, *bas, *funcvalues, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type));

    if (order < 0)
	order = DofTypeOrder(u, e) + BasisOrder(u, e, n);
    quad = phgQuadGetQuad3D(order);

    bas = phgQuadGetBasisValues(e, u, n, quad);
    funcvalues = phgQuadGetFuncValues(u->g, e, DofTypeDim(u), userfunc, quad);
    w = quad->weights;
    nvalues = DofTypeDim(u);

    d = 0.;
    for (v = funcvalues, i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	for (j = 0; j < nvalues; j++) {
	    d0 += *(bas++) * (*(v++));
	}
	d += d0 * (*(w++));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadDofDotBas(ELEMENT *e, DOF *u, DOF *v, int n, int order)
/* computes \int 'u' * ('n'-th basis function of 'v') on element 'e'
 * using quadrature rule of order 'order'.
 */
{
    int i, j, nvalues;
    FLOAT d, d0;
    const FLOAT *bas, *dof, *w;
    QUAD *quad;

    assert(!SpecialDofType(v->type));

    if (order < 0) {
	i = DofTypeOrder(u, e);
	j = DofTypeOrder(v, e);
	if (i < 0)
	    i = j;
	order = i + j;
    }
    quad = phgQuadGetQuad3D(order);

    nvalues = DofDim(u);
    if(nvalues != DofTypeDim(v))
	phgError(1,"%s:%d: dimension mismatch\n", __FILE__, __LINE__);

    /* TODO: cache basis functions or values (analytic) of u */
    dof = phgQuadGetDofValues(e, u, quad);
    bas = phgQuadGetBasisValues(e, v, n, quad);
    w = quad->weights;
    d = 0.;
    for (i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	for (j = 0; j < nvalues; j++) {
	    d0 += *(bas++) * *(dof++);
	}
	d += d0 * *(w++);
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadDofABas(ELEMENT *e, DOF *u, DOF *A, DOF *v, int m, int order)
	/*
	 * computes integration of
	 *        DOF u 
	 *        \cdot
	 *        A coefficient
	 *        \cdot
	 *        ('m'-th basis function of 'v')
	 *      on element 'e' using quadrature rule of order 'order'.
	 */
{
    int i, j, k, nvalues = DofDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(u->type) && !SpecialDofType(v->type));
    assert(nvalues == DofTypeDim(v));

    if (order < 0) {
	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
	order += BasisOrder(v, e, m);
        if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetDofValues(e, u, quad);
    g2 = phgQuadGetBasisValues(e, v, m, quad);
    w = quad->weights;

    if (A == NULL) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}
    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++)
		    d0 += *g1 * *(g2++) * *(coef++);
		g1++;
	    }
	    d += d0 * *(w++);
	}

    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadDofAGradBas(ELEMENT *e, DOF *u, DOF *A, DOF *v, int m, int order)
	/*
	 * computes integration of
	 *        DOF u 
	 *        \cdot
	 *        A coefficient
	 *        \cdot
	 *        (gradient of 'm'-th basis function of 'v')
	 *      on element 'e' using quadrature rule of order 'order'.
	 */
{
    int i, j, k, nvalues = DofDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(v->type));
    assert(nvalues == DofTypeDim(v) * Dim);

    if (order < 0) {
	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
	order += BasisOrder(v, e, m) - 1;
        if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetDofValues(e, u, quad);
    g2 = phgQuadGetBasisGradient(e, v, m, quad);
    w = quad->weights;

    if (A == NULL) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * (*(w++));
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}
    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++)
		    d0 += *g1 * *(g2++) * *(coef++);
		g1++;
	    }
	    d += d0 * *(w++);
	}

    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT *
phgQuadDofDotCurlBas_(ELEMENT *e, DOF *u, DOF *v, int m, int order, FLOAT *res)
{
    int i,  nvalues = DofDim(u);
    const FLOAT *g1, *g2, *w;
    FLOAT d;
    QUAD *quad;

    assert(!SpecialDofType(v->type));

    if (order < 0) {
	order = BasisOrder(v, e, m) - 1;
	if (DofTypeOrder(u, e) >= 0)
	    order += DofTypeOrder(u, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetDofValues(e, u, quad);
    g2 = phgQuadGetBasisGradient(e, v, m, quad);
    w = quad->weights;

    if (nvalues == Dim && v->dim == Dim && DofTypeDim(v) == 1) {
        res[0] = res[1] = res[2] = 0.; 
	for (i = 0; i < quad->npoints; i++) {
	    res[0] += (g1[1] * g2[2] - g1[2] * g2[1]) * (*w);
	    res[1] += (g1[2] * g2[0] - g1[0] * g2[2]) * (*w);
	    res[2] += (g1[0] * g2[1] - g1[1] * g2[0]) * (*w);
	    w++;
            g2 += Dim;
	}
	d = phgGeomGetVolume(u->g, e);
        res[0] *= d;
        res[1] *= d;
        res[2] *= d;
	return res;
    } else {
	phgError(1, "%s:%d: unimplement  ", __FILE__, __LINE__);
        return NULL;
    }
}

FLOAT
phgQuadDofACurlBas(ELEMENT *e, DOF *u, DOF *A, DOF *v, int m, int order)
	/*
	 * computes integration of
	 *        DOF u 
	 *        \cdot
	 *        A coefficient
	 *        \cdot
	 *        (Curl of 'm'-th basis function of 'v')
	 *      on element 'e' using quadrature rule of order 'order'.
	 */
{
    int i, j, k, nvalues = DofDim(u), An;
    const FLOAT *g1, *g2, *g2_tmp, *coef, *w;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(v->type));
    assert(nvalues == DofTypeDim(v));

    if (order < 0) {
	order = ((j = DofTypeOrder(u, e)) >= 0 ? j : BasisOrder(v, e, m));
	order += BasisOrder(v, e, m) - 1;
	if (A != NULL && DofTypeOrder(A, e) >= 0)
	    order += DofTypeOrder(A, e);
	if (order < 0)
	    order = 0;
    }
    quad = phgQuadGetQuad3D(order);

    d = 0.;
    g1 = phgQuadGetDofValues(e, u, quad);
    g2 = phgQuadGetBasisCurl(e, v, m, quad);
    w = quad->weights;

    if (A == NULL) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++);
	}
	return d * phgGeomGetVolume(u->g, e);
    }

    An = DofDim(A);
    coef = phgQuadGetDofValues(e, A, quad);
    if (1 == An) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++);
	    }
	    d += d0 * *(w++) * *(coef++);
	}
    }
    else if (An == nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    for (j = 0; j < nvalues; j++) {
		d0 += *(g1++) * *(g2++) * *(coef++);
	    }
	    d += d0 * *(w++);
	}
    }
    else if (An == nvalues * nvalues) {
	for (i = 0; i < quad->npoints; i++) {
	    d0 = 0.;
	    g2_tmp = g2;
	    for (j = 0; j < nvalues; j++) {
		g2 = g2_tmp;
		for (k = 0; k < nvalues; k++)
		    d0 += *g1 * *(g2++) * *(coef++);
		g1++;
	    }
	    d += d0 * *(w++);
	}
    }
    else {
	phgError(1, "%s:%d: dimensions mismatch: coefficient A (%s, %d)",
		 __FILE__, __LINE__, DofTypeName(A), DofTypeDim(A));
    }

    return d * phgGeomGetVolume(u->g, e);
}

FLOAT
phgQuadGradBasDotBas(ELEMENT *e, DOF *s, int m, DOF *v, int n, int order)
	/*
	   S is the voltage soure
	   We choose it as the base function of P1 at vertex m,
	   this function do 
	   int
	   grad S * v
	 */
{
    int i, j, nvalues = DofTypeDim(v);
    const FLOAT *g1, *g2, *w, *lambda;
    FLOAT d, d0;
    QUAD *quad;

    assert(!SpecialDofType(s->type) && !SpecialDofType(v->type));

    if (nvalues != Dim * DofTypeDim(s))
	phgError(1, "%s:%d, dimensions mismatch: grad(%s) <==> (%s)\n",
		 __FILE__, __LINE__, s->name, v->name);

    if (order < 0)
	order = BasisOrder(s, e, m) - 1 + BasisOrder(v, e, n);
    if (order < 0)
	order = 0;
    quad = phgQuadGetQuad3D(order);

    g1 = phgQuadGetBasisGradient(e, s, m, quad);
    g2 = phgQuadGetBasisValues(e, v, n, quad);
    d = 0.;
    lambda = quad->points;
    w = quad->weights;
    for (i = 0; i < quad->npoints; i++) {
	d0 = 0.;
	for (j = 0; j < nvalues; j++) {
	    d0 += *(g1++) * (*(g2++));
	}
	d += d0 * (*(w++));
	lambda += Dim + 1;
    }

    return d * phgGeomGetVolume(s->g, e);
}
