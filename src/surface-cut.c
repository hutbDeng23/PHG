/* Parallel Hierarchical Grid -- an adaptive finite element library.
 *
 * Copyright (C) 2005-2010 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences. */

/* This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301  USA */

/* $Id: surface-cut.c,v 1.70 2022/04/02 08:27:33 zlb Exp $ */

#include "phg.h"
#include "phg/elem-info.h"

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>	/* INT_MAX */

#undef LT
#define LT   <	/* '>': bisect smallest angle (TEST only, don't change) */

#undef TEST
#define TEST 0	/* set to 1 will produce surface-cut.vtk for debugging */

static GRID *g_;
static ELEMENT *eptr;
static INT parent, map[8];	/* mapping of vertices within an element */
static int mark, region_mark;
static CHAR hp_order;

static void
new_tetra(int v0, int v1, int v2, int v3, int bound_type[])
/* Callback function for phgXxxx2Tetra()
 * TODO: add a bound_func argument to phgXxxx2Tetra functions */
{
    int i;

    eptr->elem_type = ET_TETRA;
    eptr->verts[0] = map[v0];
    eptr->verts[1] = map[v1];
    eptr->verts[2] = map[v2];
    eptr->verts[3] = map[v3];

    for (i = 0; i < NFace; i++)
	eptr->bound_type[i] = (bound_type[i] == -1 ? INTERIOR : bound_type[i]);

    eptr->index = (INT)(eptr - g_->roots);
    eptr->mark = mark;
    eptr->region_mark = region_mark;
    eptr->hp_order = hp_order;
    g_->alien_map[eptr->index] = parent;
    eptr++;
}

#if USE_MPI
static struct {
    FLOAT	angle;		/* vertex angle */
    INT		edge_no;	/* global edge no. */
} *shared, *shared0;

static int
comp_shared(const void *p0, const void *p1)
/* compares the entries in keys[] */
{
    INT i = shared[*(const int *)p0].edge_no -
	    shared[*(const int *)p1].edge_no;
    return i > 0 ? 1 : (i < 0 ? -1 : 0);
}
#endif	/* USE_MPI */

static INT *keys0 = NULL;
static FLOAT *keys1 = NULL;

static int
comp_vertices(const void *p0, const void *p1)
/* compares at first the entries in keys1[] (angles), then the entries in
 * keys0[] */
{
    int a = *(const int *)p0, b = *(const int *)p1;

#if 1
    /* first the angles of the two vertices */
    if (keys1[a] != keys1[b])
	return keys1[a] LT keys1[b] ? 1 : -1;
#endif

    /* then the global edge no of the two vertices */
    return keys0[a] - keys0[b];
}

/* The LINK_EDGES macro reorders the vertices such that the two co-planar edges
 * (v0,v1) and (v2,v3) become (v0,v1) and (v0,v2), preserving the order of
 * the two edges */
#define LINK_EDGES(v0, v1, v2, v3)				\
    if (v2 == v1) {						\
	v2 = v0; v0 = v1; v1 = v2; v2 = v3;			\
    }								\
    else if (v3 == v1) {					\
	v3 = v0; v0 = v1; v1 = v3;				\
    }								\
    else if (v2 == v0) {					\
	v2 = v3;						\
    }								\
    else if (v3 != v0) {					\
	int i_;							\
	/* The two edges are not coplanar, raise an error */	\
	phgInfo(-1, "Impermissible case found in %s "		\
		    "(%s:%d, cuts=%d):\n", __func__, __FILE__,	\
		    __LINE__, nv - NVert);			\
	phgInfo(-1, "unexpected non coplanar edges %d-%d and "	\
		    "%d-%d on element %d:\n",			\
		    v0, v1, v2, v3, GlobalVertex(g, e->index));	\
	for (i_ = 0; i_ < NVert; i_++)				\
	    phgInfo(-1, "   v%d=(%0.16lg, %0.16lg, %0.16lg)\n",	\
			i_,					\
			(double)g->verts[e->verts[i_]][0],	\
			(double)g->verts[e->verts[i_]][1],	\
			(double)g->verts[e->verts[i_]][2]);	\
	for (i_ = 0; i_ < NEdge; i_++)				\
	    phgInfo(-1, "   cut%d=%0.16lg\n",			\
			i_, (double)cuts[e->edges[i_]]);	\
	phgError(1, "abort.\n");				\
    }

GRID *
phgSurfaceCut(GRID *g, const FLOAT cuts[])
/* Returns a new mesh generated by cutting the mesh with a given surface.
 *
 * The length of the array cuts[] is g->nedge, which gives the position
 * of the cut point in the range (0, 1) for each edge, a value outside of
 * (0,1) means the edge doesn't have a cut point. The edges are oriented
 * from the vertex with smaller global vertex number to the vertex with
 * larger global vertex number
 *
 * Restrictions:
 *   1. Each edge is allowed to have at most one cut point.
 *
 *   2. Some distributions of cut points in a tetrahedron are not allowed,
 *	the program simply aborts in such cases.
 *
 * Note: Let g_cut = phgSurface(g, ...), then,
 *
 *   1. The 'alien_map' member in g and g_cut is set up to link elements
 *	between the two grids as follows:
 *
 *	If e is an element of g_cut, then
 *	    	g->elems[g_cut->alien_map[e->index]]
 *	is the matching element (either its original or its parent) in g.
 *
 *	If e is an element of g, then
 *	    	g_cut->elems[g->alien_map[e->index]]
 *	is either its copy or its first child in g_cut, and all children of
 *	e in g_cut are numbered continuously (i.e, with contiguous indices).
 *
 *   2. The 'mark', 'region_mark' and 'hp_order' members of the elements of g
 *	are carried over (copied) to the corresponding elements of g_cut.
 *
 * TODO:
 *
 *   1. May change the prototype of this function to use two vertex numbers
 *	for a cut point instead of using edge numbers, to avoid to require
 *	the EDGE_FLAG to be set.
 *
 *   2. Mark the surface.
 */
{
    GRID *g1 = NULL;
    ELEMENT *e;
    INT i;
    INT *e2v;
    struct {
	INT	edge;		/* edge no. of the new vertex */
	BOOLEAN	private;	/* the new vertex is private to this submesh */
    } *v2e;
    int ii, nv, v0 = 0, v1 = 0, v2 = 0, v3 = 0;
    FLOAT t, *angles;

    if (g->period != NULL)
	phgError(1, "%s: unimplemented for periodic boundaries.\n", __func__);

    assert((g->flags & EDGE_FLAG));

    g1 = phgNewGrid(g->flags);
    if (g->filename != NULL)
	g1->filename = strdup(g->filename);

    memcpy(g1->bbox, g->bbox, sizeof(g->bbox));

#if ALLOW_CURVED_BOUNDARY
    if (g->bdry_funcs != NULL) {
	EXPR **p = g->bdry_funcs;
	for (ii = 0; *p != NULL; ii++, p++);
	g1->bdry_funcs = phgAlloc((ii + 1) * sizeof(*g1->bdry_funcs));
	for (ii = 0, p = g->bdry_funcs; *p != NULL; ii++, p++)
	    g1->bdry_funcs[ii] = phgDup3DFunction(*p);
	g1->bdry_funcs[ii] = NULL;
    }
#endif	/* ALLOW_CURVED_BOUNDARY */

    /* count number of vertices and fill edge=>vertex map */
    e2v = phgAlloc(g->nedge * sizeof(*e2v));	/* edge => new vertex map */
    g1->nvert = g->nvert;
    for (i = 0; i < g->nedge; i++) {
	if ((t = cuts[i]) > 0.0 && t < 1.0)
	    e2v[i] = g1->nvert++;
	else
	    e2v[i] = -1;
    }
    g1->verts = phgAlloc(g1->nvert * sizeof(*g1->verts));
    memcpy(g1->verts, g->verts, g->nvert * sizeof(*g1->verts));

    /* allocate and initialize new vertex => edge map */
    v2e = phgAlloc((g1->nvert - g->nvert) * sizeof(*v2e));
    for (i = 0; i < g1->nvert - g->nvert; i++) {
	v2e[i].edge = -1;
	v2e[i].private = TRUE;
    }

    /* count number of elements in g1 and compute coordinates of new vertices */
    g1->nroot = g->nleaf;
    ForAllElements(g, e) {
	for (ii = 0, nv = 0; ii < NEdge; ii++) {
	    i = e2v[e->edges[ii]];
	    if (i < 0)
		continue;
	    nv++;

	    /* compute coordinates of the new vertex and update v2e map */
	    i -= g->nvert;
	    if (v2e[i].edge < 0) {
		COORD *c, *c0, *c1;
		GetEdgeVertices(e, ii, v0, v1);
		c = g1->verts + i + g->nvert;
		c0 = g->verts + e->verts[v0];
		c1 = g->verts + e->verts[v1];
		t = cuts[e->edges[ii]];
		assert(t > 0. && t < 1.);
		(*c)[0] = (1. - t) * (*c0)[0] + t * (*c1)[0];
		(*c)[1] = (1. - t) * (*c0)[1] + t * (*c1)[1];
		(*c)[2] = (1. - t) * (*c0)[2] + t * (*c1)[2];
#if ALLOW_CURVED_BOUNDARY
		/* TODO */
#endif	/* ALLOW_CURVED_BOUNDARY */
		v2e[i].edge = e->edges[ii];
	    }
	    assert(v2e[i].edge == e->edges[ii]);
	}

	/* count number of new elements */
	switch (nv) {
	    case 0: break;
	    case 1: g1->nroot += 1; break;	/* 1 tetra + 1 tetra */
	    case 2: g1->nroot += 2; break;	/* 1 tetra + 1 pyramid */
	    case 3: g1->nroot += 3; break;	/* 1 tetra + 1 prism */
	    case 4: g1->nroot += 5; break;	/* 1 prism + 1 prism */
	    default:				/* not allowed */
		phgError(1, "%s (%s:%d): unexpected case (%d cut points).\n",
				__func__, __FILE__, __LINE__, nv);
	}
    }

    /* compute maximum angle (1-cos(a)) of new vertices */
    angles = phgAlloc((g1->nvert - g->nvert) * sizeof(*angles));
    for (i = 0; i < g1->nvert - g->nvert; i++)
	angles[i] = (0 LT 2 ? 0.0 : 2.0);
    ForAllElements(g, e) {
	/* FIXME: avoid processing each face twice using VEF_MAP */
	for (ii = 0; ii < NFace; ii++) {
	    COORD *c, *c0, *c1;
	    FLOAT x0, y0, z0, x1, y1, z1, a;
	    /* Note: at most two cut points are allowed on each face,
	     * we only need to process the case of two cut points on the face */
	    v0 = GetFaceVertex(ii, 0);
	    v1 = GetFaceVertex(ii, 1);
	    v2 = GetFaceVertex(ii, 2);
	    nv = (e2v[e->edges[GetEdgeNo(v0,v1)]] >= 0 ? 1 : 0) +
		 (e2v[e->edges[GetEdgeNo(v0,v2)]] >= 0 ? 1 : 0) +
		 (e2v[e->edges[GetEdgeNo(v1,v2)]] >= 0 ? 1 : 0);
	    assert(nv < 3);
	    if (nv != 2)
		continue;
	    /* exactly one of the edges doesn't have a cut point, permute the
	     * vertices such that edges (v0,v1) and (v0,v2) have cut points */
	    if (e2v[e->edges[GetEdgeNo(v0,v1)]] < 0) {
		/* exchange v0 and v2 */
		v3 = v0;
		v0 = v2;
		v2 = v3;
	    }
	    else if (e2v[e->edges[GetEdgeNo(v0,v2)]] < 0) {
		/* exchange v0 and v1 */
		v3 = v0;
		v0 = v1;
		v1 = v3;
	    }
	    assert(e2v[e->edges[GetEdgeNo(v0,v1)]] >= g->nvert &&
		   e2v[e->edges[GetEdgeNo(v0,v2)]] >= g->nvert &&
		   e2v[e->edges[GetEdgeNo(v1,v2)]] < 0);
	    /* coordinates of the cut points */
	    c0 = g1->verts + e2v[e->edges[GetEdgeNo(v0,v1)]];
	    c1 = g1->verts + e2v[e->edges[GetEdgeNo(v0,v2)]];

	    x0 = (*c1)[0] - (*c0)[0];
	    y0 = (*c1)[1] - (*c0)[1];
	    z0 = (*c1)[2] - (*c0)[2];
	    t = x0 * x0 + y0 * y0 + z0 * z0;

	    c = g1->verts + e->verts[v1];
	    x1 = (*c)[0] - (*c0)[0];
	    y1 = (*c)[1] - (*c0)[1];
	    z1 = (*c)[2] - (*c0)[2];
	    a = (x1 * x1 + y1 * y1 + z1 * z1) * t;
	    if (a == 0.0)
		a = 1.0;
	    else
		a = 1.0 - (x0 * x1 + y0 * y1 + z0 * z1) / Sqrt(a);
	    i = e2v[e->edges[GetEdgeNo(v0,v1)]] - g->nvert;
	    if (angles[i] LT a)
		angles[i] = a;

	    c = g1->verts + e->verts[v2];
	    x1 = (*c1)[0] - (*c)[0];
	    y1 = (*c1)[1] - (*c)[1];
	    z1 = (*c1)[2] - (*c)[2];
	    a = (x1 * x1 + y1 * y1 + z1 * z1) * t;
	    if (a == 0.0)
		a = 1.0;
	    else
		a = 1.0 - (x0 * x1 + y0 * y1 + z0 * z1) / Sqrt(a);
	    i = e2v[e->edges[GetEdgeNo(v0,v2)]] - g->nvert;
	    if (angles[i] LT a)
		angles[i] = a;
	}
    }

#if USE_MPI
# if !NO_NEW_COMMUNICATOR
    MPI_Comm_free(&g1->comm);
    MPI_Comm_dup(g->comm, &g1->comm);
#else
    g1->comm = g->comm;
# endif /* !NO_NEW_COMMUNICATOR */
    g1->nprocs = g->nprocs;
    g1->rank = g->rank;
    if (g->L2Gmap_vert != NULL) {
	g1->L2Gmap_vert = phgAlloc(g1->nvert * sizeof(*g1->L2Gmap_vert));
	memcpy(g1->L2Gmap_vert, g->L2Gmap_vert,
			g->nvert * sizeof(*g1->L2Gmap_vert));
    }

    if (g1->nprocs > 1) {
	INT j, n, m, no0, no1, *shared0_index;
	int a[4], *counts, *displs, *ordering;
	MPI_Datatype type;
	/* update L2Gmap_vert for new vertices */
	assert(g1->L2Gmap_vert != NULL);
	/* update the private flag of the new vertices */
	ForAllElements(g, e) {
	    for (ii = 0; ii < NEdge; ii++) {
		i = e2v[e->edges[ii]];
		if (i < 0)
		    continue;
		i -= g->nvert;
		assert(v2e[i].edge == e->edges[ii]);
		if (v2e[i].private == FALSE)
		    continue;
		/* Note: the opposite edge of edge i is edge 5 - i */
		v0 = GetEdgeVertex(5 - ii, 0);
		v1 = GetEdgeVertex(5 - ii, 1);
		if ((e->bound_type[v0] | e->bound_type[v1]) & REMOTE)
		    v2e[i].private = FALSE;
	    }
	}
	/* count shared new vertices */
	for (i = 0, n = 0; i < g1->nvert - g->nvert; i++) {
	    assert(v2e[i].edge >= 0 && v2e[i].edge < g->nedge);
	    if (!v2e[i].private)
		n++;
	}
	/* collect shared new vertices */
	shared0 = phgAlloc(n * sizeof(*shared0));
	shared0_index = phgAlloc(n * sizeof(*shared0_index));
	for (i = 0, n = 0; i < g1->nvert - g->nvert; i++) {
	    if (v2e[i].private)
		continue;
	    shared0[n].edge_no = GlobalEdge(g, v2e[i].edge);
	    shared0[n].angle = angles[i];
	    shared0_index[n++] = i + g->nvert;
	}
	assert(n < INT_MAX);
	a[0] = n;				/* # of new shared vertices */
	assert(g1->nvert - g->nvert - n < INT_MAX);
	a[1] = (int)(g1->nvert - g->nvert - n);	/* # of new private vertices */
	phgInfo(2, "old global vertices: %"dFMT"\n", g->nvert_global);
	phgInfo(2, "new vertices: %d shared, %d private.\n", (int)n, a[1]);
	/* gather counts of private and shared vertices */
	counts = phgAlloc(2 * g->nprocs * sizeof(counts));
	displs = counts + g->nprocs;
	MPI_Allgather(a, 2, MPI_INT, counts, 2, MPI_INT, g->comm);
	/* compute starting global index for new private vertices (no0)
	 * and starting global index for new shared vertices (no1) */
	no0 = no1 = g->nvert_global;
	for (ii = 0; ii < g->nprocs; ii++) {
	    if (ii == g->rank)
		no0 = no1;
	    no1 += counts[2 * ii + 1];
	    counts[ii] = counts[2 * ii];
	}
	/* compute displs and total number of shared new vertices (m) */
	m = 0;
	for (ii = 0; ii < g->nprocs; ii++) {
	    displs[ii] = m;
	    m += counts[ii];
	    assert(m < INT_MAX);
	}
	if (m == 0)
	    goto skip_shared;	/* no shared new vertices */
	shared = phgAlloc(m * sizeof(*shared));
	ordering = phgAlloc(m * sizeof(*ordering));
	/* gather lists of shared new vertices */
	MPI_Type_contiguous(sizeof(*shared), MPI_BYTE, &type);
	MPI_Type_commit(&type);
	MPI_Allgatherv(shared0, n, type, shared, counts, displs, type, g->comm);
	MPI_Type_free(&type);
	phgFree(shared0);
	/* compute ordering array for gathered lists */
	for (i = 0; i < m; i++)
	    ordering[i] = i;
	qsort(ordering, m, sizeof(*ordering), comp_shared);
	/* assign global indices to shared vertices */
	a[2] = displs[g->rank];
	assert(a[2] + n < INT_MAX);
	a[3] = a[2] + n;
	n = shared[ordering[0]].edge_no;
	j = -1;
	t = 0.0;
	for (i = 0; i < m; i++) {
	    if (n != shared[ordering[i]].edge_no) {
		if (j >= 0) {
		    j -= g->nvert;
		    assert(j >= 0);
		    if (angles[j] LT t)
			angles[j] = t;
		    j = -1;
		}
		no1++;
		n = shared[ordering[i]].edge_no;
		t = shared[ordering[i]].angle;
	    }
	    else {
		if (t LT shared[ordering[i]].angle)
		    t = shared[ordering[i]].angle;
	    }
	    if (ordering[i] >= a[2] && ordering[i] < a[3]) {
		j = shared0_index[ordering[i] - a[2]];
		phgInfo(4, "%d: shared, edge = %"dFMT", "
			   "global vertex = %"dFMT".\n",
			   j, GlobalEdge(g, v2e[j - g->nvert].edge), no1); 
		g1->L2Gmap_vert[j] = no1;
	    }
	}
	if (j >= 0) {
	    j -= g->nvert;
	    assert(j >= 0);
	    if (angles[j] LT t)
		angles[j] = t;
	}
	no1++;
	phgFree(shared0_index);
	phgFree(shared);
	phgFree(ordering);
skip_shared:
	phgFree(counts);

	/* assign global indices to private new vertices */
	for (i = g->nvert; i < g1->nvert; i++) {
	    if (!v2e[i - g->nvert].private)
		continue;
	    phgInfo(4, "%d: private, edge = %"dFMT", global vertex = %"dFMT"\n",				i, GlobalEdge(g, v2e[i - g->nvert].edge), no0); 
	    g1->L2Gmap_vert[i] = no0++;
	}
	g1->nvert_global = no1;
    }
    else
#endif  /* USE_MPI */
    {
	g1->nvert_global = g1->nvert;
    }

    phgFree(v2e);

    g1->roots = phgNewElements(g1->nroot);
    g1->alien = g;
    g1->alien_map = phgAlloc(g1->nroot * sizeof(*g1->alien_map));

    g->alien = g1;
    g->alien_map = phgCalloc(g->nelem, sizeof(*g1->alien_map));

    /* collect elements for the new mesh */
    g_ = g1;
    eptr = g1->roots;
    ForAllElements(g, e) {
	int bound_type[6], verts[8], edge_list[4], order[8], vi[8];
	INT v[8], gv[8];
	FLOAT av[8];

	g->alien_map[e->index] = (INT)(eptr - g1->roots);

	/* collect all vertices on the tetrahedron */

	/* collect the four vertices of the orignal tetrahedron */
	for (ii = 0; ii < NVert; ii++) {
	    order[ii] = ii;
	    v[ii] = e->verts[ii];
	    gv[ii] = GlobalVertex(g1, v[ii]);
	    av[ii] = 0.0;
	}
	/* collect the new vertices on the tetrahedron */
	for (ii = 0, nv = NVert; ii < NEdge; ii++) {
	    if (e2v[e->edges[ii]] < 0)
		continue;
	    edge_list[nv - NVert] = ii;
	    order[nv] = nv;
	    v[nv] = e2v[e->edges[ii]];
	    gv[nv] = GlobalVertex(g1, v[nv]);
	    av[nv] = angles[v[nv] - g->nvert];
	    nv++;
	}
	if (nv > NVert) {
	    /* build temporary indices with increasing global vertices.
	     * TODO: make use of the angles */
	    keys0 = gv;
	    keys1 = av;
	    qsort(order, nv, sizeof(*order), comp_vertices);
	    for (ii = 0; ii < nv; ii++) {
		map[ii] = v[order[ii]];
		vi[order[ii]] = ii;
	    }
	    /* Note:
	     *	. For vertex i (i is in the range [0..NVert..nv)),
	     *	  its temporary index is vi[i].
	     *	. For a vertex with temporary index i, its local index
	     *	  is map[i]. */
	}
	parent = e->index;		/* for new_tetra() */
	mark = e->mark;			/* for new_tetra() */
	region_mark = e->region_mark;	/* for new_tetra() */
	hp_order = e->hp_order;		/* for new_tetra() */
	switch (nv - NVert) {
	    case 0:		/* no cut points, copy the tetrahedron */
		eptr->elem_type = ET_TETRA;
		memcpy(eptr->verts, e->verts, sizeof(e->verts));
		memcpy(eptr->bound_type, e->bound_type, sizeof(e->bound_type));
#if ALLOW_CURVED_BOUNDARY
		memcpy(eptr->bound_func, e->bound_func, sizeof(e->bound_func));
#endif	/* ALLOW_CURVED_BOUNDARY */
#if Dim == 3
		eptr->type = e->type;
#endif	/* Dim == 3 */
		eptr->index = (INT)(eptr - g1->roots);
		eptr->mark = mark;
		eptr->region_mark = region_mark;
		eptr->hp_order = hp_order;
		g1->alien_map[eptr->index] = parent;
		eptr++;
		break;
	    case 1:		/* 1 cut point, bisect the tetrahedron */
		v0 = GetEdgeVertex(edge_list[0], 0);
		v1 = GetEdgeVertex(edge_list[0], 1);
		v2 = GetEdgeVertex(5 - edge_list[0], 0);
		v3 = GetEdgeVertex(5 - edge_list[0], 1);

		/* the tetrahedron v0, v2, v3, v4 */
		bound_type[0] = -1;
		bound_type[1] = e->bound_type[v2];
		bound_type[2] = e->bound_type[v3];
		bound_type[3] = e->bound_type[v1];
		new_tetra(vi[v0], vi[v2], vi[v3], vi[4], bound_type);

		/* the tetrahedron v1, v2, v3, v4 */
		bound_type[0] = -1;
		bound_type[1] = e->bound_type[v2];
		bound_type[2] = e->bound_type[v3];
		bound_type[3] = e->bound_type[v0];
		new_tetra(vi[v1], vi[v2], vi[v3], vi[4], bound_type);
		break;
	    case 2:		/* 2 cut points, 1 tetra + 1 pyramid */
		v0 = GetEdgeVertex(edge_list[0], 0);
		v1 = GetEdgeVertex(edge_list[0], 1);
		v2 = GetEdgeVertex(edge_list[1], 0);
		v3 = GetEdgeVertex(edge_list[1], 1);
		/* the two edges must be co-planar, reorder the vertices such
		 * that the edges are (v0,v1), (v0, v2) */
		LINK_EDGES(v0, v1, v2, v3)
		v3 = (0+1+2+3) - (v0+v1+v2);	/* the opposite vertex */

		/* the tetrahedron v0, v3, v4, v5 */
		bound_type[0] = -1;
		bound_type[1] = e->bound_type[v3];
		bound_type[2] = e->bound_type[v1];
		bound_type[3] = e->bound_type[v2];
		new_tetra(vi[v0], vi[v3], vi[4], vi[5], bound_type);

		/* the pyramid v1, v2, v5, v4,  v3 */
		verts[0] = vi[v1];
		verts[1] = vi[v2];
		verts[2] = vi[5];
		verts[3] = vi[4];
		verts[4] = vi[v3];
		bound_type[0] = e->bound_type[v0];
		bound_type[1] = e->bound_type[v1];
		bound_type[2] = -1;
		bound_type[3] = e->bound_type[v2];
		bound_type[4] = e->bound_type[v3];
		phgPyramid2Tetra(verts, new_tetra, bound_type);
		break;
	    case 3:		/* 3 cut points, 1 tetra + 1 prism */
		/* the three cut edges must share a common vertex. */
		/* FIXME: how to handle degenerate cases like 0-3 1-2 2-3
		 * (there should be a 4th cut point on edge 0-1, it's not
		 * recorded because it's too close to a vertex) */

		v0 = GetEdgeVertex(edge_list[0], 0);
		v1 = GetEdgeVertex(edge_list[0], 1);
		v2 = GetEdgeVertex(edge_list[1], 0);
		v3 = GetEdgeVertex(edge_list[1], 1);
		/* reorder vertices such that the first 2 edges are
		 * (v0,v1) and (v0,v2) */
		LINK_EDGES(v0, v1, v2, v3)
		/* the vertex opposite to the first 2 cut edges */
		v3 = (0+1+2+3) - (v0+v1+v2);
		assert(v3 == GetEdgeVertex(edge_list[2], 0) ||
		       v3 == GetEdgeVertex(edge_list[2], 1));

		/* now the cut edges are (v0,v1), (v0,v2), and (v0,v3) */

		/* the tetrahedron v0, v4, v5, v6 */
		bound_type[0] = -1;
		bound_type[1] = e->bound_type[v1];
		bound_type[2] = e->bound_type[v2];
		bound_type[3] = e->bound_type[v3];
		new_tetra(vi[v0], vi[4], vi[5], vi[6], bound_type);

		/* the prism v1, v2, v3, v4, v5, v6 */
		verts[0] = vi[v1];
		verts[1] = vi[v2];
		verts[2] = vi[v3];
		verts[3] = vi[4];
		verts[4] = vi[5];
		verts[5] = vi[6];
		bound_type[0] = e->bound_type[v3];
		bound_type[1] = e->bound_type[v1];
		bound_type[2] = e->bound_type[v2];
		bound_type[3] = e->bound_type[v0];
		bound_type[4] = -1;
		phgPrism2Tetra(verts, new_tetra, bound_type);
		break;
	    case 4:		/* 4 cut points, 1 prism + 1 prism */
		/* The two non-cut edges must be opposite to each other
		 * (the following assertion is based on the fact that the sum
		 * of two opposite edge numbers is always 5) */
		assert(edge_list[0] + edge_list[1] + edge_list[2] + edge_list[3]
			 == 0+1+2+3+4+5 - 5);

		/* reorder the edges as (v0,v1), (v1,v2), (v2,v3), (v3,v0) */
		v0 = GetEdgeVertex(edge_list[0], 0);
		v1 = GetEdgeVertex(edge_list[0], 1);

		if (edge_list[1] == 5 - edge_list[0]) {
		    /* edge 1 is opposite to edge 0, xchg edges 1,2 */
		    ii = edge_list[1];
		    edge_list[1] = edge_list[2];
		    edge_list[2] = ii;
		    ii = vi[1 + NVert];
		    vi[1 + NVert] = vi[2 + NVert];
		    vi[2 + NVert] = ii;
		    assert(edge_list[1] != 5 - edge_list[0]);
		}
		v2 = GetEdgeVertex(edge_list[1], 0);
		ii  = GetEdgeVertex(edge_list[1], 1);
		/* reorder vertices such that the first two edges are
		 * (v0,v1) and (v1,v2) */
		LINK_EDGES(v1, v0, v2, ii)

		if (edge_list[2] == 5 - edge_list[1]) {
		    /* edge 2 is opposite to edge 1, xchg edges 2,3 */
		    ii = edge_list[2];
		    edge_list[2] = edge_list[3];
		    edge_list[3] = ii;
		    ii = vi[2 + NVert];
		    vi[2 + NVert] = vi[3 + NVert];
		    vi[3 + NVert] = ii;
		    assert(edge_list[2] != 5 - edge_list[1]);
		}
		v3 = GetEdgeVertex(edge_list[2], 0);
		ii  = GetEdgeVertex(edge_list[2], 1);
		/* reorder vertices such that the edge 2 is (v2,v3) */
		assert(v3 != v1 && ii != v1);
		LINK_EDGES(v2, v1, v3, ii)

		/* edge 3 must equal to (v3,v0) or (v0,v3) */
		assert(
		  ((ii=GetEdgeVertex(edge_list[3], 0)) == v0 || (ii == v3)) &&
		  ((ii=GetEdgeVertex(edge_list[3], 1)) == v0 || (ii == v3)));

		/* Prism v2,v6,v5, v0,v7,v4 */
		verts[0] = vi[v2];
		verts[1] = vi[6];
		verts[2] = vi[5];
		verts[3] = vi[v0];
		verts[4] = vi[7];
		verts[5] = vi[4];
		bound_type[0] = e->bound_type[v1];
		bound_type[1] = -1;
		bound_type[2] = e->bound_type[v3];
		bound_type[3] = e->bound_type[v0];
		bound_type[4] = e->bound_type[v2];
		phgPrism2Tetra(verts, new_tetra, bound_type);

		/* Prism v1,v5,v4, v3,v6,v7 */
		verts[0] = vi[v1];
		verts[1] = vi[5];
		verts[2] = vi[4];
		verts[3] = vi[v3];
		verts[4] = vi[6];
		verts[5] = vi[7];
		bound_type[0] = e->bound_type[v0];
		bound_type[1] = -1;
		bound_type[2] = e->bound_type[v2];
		bound_type[3] = e->bound_type[v3];
		bound_type[4] = e->bound_type[v1];
		phgPrism2Tetra(verts, new_tetra, bound_type);
		break;
	}
    }

    phgFree(e2v);
#if !TEST
    phgFree(angles);
#endif	/* !TEST */

    g1->nroot = (INT)(eptr - g1->roots);
    g1->ntree = g1->nleaf = g1->nelem = g1->nroot;

    phgUpdateNeighbours(g1);

#if USE_MPI
    if (g1->nprocs > 1) {
	MPI_Allreduce(&g1->nleaf, &g1->nelem_global, 1, PHG_MPI_INT, MPI_SUM,
			g1->comm);
	phgUpdateRNeighbours_(g1);
    }
    else
#endif  /* USE_MPI */
    {
	g1->nelem_global = g1->nleaf;
    }

    phgUpdateEdges(g1);
#if Dim == 3
    phgUpdateFaces(g1);
#endif
    phgUpdateElementIndices(g1, 0, 0);

    /*phgCheckConformity(g1);*/
    /*phgRefineInit(g1, TRUE);*/

    if ((g1->flags & (VERT_FLAG | EDGE_FLAG | FACE_FLAG | ELEM_FLAG)))
	phgUpdateBoundaryTypes(g1);
    if ((g1->flags & GEOM_FLAG))
	phgGeomInit(g1);

#if TEST
    {
	/* cut_plane_marker is defined in ../test/cut_test.c */
	extern void cut_plane_marker(FLOAT, FLOAT, FLOAT, FLOAT *);
	DOF *m = phgDofNew(g1, DOF_P0, 1, "marker", cut_plane_marker);
	DOF *a = phgDofNew(g1, DOF_P1, 1, "angles", DofNoAction);
	for (i = 0; i < g1->nvert; i++)
	    a->data[i] = (i < g->nvert ? 0.0 : angles[i - g->nvert]);
	phgExportVTK(g1, "surface-cut.vtk", m, a, NULL);
	phgDofFree(&a);
	phgDofFree(&m);
    }
    phgFree(angles);
#endif	/* TEST */

    return g1;
}

static FLOAT
bisect(COORD *c0, FLOAT f0, COORD *c1, FLOAT f1, FLOAT eps, DOF_USER_FUNC func)
{
    /* without 'volatile', "cut_test2 -eps 1e-20" dead-loops on F18 i386 */
    volatile FLOAT d0 = 0.0, d1 = 1.0, d;
    FLOAT f, x, y, z, x0, y0, z0, x1, y1, z1;

    if (f0 == 0.0)
	return 0.0;
    else if (f1 == 0.0)
	return 1.0;

    x0 = (*c0)[0];
    y0 = (*c0)[1];
    z0 = (*c0)[2];

    x1 = (*c1)[0];
    y1 = (*c1)[1];
    z1 = (*c1)[2];

    while (TRUE) {
	d = (d0 + d1) * 0.5;
	if ((d1 - d0) <= eps || d == d0 || d == d1)
	    break;
	x = (x0 + x1) * 0.5;
	y = (y0 + y1) * 0.5;
	z = (z0 + z1) * 0.5;
	func(x, y, z, &f);
	if (f == 0.0)
	    break;
	if ((f > 0.0) == (f0 > 0.0)) {
	    d0 = d;
	    f0 = f;
	    x0 = x;
	    y0 = y;
	    z0 = z;
	}
	else {
	    d1 = d;
	    f1 = f;
	    x1 = x;
	    y1 = y;
	    z1 = z;
	}
    }

    return d;
}

GRID *
phgSurfaceCut2(GRID *g, FLOAT eps, BTYPE bdry_mask, DOF_USER_FUNC func)
/* Returns a new mesh generated by cutting the mesh with a given surface.
 * The surface is described by an user function 'func' with 'func'==0
 * representing the surface and the sign of 'func' indicating which side
 * of the surface the point belongs.
 *
 * The argument 'eps' (input) specifies the desired precision in the bisection
 * algorithm for finding the cut point on an edge. When 'eps' < 0, linear
 * interpolation will be used in place of bisection (and 'func' should be a
 * continuous function in this case).
 *
 * If 'bdry_mask' != 0 then e->mark in the generated mesh will be set to -1
 * or 1 depending which side of the surface it belongs, and the boundary flags
 * of the faces on the surface will have the 'bdry_mask' bit (or bits) set.
 *
 * The absolute value of 'eps' is always used as the tolerance for dropping
 * a cut point when it's close to a vertex.
 *
 * Note:
 *	This function is based on phgSurfaceCut. It first computes cut points
 *	on the edges using bisection or linear interpolation, then calls
 *	phgSurfaceCut.
 *
 *	This function is assumed robust in the sense that it should ensure that
 *	the set of cut points generated fully meet the consistency requirement
 *	of phgSurfaceCut, and thus will always succeed (while phgSurfaceCut may
 *	fail with some inconsistent distributions of cut points).
 */
{
    INT i;
    GRID *g1;
    ELEMENT *e;
    FLOAT *fv;			/* [nvert], values of 'func' on the vertices */
    char *flags, rescan;	/* [nvert], signness of the vertices */
    FLOAT *cuts;		/* [nedge], cut points on the edges */
    int k;

    assert(g->flags & EDGE_FLAG);

    if (eps < 0.0) {
	fv = phgAlloc(g->nvert * sizeof(*fv));
	eps = -eps;
    }
    else {
	fv = NULL;
    }
    flags = phgAlloc(g->nvert * sizeof(*flags));
    cuts = phgAlloc(g->nedge * sizeof(*cuts));

    /* compute signness of all vertices */
    for (i = 0; i < g->nvert; i++) {
	COORD *c;
	FLOAT d;
	if (g->types_vert[i] == UNREFERENCED)
	    continue;
	c = g->verts + i;
	func((*c)[0], (*c)[1], (*c)[2], &d);
	flags[i] = (d == 0.0 ? 0 : (d > 0.0 ? 1 : -1));
	if (fv != NULL)
	    fv[i] = d;
    }

    /* find the cut-points using bisection */
    for (i = 0; i < g->nedge; i++)
	cuts[i] = -2.0;			/* initialization */
    rescan = 0;
    ForAllElements(g, e) {
	for (k = 0; k < NEdge; k++){
	    int iv0, iv1;
	    INT v0, v1;
	    i = e->edges[k];
	    if (cuts[i] > -1.5)
		continue;
	    cuts[i] = -1.0;
	    GetEdgeVertices(e, k, iv0, iv1);
	    v0 = e->verts[iv0];
	    v1 = e->verts[iv1];
	    if (flags[v0] == 0 || flags[v1] == 0 || flags[v0] == flags[v1])
		continue;
	    if (fv == NULL) {
		/* use bisection to compute the cut point */
		cuts[i] = bisect(g->verts + v0, (FLOAT)flags[v0],
				 g->verts + v1, (FLOAT)flags[v1], eps, func);
	    }
	    else {
		/* use linear interpolation to compute the cut point */
		cuts[i] = fv[v0] / (fv[v0] - fv[v1]);
	    }
	    /* Check whether the cut point is too close to a vertex */
	    if (cuts[i] <= eps) {
		/* remove the cut point and mark v0 as on the surface */
		cuts[i] = -1.0;
		flags[v0] = 0;
		rescan = 1;
	    }
	    else if (cuts[i] >= 1.0 - eps) {
		/* remove the cut point and mark v1 as on the surface */
		cuts[i] = -1.0;
		flags[v1] = 0;
		rescan = 1;
	    }
	}
    }
    if (rescan) {
	/* some vertices are marked as on the surface in the previous loop,
	 * rescan the edges to remove corresponding cut points */
	ForAllElements(g, e) {
	    for (k = 0; k < NVert; k++) {
		if (flags[e->verts[k]] != 0)
		    continue;
		/* remove cuts on edges containing vertex k */
		switch (k) {
		   case 0:
			cuts[e->edges[GetEdgeNo(0,1)]] = -1.0;
			cuts[e->edges[GetEdgeNo(0,2)]] = -1.0;
			cuts[e->edges[GetEdgeNo(0,3)]] = -1.0;
			break;
		   case 1:
			cuts[e->edges[GetEdgeNo(0,1)]] = -1.0;
			cuts[e->edges[GetEdgeNo(1,2)]] = -1.0;
			cuts[e->edges[GetEdgeNo(1,3)]] = -1.0;
			break;
		   case 2:
			cuts[e->edges[GetEdgeNo(0,2)]] = -1.0;
			cuts[e->edges[GetEdgeNo(1,2)]] = -1.0;
			cuts[e->edges[GetEdgeNo(2,3)]] = -1.0;
			break;
		   case 3:
			cuts[e->edges[GetEdgeNo(0,3)]] = -1.0;
			cuts[e->edges[GetEdgeNo(1,3)]] = -1.0;
			cuts[e->edges[GetEdgeNo(2,3)]] = -1.0;
			break;
		}
	    }
	}
    }
    if (phgVerbosity > 0) {
	INT count = 0;
	for (i = 0; i < g->nedge; i++)
	    if (cuts[i] >= 0.0)
		count++;
#if USE_MPI
	i = count;
	MPI_Reduce(&i, &count, 1, PHG_MPI_INT, MPI_SUM, 0, g->comm);
#endif	/* USE_MPI */
	phgPrintf("%s: number of cut points = %"dFMT"\n", __func__, count);
    }

    phgFree(fv);
    phgFree(flags);
    g1 = phgSurfaceCut(g, cuts);
    phgFree(cuts);

    if (bdry_mask != 0) {
	/* we use a vector to compute the sum of e->mark's on the faces */
	DOF_TYPE *t = phgDofCreateSimpleType("ftype", 0, 0, 1, 0);
	DOF *fmark = phgDofNew(g1, t, 1, "fmark", DofNoAction);
	MAP *m = phgMapCreate(fmark, NULL);
	VEC *v = phgMapCreateVec(m, 1);
	v->assembled = FALSE;
	ForAllElements(g1, e) {
	    FLOAT x, y, z, d, lam[] = {0.25, 0.25, 0.25, 0.25};
	    phgGeomLambda2XYZ(g1, e, lam, &x, &y, &z);
	    func(x, y, z, &d);
	    e->mark = (d <= 0.0 ? -1 : 1);
	    for (k = 0; k < NFace; k++)
		phgVecAddEntry(v, 0, phgMapE2L(m, 0, e, k), (FLOAT)e->mark);
	}
	phgVecAssemble(v);
	phgMapLocalDataToDof(m, 1, &fmark, v->data);
	phgVecDestroy(&v);
	phgMapDestroy(&m);
	ForAllElements(g1, e) {
	    for (k = 0; k < NFace; k++) {
		/* Note: value of dof on the face is an integer in [-2,2],
		 * and the face is on the surface <==> value == 0 */
		if (Fabs(*DofFaceData(fmark, e->faces[k])) > 1e-5)
		    continue;
		e->bound_type[k] |= bdry_mask;
		if (g1->flags & VERT_FLAG) {
		    g1->types_vert[e->verts[GetFaceVertex(k, 0)]] |= bdry_mask;
		    g1->types_vert[e->verts[GetFaceVertex(k, 1)]] |= bdry_mask;
		    g1->types_vert[e->verts[GetFaceVertex(k, 2)]] |= bdry_mask;
		}
		if (g1->flags & EDGE_FLAG) {
		    int v0 = GetFaceVertex(k, 0);
		    int v1 = GetFaceVertex(k, 1);
		    int v2 = GetFaceVertex(k, 2);
		    g1->types_edge[e->edges[GetEdgeNo(v0,v1)]] |= bdry_mask;
		    g1->types_edge[e->edges[GetEdgeNo(v0,v2)]] |= bdry_mask;
		    g1->types_edge[e->edges[GetEdgeNo(v1,v2)]] |= bdry_mask;
		}
		if (g1->flags & FACE_FLAG) {
		    g1->types_face[e->faces[k]] |= bdry_mask;
		}
	    }
	}
	phgDofFree(&fmark);
	phgDofTypeFree(&t);
    }

    return g1;
}

/*---------------------------------------------------------------------------*/

static DOF *u_;

static void
lambda_func(DOF *v, ELEMENT *e, int bno, const FLOAT *lambda, FLOAT *values)
{
    GRID *g1 = v->g, *g = u_->g;
    ELEMENT *e1 = NULL;
    INT i, index;		/* range of matching elements in g */
    FLOAT x, y, z, lam0[Dim + 1], d1 = 0.0, d;
    const FLOAT *lam1 = lam0;
    FLOAT lam[Dim + 1];

    phgGeomLambda2XYZ(g1, e, lambda, &x, &y, &z);
    i = g1->alien_map[index = e->index];
    while (i < g->nelem && g->alien_map[i] <= index) {
	if ((e = g->elems[i]) == NULL)
	    continue;
	phgGeomXYZ2Lambda(g, e, x, y, z, lam);
	/* find the minimum value of lam[0-3] */
	d = lam[0];
	if (d > lam[1])
	    d = lam[1];
	if (d > lam[2])
	    d = lam[2];
	if (d > lam[3])
	    d = lam[3];
	if (d >= 0.0) {
	    /* the point is within the element */
	    lam1 = lam;
	    e1 = e;
	    break;
	}
	if (d1 == 0.0 || d1 < d) {
	    /* record current element with largest min(lam[.]) */
	    e1 = e;
	    d1 = d;
	    memcpy(lam0, lam, sizeof(lam0));
	}
	i++;
    }
    /* Note: the point is either within e1 or 'closest' to e1 */
    CheckD_order(v);
    phgDofEval(u_, e1, lam1, values);
}

DOF *
phgDofTransfer(DOF *u, GRID *g1)
/* projects or interpolates a finite element function u to GRID g1.
 *
 * Note: to be reimplemented when a general framework for inter-grid function
 *	 transfer is available. */
{
    GRID *g = u->g;
    DOF *v;

    if (g->alien == NULL || g->alien != g1 ||
	g1->alien == NULL || g1->alien != g)
	phgError(1, "%s: no links between the two grids.\n");

    v = phgDofNew(g1, u->type, u->dim, u->name, DofNoAction);
    u_ = u;
    phgDofSetDataByLambdaFunction(v, lambda_func);

    return v;
}
