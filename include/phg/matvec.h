/* Parallel Hierarchical Grid -- an adaptive finite element library.
 *
 * Copyright (C) 2005-2010 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences. */

/* This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301  USA */

/* $Id: matvec.h,v 1.9 2022/09/21 02:10:15 zlb Exp $ */

#ifndef PHG_MATVEC_H

/** Note: MAT_OP_N=notrans, MAT_OP_T=trans, MAT_OP_D=diagonal
 *	  may add MAT_OP_L=lower triangular part, and
 *	  MAT_OP_U=upper triangular part in the future */
typedef enum {MAT_OP_N, MAT_OP_T, MAT_OP_D} MAT_OP;

/* symmetry */
typedef enum {M_UNSYM = 0, M_SSYM = 1, M_SYM = 2, M_SPD = 3} SYMMETRY;

typedef struct MAT_ MAT;

typedef struct VEC_ {
    int 	magic;		/* magic number */
    struct MAP_	*map;
    FLOAT	*data;
    FLOAT	*offp_data;	/* data in the range [nlocal, localsize) */
    MAT		*mat;		/* the vec is associated (the RHS) with mat */
#if USE_MPI
    /* The members below are only used by phgVecAddEntries_.
     * 
     * WARNING: the following assertion, i.e. the lower part of O2Gmap must
     * match map->O2Gmap, must be held since some codes may rely on it:
     * 		INT size0 = map->localsize - map->nlocal;
     * 		INT size1 = localsize - map->nlocal;
     * 		assert(size1 >= size0 && (size0 == 0 ||
     * 		    !memcmp(O2Gmap, map->O2Gmap, size0 * sizeof(*O2Gmap))));
     *
     */
    INT		*O2Gmap, *ordering;
    INT		localsize, alloc;
#endif	/* USE_MPI */
    int		nvec;		/* number of vectors */
    BOOLEAN	assembled;	/* FALSE ==> needs assembly */
} VEC;

/* The mat-vec multiply function prototype for matrix-free matrices */
typedef int (*MV_FUNC)(MAT_OP op, struct MAT_ *A, VEC *x, VEC *y);

/* struct for a matrix row */
typedef struct {
    FLOAT	*data;		/* data, FLOAT[size] */
    INT		*cols;		/* global col indices, INT[size] */ 
    INT		ncols;		/* number of nonzero cols */
    INT		alloc;		/* allocated size of 'data' and 'cols' */
} MAT_ROW;

/* struct for saving factorized boundary equations, generated by
 * diagonalize_local_bdry_equations() */
typedef struct {
    FLOAT	*lu;	/* lu factorization */
    int		*pvt;	/* pivots */
    INT		*map;	/* indices of the unknowns */
    int		n;	/* number of equations */
} BDRY_EQNS;

/* Note: use PHG_XXXX instead of MAT_XXXX to avoid conflicts with PETSc */
typedef enum {
    PHG_UNPACKED	= 0,
    PHG_PACKED		= 1,
    PHG_DENSE		= 2,	/* for use in the future */
    PHG_MATRIX_FREE	= 3,
    PHG_DESTROYED	= 4	/* matrix entries have been destroyed */
} MAT_TYPE;

typedef enum {
    PHG_UNDEFINED	= 0,	/* undefined */
    PHG_ADD		= 1,	/* add entries */
    PHG_REPLACE		= 2	/* replace entries */
} MAT_MODE;

struct MAT_ {
    int		magic;		/* magic number */
    struct MAP_	*rmap, *cmap;	/* row and column maps */
    MAT_ROW	*rows, row_buffer;
    FLOAT	*diag;		/* diagonal data */
    FLOAT	*diag1;		/* L1 norms of (offd cols + diagonal) */
    MAT_TYPE	type;

    /* Pointers to packed data. Note: packed_ind[] is an array of length
     *		1 + (nprocs > 1 ? 2 * nrows : nrows),
     * which points to start of rows in packed_cols[]/packed_data[].
     *
     * The diagonal part of row i starts/ends at:
     *		packed_ind[i]/packed_ind[i + 1],
     * and if nprocs > 1, then the off-proc part of row i starts/ends at:
     *		packed_ind[j]/packed_ind[j + 1].
     * (where j = mat->rmap->nlocal + 1).
     */
    INT		*packed_cols;	/* packed column indices (length nnz) */
    FLOAT	*packed_data;	/* packed matrix data (length nnz) */
    size_t	*packed_ind;
    size_t	nnz_d, nnz_o;

    /* localsize, O2Gmap and ordering are for off-proc columns in the matrix.
     *
     * WARNING: the following assertion, i.e. the lower part of O2Gmap must
     * match map->O2Gmap, must be held since some codes may rely on it:
     * 		INT size0 = cmap->localsize - cmap->nlocal;
     * 		INT size1 = localsize - cmap->nlocal;
     * 		assert(size1 >= size0 && (size0 == 0 ||
     * 		    !memcmp(O2Gmap, cmap->O2Gmap, size0 * sizeof(*O2Gmap))));
     */
    INT		localsize;
#if USE_MPI
    INT		*O2Gmap;
    INT		*ordering;
    struct COMM_INFO_ *cinfo;	/* COMM_INFO struct */
#endif	/* USE_MPI */

    BOOLEAN	handle_bdry_eqns; /* whether process the bdry equations */

    /* Members for matrix-free matrices. The members mv_a, mv_b and mv_x
     * are for supporting AXPBY-like operations. The effective matrix is:
     *		mv_a * X + mv_b * Y
     * where 'X' is computed using mv_x and 'Y' is computed using mv_func.
     *
     * In the default situations mv_x = NULL, mv_a = 0, and mv_b = 1.
     * Note: mv_func may be NULL if mv_b = 0 */
    FLOAT	mv_a, mv_b;
    MAT		*mv_x;
    MV_FUNC	mv_func;
    void	**mv_data;

    /* members for marking boundary columns */
    INT		bdry_localsize, *bdry;

    /* members for saving factorized local bdry equations */
    BDRY_EQNS	*bdry_eqns;	/* list of local boundary equations */
    INT		bdry_eqns_count, bdry_eqns_allocated;

    /* member for saving bdry columns */
    MAT_ROW	*bdry_rows;	/* list of (saved) boundary columns */

    /* block-matrix data */
    struct {
	int	p, q;			/* PxQ block matrix */
	MAT	**pmat;			/* list of submatrices */
	INT	*nrows, *ncols;		/* # of rows and cols of submatrices */
	INT	*noffp;			/* offp sizes (localsize - nlocal) */
	INT	*nrows_global, *ncols_global;
	INT	**partitions;		/* pointers to cmap->partition */
	FLOAT	*coeff;			/* coefficients */
    } *blocks;

    int		refcount;	/* reference count */
    MAT_MODE	mode;		/* add or replace mode */
    BOOLEAN	assembled;

#if USE_OMP
    INT		nlock;
    omp_lock_t	*locks;		/* locks used by add_columns_to_row() */
    omp_lock_t	lock;		/* lock used by convert_row_index() */
#endif	/* USE_OMP */
};

#define PHG_DECIDE -1

#ifdef __cplusplus
extern "C" {
#endif

void phgMatSetupDiagonal(MAT *mat);
void phgMatPack(MAT *mat);
void phgMatUnpack(MAT *mat);

MAT *phgMatAXPBY_(FLOAT a, MAT *x, FLOAT b, MAT **py,
		  BOOLEAN force_matrix_free);
#define phgMatAXPBY(a, x, b, py) phgMatAXPBY_(a, x, b, py, FALSE)
#define phgMatCopy(src, dest)	phgMatAXPBY(1.0, src, 0.0, dest)

MAT *phgMatGetOffprocRows(MAT *B, INT n, const INT list[],
			  BOOLEAN list_is_ordered, const INT ordering[]);
MAT *phgMatTranspose(MAT *A);
MAT *phgMatMat(MAT_OP transa, MAT_OP transb, FLOAT alpha, MAT *A, MAT *B,
		FLOAT beta, MAT **Cptr);

VEC *phgVecCreate(MPI_Comm, INT m, INT M, int nvec);
void phgVecDestroy(VEC **vec);
VEC *phgVecCopy(VEC *src, VEC **dest);
VEC *phgVecAXPBY(FLOAT a, VEC *x, FLOAT b, VEC **y);

VEC *phgMatVec(MAT_OP op, FLOAT alpha, MAT *A, VEC *x, FLOAT beta, VEC **y);
#define phgMatMultVec(mat, vec, result) \
	 phgMatVec(MAT_OP_N, (FLOAT)1.0, mat, vec, (FLOAT)0.0, result)
    
FLOAT phgVecDot(VEC *x, int which_x, VEC *y, int which_y, FLOAT *res);
FLOAT phgVecNorm2(VEC *src, int which, FLOAT *res);
FLOAT phgVecNorm1(VEC *src, int which, FLOAT *res);
FLOAT phgVecNormInfty(VEC *src, int which, FLOAT *res);

MAT *phgMatDup(MAT *src);
void phgVecDumpMATLAB(VEC *v, const char *var_name, const char *file_name);
void phgMatDumpMATLAB(MAT *A, const char *var_name, const char *file_name);
VEC *phgVecRandomize(VEC *v, long int seed);

MAT *phgMatCreate(MPI_Comm comm, INT m, INT M);
MAT *phgMatCreateNonSquare(MPI_Comm comm, INT m, INT M, INT n, INT N);
MAT *phgMatCreateMatrixFree(MPI_Comm comm, INT m, INT M,
				MV_FUNC mv_func, void *mv_data, ...);
MAT *phgMatCreateMatrixFreeNonSquare(MPI_Comm comm, INT m, INT M, INT n, INT N,
				MV_FUNC mv_func, void *mv_data, ...);
MAT *phgMatCreateBlockMatrix(MPI_Comm comm, int p, int q, MAT *pmat[],
			     FLOAT coeff[], MAT_OP trans[]);

const MAT_ROW *phgMatGetRow_(MAT *mat, INT irow, MAT_ROW *row0);
/* Note: phgMatGetRow copies data to MAT.row_buffer. To avoid this data copy,
 * "NULL" can be used in place of "&(mat)->row_buffer" below. */
#define phgMatGetRow(mat, irow) phgMatGetRow_(mat, irow, &(mat)->row_buffer)
INT phgMatGetNnzInRow(MAT *mat, INT irow, INT *nd, INT *no);
FLOAT phgMatGetEntry_(MAT *A, INT row, INT col, BOOLEAN global_col);
#define phgMatGetEntry(A, row, col)	phgMatGetEntry_(A, row, col, FALSE)
#define phgMatGetLGEntry(A, row, col)	phgMatGetEntry_(A, row, col, TRUE)

void phgMatFreeMatrix(MAT *mat);
void phgMatDestroy(MAT **Mat);

struct MAP_ *phgVecGetMap(VEC *vec);
struct MAP_ *phgMatGetRowMap(MAT *mat);
struct MAP_ *phgMatGetColumnMap(MAT *mat);

void phgMatAssemble(MAT *mat);
void phgMatDisassemble(MAT *mat);
void phgVecAssemble(VEC *vec);
void phgVecDisassemble(VEC *vec);

void phgMatSetMode(MAT *mat, MAT_MODE mode);
#define phgMatSetReplaceMode(mat)	phgMatSetMode(mat, PHG_REPLACE)
#define phgMatSetAddMode(mat)		phgMatSetMode(mat, PHG_ADD)
void phgMatAddEntry_(MAT *mat, INT row, INT col, FLOAT value,
			BOOLEAN row_is_global, BOOLEAN col_is_global,
			BOOLEAN replace);
#define phgMatAddEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, FALSE, FALSE, FALSE)
#define phgMatAddGlobalEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, TRUE, TRUE, FALSE)
#define phgMatAddLGEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, FALSE, TRUE, FALSE)
#define phgMatAddGLEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, TRUE, FALSE, FALSE)

#define phgMatSetEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, FALSE, FALSE, TRUE)
#define phgMatSetGlobalEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, TRUE, TRUE, TRUE)
#define phgMatSetLGEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, FALSE, TRUE, TRUE)
#define phgMatSetGLEntry(mat, row, col, value) \
	phgMatAddEntry_(mat, row, col, value, TRUE, FALSE, TRUE)

void phgMatAddEntries_(MAT *mat,
			INT nrows, const INT *rows, INT ncols, const INT *cols,
			const FLOAT *values, BOOLEAN rows_are_global,
			BOOLEAN cols_are_global, BOOLEAN replace);
#define phgMatAddEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, FALSE, FALSE, \
			  FALSE)
#define phgMatAddGlobalEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, TRUE, TRUE, \
			  FALSE)
#define phgMatAddLGEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, FALSE, TRUE, \
			  FALSE)
#define phgMatAddGLEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, TRUE, FALSE, \
			  FALSE)

#define phgMatSetEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, FALSE, FALSE, \
			  TRUE)
#define phgMatSetGlobalEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, TRUE, TRUE, \
			  TRUE)
#define phgMatSetLGEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, FALSE, TRUE, \
			  TRUE)
#define phgMatSetGLEntries(mat, nrows, rows, ncols, cols, values) \
	phgMatAddEntries_(mat, nrows, rows, ncols, cols, values, TRUE, FALSE, \
			  TRUE)

void phgVecAddEntries_(VEC *vec, int which, INT n,
		       const INT *indices, const FLOAT *values,
		       BOOLEAN global);
void phgVecAddEntry(VEC *vec, int which, INT index, FLOAT value);
void phgVecAddGlobalEntry(VEC *vec, int which, INT index, FLOAT value);

#define phgVecAddEntries(vec, which, n, indices, values) \
	phgVecAddEntries_(vec, which, n, indices, values, FALSE)
#define phgVecAddGlobalEntries(vec, which, n, indices, values) \
	phgVecAddEntries_(vec, which, n, indices, values, TRUE)

#define phgMat2Solver	phgSolverMat2Solver

MAT *phgMatRemoveBoundaryEntries(MAT *mat);

int phgMatEigenSolve(MAT *A, MAT *B, int n, int which, FLOAT tau, int *nit,
		     FLOAT *evals, struct MAP_ *map, DOF **u, ...);

int phgMatDumpCSR(MAT *mat, const char *fn);
int phgVecDump(VEC *vec, const char *fn);

typedef struct SOLVER_ SOLVER;
FLOAT phgMatConditionNumber_(MAT *A, SYMMETRY symmetry, SOLVER *S, SOLVER *St);
#define phgMatConditionNumber(A) phgMatConditionNumber_(A, 0, NULL, NULL)
FLOAT phgMatNormInfty(MAT *A);
MAT *phgMatDiagonalBlockInverse(MAT *A);

#ifdef __cplusplus
}
#endif

#define PHG_MATVEC_H
#endif
