/* Parallel Hierarchical Grid -- an adaptive finite element library.
 *
 * Copyright (C) 2005-2010 State Key Laboratory of Scientific and
 * Engineering Computing, Chinese Academy of Sciences. */

/* This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301  USA */

/* $Id: abaqus.c,v 1.68 2021/11/29 01:45:58 zlb Exp $
 *
 * An experimental ABAQUS (flat) file format reader.
 *
 * Documentations on the .inp file format:
 * 1. "../bibliography/FileFormats/ccx_1.5.ps.gz".
 * 2. The ABAQUS Analysis User's Manual:
 *	"https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usb/book01.html"
 *
 * Sample files: "../mesh-files/{*.inp,cube.abaqus}". See also "../p4est/gmsh/".
 *
 * This file only depends on
 *	"../src/elem-info.c"
 *	"../include/phg/elem-info.h"
 * and the three files can be compiled standalone.
 *
 */

#define CREATE_NEIGHBOUR_LINKS 0	/* WARNING: may have been broken */

#include "phg/elem-info.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

typedef unsigned char BYTE;

/* TODO: handle *NSETs and *ELSETs? */

typedef struct {
    const char	*name;
    short	nnode;
    ELEM_TYPE	type;
} INPUT_TYPE;

static INPUT_TYPE input_types[] = {
    /* 2D elements */
    {"CPS3",		3,	ET_TRIANGLE},
    {"CPS4",		4,	ET_QUAD},
    /* 3D elements */
    {"C3D4",		4,	ET_TETRA},
    {"C3D4H",		4,	ET_TETRA},
    {"C3D10",		10,	ET_TETRA},
    {"C3D10H",		10,	ET_TETRA},
    {"C3D10M",		10,	ET_TETRA},
    {"C3D10MH",		10,	ET_TETRA},
    {"C3D10MHT",	10,	ET_TETRA},
    {"C3D10MT",		10,	ET_TETRA},
    {"C3D6",		6,	ET_PRISM},
    {"C3D6H",		6,	ET_PRISM},
    {"C3D15",		15,	ET_PRISM},
    {"C3D15H",		15,	ET_PRISM},
    {"C3D15V",		15,	ET_PRISM},
    {"C3D15VH",		15,	ET_PRISM},
    {"C3D8",		8,	ET_HEXA},
    {"C3D8H",		8,	ET_HEXA},
    {"C3D8HT",		8,	ET_HEXA},
    {"C3D8I",		8,	ET_HEXA},
    {"C3D8IH",		8,	ET_HEXA},
    {"C3D8R",		8,	ET_HEXA},
    {"C3D8RH",		8,	ET_HEXA},
    {"C3D8RHT",		8,	ET_HEXA},
    {"C3D8RT",		8,	ET_HEXA},
    {"C3D8T",		8,	ET_HEXA},
    {"C3D20",		20,	ET_HEXA},
    {"C3D20H",		20,	ET_HEXA},
    {"C3D20HT",		20,	ET_HEXA},
    {"C3D20R",		20,	ET_HEXA},
    {"C3D20RHT",	20,	ET_HEXA},
    {"C3D20RT",		20,	ET_HEXA},
    {"C3D20T",		20,	ET_HEXA},
    /* elements with variable number of nodes */
    {"C3D27",	/*21--*/27,	ET_HEXA},
    {"C3D27H",	/*21--*/27,	ET_HEXA},
    {"C3D27RH",	/*21--*/27,	ET_HEXA},
};

/* 'verts' contains list of all vertices */
static struct {
    double	coord[3];
    int		index;
} *verts = NULL;

/* 'elems' contains imported elements, and 'elems1' contains tetrahedra
 * tetrahedra generated by tetrahedralize() */
static struct {
    int		verts[8];
#if CREATE_NEIGHBOUR_LINKS
    int		neigh[6];	/* list of (face) neighbours */
#endif	/* CREATE_NEIGHBOUR_LINKS */
    int		index;
    int		region_mark;
    short	type;
#if CREATE_NEIGHBOUR_LINKS
    short	neigh_face[6];	/* the matching face of the neighbours */
#endif	/* CREATE_NEIGHBOUR_LINKS */
} *elems = NULL, *elems1 = NULL;

static int nvert = 0, nvert_allocated = 0;
static int nelem = 0, nelem_allocated = 0;
static int nelem1 = 0, nelem1_allocated = 0;
static int region_mark = 0;

#define FLOAT_CHARS_MAX	20	/* float numbers have at most 20 chars */
#define INT_DIGITS_MAX	9	/* intergers have at most 9 digits */
#define STRING_MAX	80	/* strings are case insensitive, <= 80 */
#define LINE_MAX	256	/* input line length limit is 256 */

static char *
next_key(FILE *f_in)
/* returns next keyword line, which is stored in "buffer".
 * 'skip' != 0 ==> skip data */
{
    static int is_first_key = 1;
    static char buffer[10 * LINE_MAX + 1];
    char *line, *p, *q;

    line = buffer;
    while (1) {
	if (fgets(line, sizeof(buffer), f_in) == NULL)
	    return NULL;
	/* delete spaces in the keyword line */
	for (p = q = line; *q != '\0'; q++)
	    if (!isspace(*(BYTE *)q))
		*(p++) = *q;
	*p = '\0';
	if (line[0] != '*') {
	    if (is_first_key)
		return NULL;
	    continue;
	}
	if (line[1] != '*')
	    break;
    }

    if (p > line && *(p - 1) == ',') {
	/* append continuation lines */
	while (1) {
	    line = p;
	    if (line + LINE_MAX > buffer + (sizeof(buffer) - 1)) {
		fprintf(stderr, "%s:%d: too many continuation lines, abort.\n",
			__FILE__, __LINE__);
		exit(1);
	    }
	    if (fgets(line, sizeof(buffer) - (buffer - line), f_in) == NULL)
		break;
	    /* delete spaces in the keyword line */
	    for (p = q = line; *q != '\0'; q++)
	    if (!isspace(*(BYTE *)q))
		*(p++) = *q;
	    *p = '\0';
	    if (p <= line || *(p - 1) != ',')
		break;
	}
    }

    is_first_key = 0;
    return buffer;
}

static int
check_key(const char *line, const char *key)
/* checks whether the line contains 'key', and returns !0 if yes */
{
    char p, q;

    while (*key != '\0') {
	p = toupper(*(line++));
	q = toupper(*(key++));
	if (p != q)
	    return 0;
    }

    return *line == ',' || *line == '\0';
}

static char *
get_parameter(const char *line, const char *key, char *value, int size)
/* gets the value from 'key=value', returns NULL of not found */
{
    int len = strlen(key);
    const char *end = NULL;

    if ((line = strchr(line, ',')) == NULL)
	return NULL;
    line++;	/* skip ',' */

    do {
	if (*line == '\0')
	    return NULL;
	if (!strncasecmp(line, key, len)) {
	    /* Note: keywords can be partially specified */
	    line += len;
	    /* find the ending position for this parameter */
	    if ((end = strchr(line, ',')) == NULL)
		end = line + strlen(line);
	    /* drop trailing spaces */
	    while (end > line && isspace(*(end - 1)))
		end--;
	    /* skip characters before '=' */
	    while (line < end && *line != '=')
		line++;
	    if (*line == '=')
		line++;
	    break;
	}
	line++;
    } while (1);

    for (len = 0; line < end;) {
	assert(len < size - 1);
	value[len++] = *(line++);
    }

    value[len] = '\0';

    return value;
}

static int
get_number(FILE *f_in)
/* reads an integer number (>0) from the file, returns -1 if the next token
 * is not a number */
{
    int c;

    do {
	if ((c = fgetc(f_in)) == EOF)
	    return -1;
	if (isspace((BYTE)c))
	    continue;
	if (c == ',')
	    return 0;
	ungetc(c, f_in);
	if (!isdigit(c))
	    return -1;
	if (fscanf(f_in, "%d,", &c) != 1) {
	    fprintf(stderr, "%s:%d: unexpected error.\n", __FILE__, __LINE__);
	    exit(1);
	}
	return c;
    } while (1);
}

static void
get_token(FILE *f_in, char *token, int size)
/* returns the trailing ',' together if present */
{
    int c, skip = 0;

    do {
	c = fgetc(f_in);
	if (c == EOF || (!isspace((BYTE)c) && c != ','))
	    break;
    } while (1);

    assert(size > 1);
    *(token++) = c;
    size--;

    do {
	c = fgetc(f_in);
	if (c == EOF || c == '\n')
	    break;
	if (isspace((BYTE)c)) {
	    skip = 1;
	    continue;
	}
	if (!skip || c == ',') {
	    if (--size <= 0) {
		fprintf(stderr, "%s:%d: buffer overflow, abort.\n",
			__FILE__, __LINE__);
		exit(1);
	    }
	    *(token++) = c;
	    if (c == ',')
		break;
	    else
		continue;
	}
	ungetc(c, f_in);
	break;
    } while (1);

    *token = '\0';
    return;
}

static int
read_nodes(const char *line, FILE *f_in)
/* If the key is "*NODE" then reads the group of nodes which follows
 * and returns !0, otherwise returns 0. */
{
    int i, no, nread = 0;
    char s[LINE_MAX + 1], *p;

    if (!check_key(line, "*node"))
	return 0;

    /* fprintf(stderr, "  reading nodes: ");*/
    while (1) {
	if ((no = get_number(f_in)) <= 0)
	    break;
	if (no > nvert_allocated) {
	    i = no + 1024;
	    verts = realloc(verts, i * sizeof(*verts));
	    while (nvert_allocated < i)
		verts[nvert_allocated++].index = -1;
	}
	if (no > nvert)
	    nvert = no;
	if (verts[no - 1].index >= 0)
	    fprintf(stderr, "warning: overriding node %d. ", no);
	verts[no - 1].index = no - 1;
	for (i = 0; ; i++) {
	    get_token(f_in, s, sizeof(s));
	    while ((p = strchr(s,'d')) != NULL || (p = strchr(s,'D')) != NULL)
		*p = 'E';
	    if (i < 3)
		verts[no - 1].coord[i] = atof(s);
	    if (s[strlen(s) - 1] != ',')
		break;
	}
	while (++i < 3)
	    verts[no - 1].coord[i] = 0.;
	nread++;
    }

    /*fprintf(stderr, "%d vertices read.\n", nread);*/
    return 1;
}

static int
comp_etype(const void *p0, const void *p1)
{
    const INPUT_TYPE *it0 = p0, *it1 = p1;

    return strcasecmp(it0->name, it1->name);
}

static int
read_elements(const char *line, FILE *f_in)
/* Reads the group of elements if the key is "*Element" with a known type or
 * "*Elset" following a known type and returns !0, otherwise returns 0. */
{
    int initialized = 0;
    int i, j, n, no, nread = 0;
    char s[LINE_MAX + 1];
    static INPUT_TYPE *it = NULL;
    static int region_marks[] = {0, 0, 0};

    /* find the type in input_types */
    n = sizeof(input_types) / sizeof(*it);

    if (!initialized) {
	initialized = 1;
	qsort(input_types, n, sizeof(*it), comp_etype);
    }

    if (check_key(line, "*element")) {
	INPUT_TYPE it0;	/* variable for the bsearch key */
	/* get element type */
	if (!get_parameter(line, "type", s, sizeof(s))) {
	    fprintf(stderr, "%s:%d: unexpected error.\n", __FILE__, __LINE__);
	    exit(1);
	}
	it0.name = s;
	it = bsearch(&it0, input_types, n, sizeof(it0), comp_etype);
	if (it == NULL) {
	    /* fprintf(stderr, "  ignoring element type \"%s\"\n", s);*/
	    return 0;
	}
    }
#if 0
    else if (check_key(line, "*elset")) {
	/* Assign elements or element sets to a element set */
	TODO
    }
#endif
    else {
	return 0;
    }

    n = it->nnode;
    region_mark = region_marks[(int)phgElemInfo[it->type].dim];
    while (1) {
	if ((no = get_number(f_in)) <= 0)
	    break;
	if (no > nelem_allocated) {
	    i = no + 1024;
	    elems = realloc(elems, i * sizeof(*elems));
	    while (nelem_allocated < i) {
		elems[nelem_allocated].type = -1;
		elems[nelem_allocated].index = -1;
#if CREATE_NEIGHBOUR_LINKS
#warning handle 2D elements!
		for (j = 0; j < phgElemInfo[it->type].nface; j++)
		    elems[nelem_allocated].neigh[j] = -1;
#endif
		nelem_allocated++;
	    }
	}
	if (no > nelem)
	    nelem = no;
	if (elems[no - 1].index >= 0)
	    fprintf(stderr, "warning: overriding element %d. ", no);
	elems[no - 1].index = no - 1;
	elems[no - 1].type = it->type;
	elems[no - 1].region_mark = region_mark;
	for (i = 0; ; i++) {
	    get_token(f_in, s, sizeof(s));
	    j = atoi(s) - 1;
	    if (j < 0 || j >= nvert) {
		fprintf(stderr, "%s:%d: unexpected error (j=%d, nvert=%d).\n",
			__FILE__, __LINE__, j, nvert);
		exit(1);
	    }
	    if (i < phgElemInfo[it->type].nvert) {
		elems[no - 1].verts[i] = j;
	    }
	    if (s[strlen(s) - 1] != ',')
		break;
	}
	while (++i < phgElemInfo[it->type].nvert)
	    elems[no - 1].verts[i] = 0;
	nread++;
    }

    if (get_parameter(line, "elset", s + 1, sizeof(s) - 1)) {
	s[0] = '"';
	strcat(s, "\"");
    }
    else {
	strcpy(s, "undefined");
    }

    fprintf(stderr, "    Elset %s, type \"%s\" (%s): region_mark %d, "
		    "%d element%s.\n", s, it->name, phgElemInfo[it->type].name,
		    region_mark, nread, nread <= 1 ? "" : "s");

    region_marks[(int)phgElemInfo[it->type].dim]++;

    return 1;
}

/*============================ Update neighbours ============================*/

#if CREATE_NEIGHBOUR_LINKS

typedef struct {
    int		eno;
    short	vno;
} VMap;

static int
comp_vmap(const void *p0, const void *p1)
{
    return ((const VMap *)p0)->eno - ((const VMap *)p1)->eno;
}

static int
comp_short(const void *p0, const void *p1)
{
    return (*(const short *)p0) - (*(const short *)p1);
}

static int
comp_face(int n, short *vlist, short *vlist0)
{
    int i;

    qsort(vlist, n, sizeof(*vlist), comp_short);
    for (i = 0; i < n; i++)
	if (bsearch(vlist0 + i, vlist, n, sizeof(*vlist), comp_short) == NULL)
	    return 0;
    return 1;
}

static int
find_face(int eno, int fno, int eno1)
/* find the face of element 'eno1' matching the face 'fno' of 'eno0' */
{
    int vlist[4], vlist1[4];
    int nv = phgElemInfo[elems[eno].type].face_info[fno][0];
    int nface1 = phgElemInfo[elems[eno1].type].nface;
    int i, j, k, k0;

    /* extract list of nodes of the source face */
    for (i = 0; i < nv; i++) {
	k = phgElemInfo[elems[eno].type].face_info[fno][i + 1];
	vlist[i] = elems[eno].verts[k];
    }

    /* loop on faces of 'eno1' */
    for (j = 0; j < nface1; j++) {
	if (phgElemInfo[elems[eno1].type].face_info[j][0] != nv)
	    continue;
	/* extract list of nodes of the target face */
	for (i = 0; i < nv; i++) {
	    k = phgElemInfo[elems[eno1].type].face_info[j][i + 1];
	    vlist1[i] = elems[eno1].verts[k];
	}
	/* compare vlist with vlist1.
	 * Note: it is assumed the nodes are in circular order */
	for (k0 = 0; k0 < nv; k0++)
	    if (vlist[0] == vlist1[k0])
		break;
	if (k0 >= nv)
	    continue;
	/* check the increasing order */
	for (i = 1, k = k0; i < nv; i++) {
	    if (++k >= nv)
		k = 0;
	    if (vlist[i] != vlist1[k])
		break;
	}
	if (i >= nv)
	    return j;		/* found */
	/* check decreasing order */
	for (i = 1, k = k0; i < nv; i++) {
	    if (--k < 0)
		k = nv - 1;
	    if (vlist[i] != vlist1[k])
		break;
	}
	if (i >= nv)
	    return j;		/* found */
    }

    return -1;
}

static void
update_neighbours(void)
{
    struct {		/* vertex -> elements map */
	int	*elist;
	short	nlist, nalloc;
    } *vmap, *v;
    int i, j, k, l, n;

    if (nvert == 0 || nelem == 0)
	return;

    vmap = malloc(nvert * sizeof(*vmap));
    for (i = 0; i < nvert; i++) {
	vmap[i].elist = NULL;
	vmap[i].nlist = vmap[i].nalloc = 0;
    }

    /* collect elements vertices */
    for (i = 0; i < nelem; i++) {
	for (j = 0; j < phgElemInfo[elems[i].type].nvert; j++) {
	    v = vmap + (n = elems[i].verts[j]);
	    if (v->nlist >= v->nalloc)
		v->elist = realloc(v->elist,
					(v->nalloc += 32) * sizeof(*v->elist));
	    v->elist[v->nlist++] = i;
	}
    }

    /* loop on all elements */
    for (i = 0; i < nelem; i++) {
	VMap *elist;
	char vflag[sizeof(elems->verts) / sizeof(elems->verts[0])];
	int nface, min_nodes, max_nodes; /* min/max # of nodes on a face */
	short vlist[4];

	min_nodes = 4;
	max_nodes = 3;
	memset(vflag, 0, sizeof(vflag));
	nface = phgElemInfo[elems[i].type].nface;
	/* FIXME: looping on all vertices of the element once instead of face
	 * by face is faster (see find_neighbours_callback1 in utils.c) */
	for (j = 0; j < nface; j++) {	/* loop on faces */
	    if (elems[i].neigh[j] >= 0)
		continue;		/* skip matched faces */
	    k = phgElemInfo[elems[i].type].face_info[j][0];
	    if (min_nodes > k)
		min_nodes = k;
	    if (max_nodes < k)
		max_nodes = k;
	    for (l = 0; l < k; l++) {
		vflag[phgElemInfo[elems[i].type].face_info[j][l + 1]] = 1;
	    }
	}

	if (min_nodes > max_nodes)
	    continue;		/* all faces matched */

	/* collect elements from vmap[].elist entries. */
	n = 0;
	for (j = 0; j < phgElemInfo[elems[i].type].nvert; j++) {
	    if (vflag[j] == 0)
		continue;
	    n += vmap[elems[i].verts[j]].nlist;
	}
	n -= phgElemInfo[elems[i].type].nvert;
	if (n <= 0)
	    continue;
	elist = malloc(n * sizeof(*elist));
	n = 0;
	for (j = 0; j < phgElemInfo[elems[i].type].nvert; j++) {
	    if (vflag[j] == 0)
		continue;
	    l = vmap[elems[i].verts[j]].nlist;
	    for (k = 0; k < l; k++) {
		if (vmap[elems[i].verts[j]].elist[k] == i)
		    continue;
		elist[n].eno = vmap[elems[i].verts[j]].elist[k];
		elist[n++].vno = j;
	    }
	}
	qsort(elist, n, sizeof(*elist), comp_vmap);
	/* check duplicity of entries in elist */
	j = -1;		/* current element index */
	k = 0;		/* count of duplicate elements */
	for (l = 0; l <= n; l++) {
	    if (l >= n || j != elist[l].eno) {
		if (k >= min_nodes) {
		    int ii, jj;
		    for (ii = 0; ii < nface; ii++) {
			FACE_INFO *vf;
			if (elems[i].neigh[ii] >= 0)
			    continue;
			vf = phgElemInfo[elems[i].type].face_info + ii;
			if (k != (*vf)[0])
			    continue;
			/* check face ii */
			if (comp_face(k, vlist, (*vf) + 1))
			    break;
		    }
		    if (ii < nface) {
			/* got a pair of matched face */
			jj = find_face(i, ii, j);
			assert(jj >= 0);
			if (elems[j].neigh[jj] >= 0) {
			    fprintf(stderr, "Error: multiply linked face.\n");
			    exit(1);
			}
			elems[i].neigh[ii] = j;
			elems[i].neigh_face[ii] = jj;
			elems[j].neigh[jj] = i;
			elems[j].neigh_face[jj] = ii;
		    }
		}
		if (l >= n)
		    break;
		j = elist[l].eno;
		vlist[0] = elist[l].vno;
		k = 1;
	    }
	    else {
		assert(k < max_nodes);
		vlist[k++] = elist[l].vno;
	    }
	}
	free(elist);
    }

    for (i = 0; i < nvert; i++) {
	if (vmap[i].elist != NULL)
	    free(vmap[i].elist);
    }
    free(vmap);
}

#endif	/* CREATE_NEIGHBOUR_LINKS */

/*============================= Tetrahedralize ==============================*/

static void
new_tetra(int v0, int v1, int v2, int v3, int bound_type[])
{
    (void)bound_type;

    if (nelem1 >= nelem1_allocated) {
	nelem1_allocated += 1024;
	elems1 = realloc(elems1, nelem1_allocated * sizeof(*elems1));
    }
    elems1[nelem1].type = ET_TETRA;
    elems1[nelem1].region_mark = region_mark;
    elems1[nelem1].index = nelem + nelem1;
#if CREATE_NEIGHBOUR_LINKS
    elems1[nelem1].neigh[0] = elems1[nelem1].neigh[1] =
    elems1[nelem1].neigh[2] = elems1[nelem1].neigh[3] = -1;
#endif
    elems1[nelem1].verts[0] = v0;
    elems1[nelem1].verts[1] = v1;
    elems1[nelem1].verts[2] = v2;
    elems1[nelem1].verts[3] = v3;
    nelem1++;
}

static int have_hexa = 1;

static void
tetrahedralize(void)
{
    int i;

    for (i = 0; i < nelem; i++) {
	region_mark = elems[i].region_mark;
	switch (elems[i].type) {
	    case ET_TETRA:
		break;
	    case ET_PRISM:
		phgPrism2Tetra(elems[i].verts, new_tetra, NULL);
		break;
	    case ET_HEXA:
#if 0		/* do nothing, leaving hexahedral elements unchanged */
		phgHexa2Tetra(elems[i].verts, new_tetra, NULL);
		have_hexa = 0;
#endif
		break;
	}
    }
}

/*===========================================================================*/

int
main(int argc, char *argv[])
{
    FILE *f_in;
    const char *key;
    int i, j, type, n;
    int *counts;
    int tetrahedral_mesh = 1;

    if (argc != 2) {
	fprintf(stderr,
"This program reads mesh data from an Abaqus .inp file, and outputs them to\n"
"stdout in the Medit mesh file format to stdout. Usage:\n"
"\t%% %s infile.inp [>outfile.mesh]\n",
		argv[0]);
	exit(1);
    }

    if ((f_in = fopen(argv[1], "rt")) == NULL) {
	fprintf(stderr, "Can not open file \"%s\"\n", argv[1]);
	exit(1);
    }

    fprintf(stderr, "Processing \"%s\".\n", argv[1]);
    while (1) {
	if ((key = next_key(f_in)) == NULL)
	    break;
	/*fprintf(stderr, "%s", key);*/
	if (read_nodes(key, f_in))
	    continue;
	if (read_elements(key, f_in))
	    continue;
    }

    fclose(f_in);

    /* Remap vertices, remove undefined elements/vertices */

    /* construct new indices of vertices */
    for (i = 0, n = 0; i < nvert; i++) {
	if (verts[i].index < 0)
	    continue;
	verts[i].index = n++;
    }
    /* construct new indices of elements */
    for (i = 0, n = 0; i < nelem; i++) {
	if (elems[i].index < 0)
	    continue;
	elems[i].index = n++;
    }
    /* update neighbours and vertices of elements */
    for (i = 0; i < nelem; i++) {
	if (elems[i].index < 0)
	    continue;
	for (j = 0; j < phgElemInfo[elems[i].type].nvert; j++) {
	    n = elems[i].verts[j];
	    elems[i].verts[j] = verts[n].index;
	}
#if CREATE_NEIGHBOUR_LINKS
	/* The following is unnecessary since neigh[] is not yet generated */
	for (j = 0; j < phgElemInfo[elems[i].type].nface; j++) {
	    if ((n = elems[i].neigh[j]) < 0)
		continue;
	    elems[i].neigh[j] = elems[n].index;
	}
#endif
    }
    /* remove unused vertices */
    for (i = 0, n = 0; i < nvert; i++) {
	if (verts[i].index < 0)
	    continue;
	if (i != n)
	    verts[n] = verts[i];
	n++;
    }
    nvert = n;
    /* remove unused elements */
    for (i = 0, n = 0; i < nelem; i++) {
	if (elems[i].index < 0)
	    continue;
	if (n != i)
	    elems[n] = elems[i];
	n++;
    }
    nelem = n;

    fprintf(stderr, "Total number of vertices: %d\n", nvert);
    fprintf(stderr, "Total number of elements: %d", nelem);
    /* statistics by type */
    counts = malloc(phgElemInfoCount * sizeof(*counts));
    for (type = 0; type < phgElemInfoCount; type++)
	counts[type] = 0;
    for (i = 0; i < nelem; i++)
	counts[elems[i].type]++;
    j = 0;
    for (type = 0; type < phgElemInfoCount; type++) {
	if (counts[type] == 0)
	    continue;
	if (type != ET_TETRA)
	    tetrahedral_mesh = 0;
	fprintf(stderr, "%s%s: %d", j ? ", " : " (", phgElemInfo[type].name,
			counts[type]);
	j = 1;
    }
    fprintf(stderr, "%s", j ? ")\n" : "\n");

#if CREATE_NEIGHBOUR_LINKS
    /* Generate neighbour links. It is not needed by the current
     * tetrahedralization, but may reveal some mesh inconsistencies.
     * The code may also be moved to PHG lib in the future */
    update_neighbours();
#endif	/* CREATE_NEIGHBOUR_LINKS */

    /* Convert to tetrahedral mesh */
    if (!tetrahedral_mesh) {
	fprintf(stderr, "Tetrahedralizing mesh.\n");
	tetrahedralize();
	fprintf(stderr, "Total number of tetrahedra: %d\n",
		counts[ET_TETRA] + nelem1);
    }

#if CREATE_NEIGHBOUR_LINKS
    /* TODO: update neighbour links for the new tetrahedra */
#endif	/* CREATE_NEIGHBOUR_LINKS */

    /* Dump Medit format */
    if (nelem == 0)
	goto end;

    /* Medit header */
    printf("MeshVersionFormatted 1\nDimension 3\n\n");

    /* list of nodes */
    printf("Vertices %d\n", nvert);
    for (i = 0; i < nvert; i++) {
	printf("%0.16lg %0.16lg %0.16lg 0\n",
		verts[i].coord[0], verts[i].coord[1], verts[i].coord[2]);
    }

    /* Tetrahedral elements */
    /* Note: there are only tetrahedral elements in 'elems1' */
    if (counts[ET_TETRA] + nelem1 > 0) {
	printf("\nTetrahedra %d\n", counts[ET_TETRA] + nelem1);
	for (i = 0; i < nelem; i++) {
	    if (elems[i].type != ET_TETRA)
		continue;
	    printf("%d %d %d %d %d\n",
				elems[i].verts[0] + 1, elems[i].verts[1] + 1,
				elems[i].verts[2] + 1, elems[i].verts[3] + 1,
				elems[i].region_mark);
	}
	for (i = 0; i < nelem1; i++) {
	    printf("%d %d %d %d %d\n",
				elems1[i].verts[0] + 1, elems1[i].verts[1] + 1,
				elems1[i].verts[2] + 1, elems1[i].verts[3] + 1,
				elems[i].region_mark);
	}
    }

    /* Other types of elements */
    for (type = 0; type < phgElemInfoCount; type++) {
	if (counts[type] == 0)
	    continue;
	if (type == ET_TETRA)
	    continue;
	if (type == ET_HEXA && !have_hexa)
	    continue; 	/* note: !have_hexa -> hexa converted to tetra */
	if (phgElemInfo[type].medit_name == NULL)
	    continue;
	printf("\n%s %d\n", phgElemInfo[type].medit_name, counts[type]);
	for (i = 0; i < nelem; i++) {
	    if (elems[i].type != type)
		continue;
	    for (j = 0; j < phgElemInfo[type].nvert; j++)
		printf("%d ", elems[i].verts[j] + 1);
	    printf("%d\n", elems[i].region_mark);
	}
    }

    free(counts);

end:
    if (verts != NULL) {
	free(verts);
	verts = NULL;
    }

    if (elems != NULL) {
	free(elems);
	elems = NULL;
    }

    if (elems1 != NULL) {
	free(elems1);
	elems1 = NULL;
    }

    return 0;
}
